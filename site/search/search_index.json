{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>This library is a wrapper of the great rich library that extends rich.text.Text to allow for the easy generation gradient text from either user entered colors or randomly if no colors are entered.</p> <p>Borrowing from rich-color-ext rich_gradient extends the rich standard colors to include:</p> <ul> <li>3 or 6 digit hex code (e.g. <code>#f00</code> or <code>#ff0000</code>)</li> <li>RGB color codes (e.g. <code>rgb(255, 0, 0)</code>)</li> <li>RGB tuples   (e.g. <code>(255, 0, 0)</code>)</li> <li>CSS3 Color Names (e.g. <code>rebeccapurple</code>)</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#uv-recommended","title":"uv (Recommended)","text":"<pre><code>uv add rich-gradient\n</code></pre>"},{"location":"#pip","title":"Pip","text":"<pre><code>pip install rich-gradient\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#text-example","title":"Text Example","text":"<p>To print a simple gradient import the <code>Text</code> class from in the <code>rich_gradient</code> library:</p> <p></p>"},{"location":"#gradient","title":"Gradient","text":"<p>If just text is boring, <code>rich_gradient.gradient.Gradient</code> allows you to apply a gradient to any <code>rich.console.ConsoleRenderable</code>. Such as a <code>rich.panel.Panel</code> or <code>rich.table.Table</code>;</p> <pre><code>table = Table(\n    title=\"Gradient Table Example\",\n    border_style=\"bold\",\n)\ntable.add_column(\n    \"Renderable\",\n    style=\"bold\",\n    vertical=\"middle\",\n    justify=\"right\"\n)\ntable.add_column(\"Works w/Gradient\", justify=\"left\", style=\"bold\")\nrenderables = [\n    \"Text\",\n    \"Panel\",\n    \"Syntax\",\n    \"Table\",\n    \"Live\",\n    \"Group\",\n    \"Markdown\"\n]\nfor renderable in renderables:\n    table.add_row(\n        renderable,\n        \"[b]:heavy_check_mark:[/b]\"\n    )\n\nconsole.print(Gradient(table, rainbow=True), justify=\"center\")\n</code></pre> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#v032-2025-06-26-added-tests-and-renamed-rule","title":"v0.3.2 - 2025-06-26 |  Added tests and renamed Rule","text":""},{"location":"CHANGELOG/#v032-removed","title":"v0.3.2 Removed","text":"<ul> <li>Dev Dependencies</li> <li><code>snoop</code></li> <li><code>cheap-repr</code></li> </ul>"},{"location":"CHANGELOG/#v032-updated","title":"v0.3.2 Updated","text":"<ul> <li>Removed instances that were imported from:</li> <li><code>snoop</code><ul> <li><code>@snoop()</code></li> </ul> </li> <li><code>cheap-repr</code><ul> <li><code>register_repr(f\"{class})(normal_repr)</code></li> </ul> </li> <li>Renamed GradientRule -&gt; Rule</li> <li>to match the naming of the other modules in <code>rich-gradient</code></li> </ul>"},{"location":"CHANGELOG/#v032-added","title":"v0.3.2 Added","text":"<ul> <li>Tests</li> <li><code>tests/benchmark_perf.py</code>: To benchmark the performance of generating gradients that span large amounts of characters.</li> <li><code>tests/test_edge_cases.py</code>: To cover edge cases that may otherwise break <code>rich-gradient</code>.</li> </ul>"},{"location":"CHANGELOG/#v030-2025-06-20-working-rewrite","title":"v0.3.0 - 2025-06-20 |  Working Rewrite","text":""},{"location":"CHANGELOG/#v030-added","title":"v0.3.0 Added","text":"<ul> <li>Validated working and added tests for:</li> <li><code>rich_gradient.text.Text</code></li> <li><code>rich_gradient.gradient.Gradient</code></li> <li><code>rich_gradient.rule.GradientRule</code></li> <li><code>rich_gradient.spectrum.Spectrum</code></li> <li><code>rich-color-ext</code> acting as adequate replacement for previous color logic</li> <li>Added examples directory containing:</li> <li><code>animated_gradient_example.py</code></li> <li><code>gradient_example.py</code></li> <li><code>hello_world.py</code></li> <li><code>rainbow_gradient.py</code></li> <li><code>specific_color_gradient.py</code></li> <li><code>text_markup.py</code></li> <li><code>two_color_gradients.py</code></li> <li>Generated updated exports for examples for documentation (still in the works)</li> </ul>"},{"location":"CHANGELOG/#v030-updated","title":"v0.3.0 Updated","text":"<ul> <li><code>docs/index.md</code></li> </ul>"},{"location":"CHANGELOG/#v030-todo","title":"v0.3.0 TODO","text":"<ul> <li>Update Documentation</li> <li>Expand Tests</li> <li>Work on Gradient Panel and Table Renderables</li> </ul>"},{"location":"CHANGELOG/#v030-removed","title":"v0.3.0 Removed","text":"<p>Removed all of the the archived modules from rich_gradient/archive/*</p>"},{"location":"CHANGELOG/#v021-rewrite","title":"v0.2.1 Rewrite","text":"<p>There was a lot of overhead in rich-gradient so I rewrote it from the ground up with an actual goal. I created rich-color-ext to wrap around rich's color parsing removing the need for the<code>_rgb.py</code>, <code>color.py</code>, <code>color_data.py</code>, <code>_colors.py</code>, and all of their tests.</p>"},{"location":"CHANGELOG/#v020-2025-3-13-uv-pure-python-and-3132","title":"v0.2.0 - 2025-3-13 | uv, pure python, and 3.13.2","text":"<p>There are a number of significant changes in v0.2.0:</p>"},{"location":"CHANGELOG/#rye-uv","title":"<code>rye</code> \u2192 <code>uv</code>","text":"<p>Astral has done a hell of a job making python dev tools. ruff blew the existing python linters out of the water and uv pretty much did the same thing to package managers. Rich-gradient was started on rye but as Astral has since depreciated it, it's moved to their current rust powered python package manager, uv.</p>"},{"location":"CHANGELOG/#pure-python","title":"Pure Python","text":"<p>Rich-gradient is now a pure-python package. This allows it to be more easily used regardless of platform. As rich-gradient previously had pydantic as a dependency, it now just borrows the logic from <code>pydantic-extra-types.color</code>.</p>"},{"location":"CHANGELOG/#3132","title":"3.13.2","text":"<p>After switching to uv, the package has been updated to python 3.13.2.</p>"},{"location":"CHANGELOG/#v020-updated","title":"v0.2.0 Updated","text":"<ul> <li>Switched rich-gradient package manager from astral/rye to astral/uv</li> <li>Updated python to <code>3.13.2</code></li> </ul>"},{"location":"CHANGELOG/#v020-changed","title":"v0.2.0 Changed","text":"<ul> <li>Removed <code>pydantic</code> and <code>pydantic-extra-types</code> dependencies.</li> <li>Updated the names of some of the colors. For example greenyellow became lawngreen.</li> <li>Updated <code>README.md</code>, <code>CHANGELOG</code>, and documentation.</li> </ul>"},{"location":"CHANGELOG/#v020-added","title":"v0.2.0 Added","text":"<ul> <li><code>src/rich_gradient/_base_color.py</code>: stores the color logic from pydantic-extra-types.color modules stripped of the pydantic framwork.</li> </ul>"},{"location":"CHANGELOG/#v017-2024-7-16-added-support-for-two-color-gradients","title":"v0.1.7 - 2024-7-16 | Added support for Two-Color Gradients","text":""},{"location":"CHANGELOG/#v017-updated","title":"v0.1.7 Updated","text":"<ul> <li>Updated Gradient.generate_subgradients() to default to returning a list containing a single simple gradient to allow Gradients to work when only supplied with two colors.</li> </ul>"},{"location":"CHANGELOG/#v017-added","title":"v0.1.7 Added","text":"<ul> <li>Added len, int, str, and repr dunder methods to <code>rich-gradient.gradient.Gradient</code> (will simply refer to as <code>Gradient</code> from here on out).</li> <li>Added a tests/test_gradient.py for Gradient to test two color gradiets</li> </ul>"},{"location":"CHANGELOG/#v016-2024-6-28-updated-rev","title":"v0.1.6 - 2024-6-28 | Updated Rev","text":"<ul> <li>Updated rev to 0.1.6.</li> </ul>"},{"location":"CHANGELOG/#v015-2024-6-28-added-tests","title":"v0.1.5 - 2024-6-28 | Added Tests","text":""},{"location":"CHANGELOG/#v015-updated","title":"v0.1.5 Updated","text":"<ul> <li>Updated requirements for minimum versions of python from 3.8 -&gt; 3.10.</li> <li>Added <code>pytest</code> to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v015-added","title":"v0.1.5 Added","text":"<ul> <li>Tests for:</li> <li>Color</li> <li>Specturm</li> <li>SimpleGradient</li> </ul>"},{"location":"CHANGELOG/#v014-2024-6-28-resolved-dependancies","title":"v0.1.4 | 2024-6-28 | Resolved Dependancies","text":""},{"location":"CHANGELOG/#v014-updated","title":"v0.1.4 Updated","text":"<ul> <li>This release is primarily to prune unnecessary dependancies.</li> <li>Removed <code>numpy</code> to avoid issues of <code>numpy</code> version 2.0.0 conflicting with <code>torch</code>.</li> </ul>"},{"location":"CHANGELOG/#v013-2021-10-10","title":"v0.1.3 - 2021-10-10","text":""},{"location":"CHANGELOG/#v013-fixed","title":"v0.1.3 Fixed","text":"<ul> <li>Updated README to use GitHub pages for example gradient image.</li> </ul>"},{"location":"CHANGELOG/#v012-2021-10-10","title":"v0.1.2 - 2021-10-10","text":""},{"location":"CHANGELOG/#v012-updated","title":"v0.1.2 Updated","text":"<ul> <li>Updated PyProject.toml description.</li> <li>Moved MKDocs and related dependancies to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v012-fixed","title":"v0.1.2 Fixed","text":"<ul> <li>Updated README to use GitHub pages for banner image.</li> <li>Updated README to use GitHub pages for docs url.</li> </ul>"},{"location":"CHANGELOG/#v011-2021-10-10","title":"v0.1.1 - 2021-10-10","text":""},{"location":"CHANGELOG/#v011-fixed","title":"v0.1.1 Fixed","text":"<ul> <li>Updated README to use GitHub pages for images.</li> </ul>"},{"location":"CHANGELOG/#v010-2021-10-10","title":"v0.1.0 - 2021-10-10","text":"<p>Initial release. Based off of MaxGradient with a simplified color model based on pydantic-extra-types.color.Color. Re-released as rich-gradient to avoid confusion with MaxGradient.</p>"},{"location":"gradient/","title":"Gradient","text":"<p>The <code>Gradient</code> class accepts any rich.console.ConsoleRenderable and prints it to a rich.console.Console instance in gradient color.</p> <pre><code>panel = Panel(\n    \"If you are looking for a way to display more than \\\na single line of text with a gradient, \\\nyou can use the `Gradient` class to \\\ncreate a gradient that can be applied to \\\nmultiple lines of text or any rich renderable object.\",\n    title=\"Gradient Example\",\n    title_align=\"left\",\n    padding=(1, 2),\n    border_style=\"bold\",\n    width=60,\n)\nconsole.print(Gradient(panel, rainbow=True), justify=\"center\")\n</code></pre> <p></p> <p>Or if you would like an animated gradient:</p> <pre><code>console = Console(width=64, record=True)\nconsole.line(2)\npanel = Panel(\n    \"This example demonstrates an animated gradient that shifts colors over time. \\\nYou can use the `Gradient` class to create a gradient that can be applied to any \\\nrich renderable object, such as text or panels. The animation is achieved by \\\nincrementing the phase of the gradient.\",\n    title=\"Animated Gradient\",\n    padding=(1, 2),\n)\ngradient = Gradient(panel, rainbow=True, animated=True)\nlive_renderable = gradient\n# Setup Live to refresh at ~30 FPS\nwith Live(live_renderable, console=console, refresh_per_second=30):\n    with suppress(KeyboardInterrupt):\n        while True:\n            time.sleep(0.03)\n            # Increment phase to animate gradient shift\n            gradient.phase += 0.2\n</code></pre> <p></p>"},{"location":"gradient_ref/","title":"Gradient","text":"<p>               Bases: <code>JupyterMixin</code></p> <p>Gradient class that can act as a static or animated gradient. If animated=True, it animates the gradient using Live.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>class Gradient(JupyterMixin):\n    \"\"\"\n    Gradient class that can act as a static or animated gradient.\n    If animated=True, it animates the gradient using Live.\n    \"\"\"\n\n    def __init__(\n        self,\n        # --- Rendering-related ---\n        renderables: Optional[\n            Union[str, ConsoleRenderable, List[ConsoleRenderable]]\n        ] = None,\n        expand: bool = False,\n        justify: AlignMethod = \"left\",\n        vertical_justify: VerticalAlignMethod = \"top\",\n        show_quit_panel: bool = False,\n        repeat_scale: float = 2.0,\n        *,\n        console: Optional[Console] = None,\n        # --- Color-related ---\n        colors: Optional[List[ColorType]] = None,\n        bg_colors: Optional[List[ColorType]] = None,\n        hues: int = 3,\n        rainbow: bool = False,\n        background: bool = False,\n        # --- Animation-related ---\n        animated: bool = False,\n        auto_start: bool = True,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 20.0,\n        speed: int = 2,\n        # --- Console/Debug options ---\n        transient: bool = False,\n        redirect_stdout: bool = False,\n        redirect_stderr: bool = False,\n        disable: bool = False,\n    ) -&gt; None:\n        self.console: Console = console or get_console()\n        self.hues: int = max(hues, 2)\n        self.rainbow: bool = rainbow\n        self.repeat_scale: float = repeat_scale\n        self.phase: float = 0.0\n        self.expand: bool = expand\n        self.justify = justify\n        self.vertical_justify = vertical_justify\n        self.show_quit_panel = show_quit_panel\n        self.background = background\n\n        self.renderables = self._normalize_renderables(renderables, colors)\n        self.colors = colors or []\n        self.bg_colors = bg_colors or []\n        # Animation related\n        self.animated = animated\n        self.auto_refresh = auto_refresh\n        self.refresh_per_second = refresh_per_second\n        self.transient = transient\n        self.redirect_stdout = redirect_stdout\n        self.redirect_stderr = redirect_stderr\n        self.disable = disable\n        self._speed = speed / 1000.0\n        self._cycle = 0.0\n        self._running: bool = False\n        self._thread: Optional[Thread] = None\n        self._stop_event: Event = Event()\n        self._lock = RLock()\n        self.live: Optional[Live] = None\n        if self.animated:\n            # Live must exist before we set / forward console\n            self.live = Live(\n                console=self.console,\n                auto_refresh=self.auto_refresh,\n                refresh_per_second=self.refresh_per_second,\n                transient=self.transient,\n                redirect_stdout=self.redirect_stdout,\n                redirect_stderr=self.redirect_stderr,\n            )\n            self.console = self.live.console\n        if self.animated and auto_start:\n            self.start()\n        self._active_stops = self._initialize_color_stops()\n\n    def _normalize_renderables(\n        self, renderables: Optional[Union[str, ConsoleRenderable, List[ConsoleRenderable]]], colors: Optional[List[ColorType]]\n    ) -&gt; List[ConsoleRenderable]:\n        from rich_gradient.text import Text\n\n        if renderables is None:\n            return []\n        if isinstance(renderables, str):\n            return [Text(renderables, colors=colors)]\n        if isinstance(renderables, list):\n            return [(Text(r, colors=colors) if isinstance(r, str) else r) for r in renderables]\n        return [renderables]\n\n    def _initialize_color_stops(self) -&gt; List[ColorTriplet]:\n        source = self.bg_colors if self.background else self.colors\n        return [source[0], source[0]] if len(source) == 1 else source\n\n    @property\n    def renderables(self) -&gt; List[ConsoleRenderable]:\n        \"\"\"List of renderable objects to which the gradient is applied.\"\"\"\n        return self._renderables\n\n    @renderables.setter\n    def renderables(self, value: ConsoleRenderable | List[ConsoleRenderable]) -&gt; None:\n        render_list = value if isinstance(value, list) else [value]\n        normalized: List[ConsoleRenderable] = []\n        for item in render_list:\n            if isinstance(item, str):\n                normalized.append(RichText.from_markup(item))\n            else:\n                normalized.append(item)\n        self._renderables = normalized\n\n    @property\n    def colors(self) -&gt; List[ColorTriplet]:\n        \"\"\"List of parsed ColorTriplet objects for gradient foreground.\"\"\"\n        return self._foreground_colors\n\n    @colors.setter\n    def colors(self, colors: List[ColorType]) -&gt; None:\n        # User-provided colors take priority, even if rainbow is True\n        if colors:\n            triplets = self._to_color_triplets(colors)\n        elif self.rainbow:\n            triplets = Spectrum().triplets\n        else:\n            triplets = Spectrum(self.hues).triplets\n        if len(triplets) &gt; 2:\n            # Repeat the gradient by reversing all but the last color stop, to smoothly wrap to the first color\n            triplets += list(reversed(triplets[:-1]))\n        self._foreground_colors = triplets\n\n    @property\n    def bg_colors(self) -&gt; List[ColorTriplet]:\n        \"\"\"List of parsed ColorTriplet objects for gradient background.\"\"\"\n        return self._background_colors\n\n    @bg_colors.setter\n    def bg_colors(self, colors: Optional[List[ColorType]]) -&gt; None:\n        if not colors:\n            self._background_colors = []\n            return\n        if len(colors) == 1:\n            triplet = Color.parse(colors[0]).get_truecolor()\n            self._background_colors = [triplet] * self.hues\n        else:\n            triplets = self._to_color_triplets(colors)\n            self._background_colors = triplets\n\n    @property\n    def justify(self) -&gt; AlignMethod:\n        return self._justify  # type: ignore\n\n    @justify.setter\n    def justify(self, method: AlignMethod) -&gt; None:\n        if isinstance(method, str) and method.lower() in {\"left\", \"center\", \"right\"}:\n            self._justify = method.lower()  # type: ignore\n        else:\n            raise ValueError(f\"Invalid justify method: {method}\")\n\n    @property\n    def vertical_justify(self) -&gt; VerticalAlignMethod:\n        return self._vertical_justify  # type: ignore\n\n    @vertical_justify.setter\n    def vertical_justify(self, method: VerticalAlignMethod) -&gt; None:\n        if isinstance(method, str) and method.lower() in {\"top\", \"center\", \"bottom\"}:\n            self._vertical_justify = method.lower()  # type: ignore\n        else:\n            raise ValueError(f\"Invalid vertical justify method: {method}\")\n\n    @property\n    def show_quit_panel(self) -&gt; bool:\n        return self._show_quit_panel  # type: ignore\n\n    @show_quit_panel.setter\n    def show_quit_panel(self, value: bool) -&gt; None:\n        self._show_quit_panel = bool(value)\n\n    @staticmethod\n    def _to_color_triplets(colors: List[ColorType]) -&gt; List[ColorTriplet]:\n        triplets: List[ColorTriplet] = []\n        for c in colors:\n            if isinstance(c, ColorTriplet):\n                triplets.append(c)\n            elif isinstance(c, Color):\n                triplets.append(c.get_truecolor())\n            elif isinstance(c, str):\n                triplets.append(Color.parse(c).get_truecolor())\n            else:\n                raise ColorParseError(\n                    f\"Unsupported color type: {type(c)}\\n\\tCould not parse color: {c}\"\n                )\n        return triplets\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; Measurement:\n        measurements = [Measurement.get(console, options, r) for r in self.renderables]\n        min_width = min(m.minimum for m in measurements)\n        max_width = max(m.maximum for m in measurements)\n        return Measurement(min_width, max_width)\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n        width = options.max_width\n        content = Group(*self.renderables)\n        if self.show_quit_panel:\n            panel = Panel(\n                \"Press [bold]Ctrl+C[/bold] to stop.\", expand=False\n            )  # &lt;-- changed here\n            content = Group(content, Align(panel, align=\"right\"))\n        lines = console.render_lines(content, options, pad=True, new_lines=False)\n        for line_idx, segments in enumerate(lines):\n            col = 0\n            for seg in segments:\n                text = seg.text\n                base_style = seg.style or Style()\n                cluster = \"\"\n                cluster_width = 0\n                for ch in text:\n                    w = get_character_cell_size(ch)\n                    if w &lt;= 0:\n                        cluster += ch\n                        continue\n                    if cluster:\n                        style = self._get_style_at_position(\n                            col - cluster_width, cluster_width, width\n                        )\n                        yield Segment(cluster, self._merge_styles(base_style, style))\n                        cluster = \"\"\n                        cluster_width = 0\n                    cluster = ch\n                    cluster_width = w\n                    col += w\n                if cluster:\n                    style = self._get_style_at_position(\n                        col - cluster_width, cluster_width, width\n                    )\n                    yield Segment(cluster, self._merge_styles(base_style, style))\n            if line_idx &lt; len(lines) - 1:\n                yield Segment.line()\n\n    def _get_style_at_position(self, position: int, width: int, span: int) -&gt; Style:\n        frac = self._compute_fraction(position, width, span)\n        fg_style = \"\"\n        bg_style = \"\"\n        if self.colors:\n            r, g, b = self._interpolate_color(frac, self.colors)\n            fg_style = f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n        if self.bg_colors:\n            r, g, b = self._interpolate_color(frac, self.bg_colors)\n            bg_style = f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n        return Style(color=fg_style or None, bgcolor=bg_style or None)\n\n    def _compute_fraction(self, position: int, width: int, span: float) -&gt; float:\n        total_width = span * self.repeat_scale\n        base = (position + width / 2) / total_width\n        return (base + self.phase) % 1.0\n\n    def _interpolate_color(\n        self, frac: float, color_stops: list[ColorTriplet]\n    ) -&gt; tuple[float, float, float]:\n        if frac &lt;= 0:\n            return color_stops[0]\n        if frac &gt;= 1:\n            return color_stops[-1]\n        segment_count = len(color_stops) - 1\n        pos = frac * segment_count\n        idx = int(pos)\n        t = pos - idx\n        r0, g0, b0 = color_stops[idx]\n        r1, g1, b1 = color_stops[min(idx + 1, segment_count)]\n\n        def to_linear(c: float) -&gt; float:\n            return (c / 255.0) ** _GAMMA_CORRECTION\n\n        def to_srgb(x: float) -&gt; float:\n            return (x ** (1.0 / _GAMMA_CORRECTION)) * 255.0\n\n        lr0, lg0, lb0 = to_linear(r0), to_linear(g0), to_linear(b0)\n        lr1, lg1, lb1 = to_linear(r1), to_linear(g1), to_linear(b1)\n        lr = lr0 + (lr1 - lr0) * t\n        lg = lg0 + (lg1 - lg0) * t\n        lb = lb0 + (lb1 - lb0) * t\n        return to_srgb(lr), to_srgb(lg), to_srgb(lb)\n\n    @staticmethod\n    def _merge_styles(original: Style, gradient_style: Style) -&gt; Style:\n        return original + gradient_style if original else gradient_style\n\n    # ------------- Animation methods --------------\n    @property\n    def live_console(self) -&gt; Optional[Console]:\n        return self.live.console if self.live is not None else None\n\n    @live_console.setter\n    def live_console(self, value: Console) -&gt; None:\n        if self.live is not None:\n            self.live.console = value\n\n    def start(self) -&gt; None:\n        \"\"\"Start the Live context and the animation loop in a background thread.\"\"\"\n        if not self.animated:\n            return\n        if self._running:\n            return\n        self._running = True\n        self._stop_event.clear()\n        if self.live is not None:\n            self.live.start()\n        self._thread = Thread(target=self._animate, daemon=True)\n        self._thread.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"Signal the animation to stop, wait for the thread, and close Live.\"\"\"\n        if not self.animated:\n            return\n        if not self._running:\n            return\n        self._running = False\n        self._stop_event.set()\n        if self._thread is not None:\n            self._thread.join(timeout=1.0)\n            self._thread = None\n        if self.live is not None:\n            self.live.stop()\n\n    def run(self) -&gt; None:\n        \"\"\"Blocking helper: start, then wait for Ctrl+C, then stop.\"\"\"\n        if not self.animated:\n            raise RuntimeError(\"run() is only available if animated=True\")\n        try:\n            self.start()\n            while self._running:\n                time.sleep(0.1)\n        except KeyboardInterrupt:\n            pass\n        finally:\n            self.stop()\n\n    def __enter__(self):\n        if self.animated:\n            self.start()\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        if self.animated:\n            self.stop()\n        return False\n\n    def get_renderable(self) -&gt; ConsoleRenderable:\n        \"\"\"Return the renderable the Live instance should display each frame.\"\"\"\n        with self._lock:\n            if not self.renderables:\n                raise AssertionError(\"No renderables set for the gradient\")\n            return Align(\n                self,\n                align=self.justify,\n                vertical=cast(VerticalAlignMethod, self.vertical_justify),\n                width=self.console.width if self.expand else None,\n                height=self.console.height if self.expand else None,\n                pad=self.expand,\n            )\n\n    def _animate(self) -&gt; None:\n        try:\n            frame_time = 1.0 / self.refresh_per_second\n            while not self._stop_event.is_set():\n                self._cycle += self._speed\n                self.phase = self._cycle\n                if self.live is not None:\n                    self.live.update(\n                        self.get_renderable(), refresh=not self.auto_refresh\n                    )\n                    if not self.auto_refresh:\n                        self.live.refresh()\n                self._stop_event.wait(frame_time)\n        except KeyboardInterrupt:\n            pass\n        finally:\n            self._running = False\n\n    # Add this method for test compatibility\n    def _color_at(self, pos: int, width: int, span: int) -&gt; str:\n        \"\"\"Return the hex color at a given position.\"\"\"\n        stops = self._active_stops\n        frac = self._compute_fraction(pos, width, span)\n        r, g, b = self._interpolate_color(frac, stops)\n        return f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n\n    # Add this method for test compatibility\n    def _styled(self, original: Style, color: str) -&gt; Style:\n        \"\"\"Return a Style with the given color or bgcolor, preserving original.\"\"\"\n        if self.background:\n            return original + Style(bgcolor=color)\n        else:\n            return original + Style(color=color)\n\n    # Add this method for test compatibility\n    def _interpolated_color(self, frac: float, stops: list, n: int):\n        \"\"\"Return the interpolated color at a fraction (for test).\"\"\"\n        return self._interpolate_color(frac, stops)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.bg_colors","title":"<code>bg_colors</code>  <code>property</code> <code>writable</code>","text":"<p>List of parsed ColorTriplet objects for gradient background.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>List of parsed ColorTriplet objects for gradient foreground.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.renderables","title":"<code>renderables</code>  <code>property</code> <code>writable</code>","text":"<p>List of renderable objects to which the gradient is applied.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._color_at","title":"<code>_color_at(pos, width, span)</code>","text":"<p>Return the hex color at a given position.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _color_at(self, pos: int, width: int, span: int) -&gt; str:\n    \"\"\"Return the hex color at a given position.\"\"\"\n    stops = self._active_stops\n    frac = self._compute_fraction(pos, width, span)\n    r, g, b = self._interpolate_color(frac, stops)\n    return f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._interpolated_color","title":"<code>_interpolated_color(frac, stops, n)</code>","text":"<p>Return the interpolated color at a fraction (for test).</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _interpolated_color(self, frac: float, stops: list, n: int):\n    \"\"\"Return the interpolated color at a fraction (for test).\"\"\"\n    return self._interpolate_color(frac, stops)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._styled","title":"<code>_styled(original, color)</code>","text":"<p>Return a Style with the given color or bgcolor, preserving original.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _styled(self, original: Style, color: str) -&gt; Style:\n    \"\"\"Return a Style with the given color or bgcolor, preserving original.\"\"\"\n    if self.background:\n        return original + Style(bgcolor=color)\n    else:\n        return original + Style(color=color)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.get_renderable","title":"<code>get_renderable()</code>","text":"<p>Return the renderable the Live instance should display each frame.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def get_renderable(self) -&gt; ConsoleRenderable:\n    \"\"\"Return the renderable the Live instance should display each frame.\"\"\"\n    with self._lock:\n        if not self.renderables:\n            raise AssertionError(\"No renderables set for the gradient\")\n        return Align(\n            self,\n            align=self.justify,\n            vertical=cast(VerticalAlignMethod, self.vertical_justify),\n            width=self.console.width if self.expand else None,\n            height=self.console.height if self.expand else None,\n            pad=self.expand,\n        )\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.run","title":"<code>run()</code>","text":"<p>Blocking helper: start, then wait for Ctrl+C, then stop.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Blocking helper: start, then wait for Ctrl+C, then stop.\"\"\"\n    if not self.animated:\n        raise RuntimeError(\"run() is only available if animated=True\")\n    try:\n        self.start()\n        while self._running:\n            time.sleep(0.1)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        self.stop()\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.start","title":"<code>start()</code>","text":"<p>Start the Live context and the animation loop in a background thread.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the Live context and the animation loop in a background thread.\"\"\"\n    if not self.animated:\n        return\n    if self._running:\n        return\n    self._running = True\n    self._stop_event.clear()\n    if self.live is not None:\n        self.live.start()\n    self._thread = Thread(target=self._animate, daemon=True)\n    self._thread.start()\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.stop","title":"<code>stop()</code>","text":"<p>Signal the animation to stop, wait for the thread, and close Live.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Signal the animation to stop, wait for the thread, and close Live.\"\"\"\n    if not self.animated:\n        return\n    if not self._running:\n        return\n    self._running = False\n    self._stop_event.set()\n    if self._thread is not None:\n        self._thread.join(timeout=1.0)\n        self._thread = None\n    if self.live is not None:\n        self.live.stop()\n</code></pre>"},{"location":"rule/","title":"Rule","text":""},{"location":"rule/#rule","title":"Rule","text":"<p>The 'Rule` class is based off of the rich.rule.Rule class and is used to define a rule in gradient color and variable thickness.</p>"},{"location":"rule/#usage","title":"Usage","text":"<pre><code>from rich.console import Console\nfrom rich_gradient.rule import Rule\n\nconsole = Console()\nconsole.print(\n    Rule(\n        \"Hello, world!\",\n    )\n)\n</code></pre>"},{"location":"rule/#alignment","title":"Alignment","text":"<p>The <code>Rule</code> class supports the same alignment options as the <code>Rule</code> class.</p>"},{"location":"rule/#left-aligned-rule","title":"Left Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"\u2190 This is a left aligned rule.\",\n        align=\"left\",\n    )\n)\n</code></pre>"},{"location":"rule/#right-aligned-rule","title":"Right Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a right aligned rule. \u2192,\n        align=\"right\"\n    )\n)\n</code></pre>"},{"location":"rule/#center-aligned-rule","title":"Center Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"\u2192 This is a center aligned rule. \u2190\",\n        align=\"center\"\n    )\n)\n</code></pre> <p>Note</p> <p>The default behavior of rich_gradient.rule.Rule is center aligned.</p>"},{"location":"rule/#thickness","title":"Thickness","text":"<p>The <code>Rule</code> class add the ability to determine the thickness of the rule. Valid values are:</p> <ol> <li><code>thin</code> (<code>\u2500</code>)</li> <li><code>double</code> (<code>\u2550</code>)</li> <li><code>medium</code> (<code>\u2501</code>) (default)</li> <li><code>thick</code> (<code>\u2588</code>)</li> </ol>"},{"location":"rule/#thin-rule","title":"Thin Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a thin rule\",\n        thickness=1\n    )\n)\n</code></pre>"},{"location":"rule/#double-line-rule","title":"Double-line Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a double-line rule\",\n        thickness=2\n    )\n)\n</code></pre>"},{"location":"rule/#medium-rule","title":"Medium Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a medium rule\",\n        thickness=3\n    )\n)\n</code></pre>"},{"location":"rule/#thick-rule","title":"Thick Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a thick rule\",\n        thickness=4\n    )\n)\n</code></pre>"},{"location":"rule/#custom-colored-rule","title":"Custom Colored Rule","text":"<p>To create a rule with custom colors, simply supply the <code>colors</code> parameter with a list of colors (as CSS color names, 3 or 6 digit hex codes, rich color names, or rgb color codes).</p> console.print( Rule( \"This rule has custom colors!\", colors=[ \"#f00\", # red \"#f90\", # orange \"#ff0\", # yellow \"#9f0\", # yellow-green ]    \u00a0\u00a0) )  <p></p> <p></p>"},{"location":"rule/#custom-title-style","title":"Custom Title Style","text":"<p>If you would like some distinction between the rule and it's title, simply pass a rich style to the <code>title_style</code> parameter:</p> <pre><code>console.print(\n     Rule(\n         \"Custom Styled Rule Title\",\n         title_style=\"bold white\",\n         align=\"center\"\n     )\n)\n</code></pre> <p></p>"},{"location":"rule_ref/","title":"Rule Reference","text":"<p>               Bases: <code>Rule</code></p> <p>A Rule with a gradient background.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Optional[str]</code> <p>The text to display as the title.</p> required <code>title_style</code> <code>StyleType</code> <p>The style to apply to the title text. Defaults to NULL_STYLE.</p> <code>parse('bold')</code> <code>colors</code> <code>List[ColorType]</code> <p>A list of color strings for the gradient. Defaults to empty list.</p> <code>None</code> <code>thickness</code> <code>int</code> <p>Thickness level of the rule (0 to 3). Defaults to 2.</p> <code>2</code> <code>style</code> <code>StyleType</code> <p>The style of the rule line. Defaults to NULL_STYLE.</p> <code>NULL_STYLE</code> <code>rainbow</code> <code>bool</code> <p>If True, use a rainbow gradient regardless of colors. Defaults to False.</p> <code>False</code> <code>hues</code> <code>int</code> <p>Number of hues in the gradient if colors are not provided. Defaults to 10.</p> <code>10</code> <code>end</code> <code>str</code> <p>End character after the rule. Defaults to newline.</p> <code>'\\n'</code> <code>align</code> <code>AlignMethod</code> <p>Alignment of the rule. Defaults to \"center\".</p> <code>'center'</code> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>class Rule(RichRule):\n    \"\"\"A Rule with a gradient background.\n\n    Args:\n        title (Optional[str]): The text to display as the title.\n        title_style (StyleType, optional): The style to apply to the title text. Defaults to NULL_STYLE.\n        colors (List[ColorType], optional): A list of color strings for the gradient. Defaults to empty list.\n        thickness (int, optional): Thickness level of the rule (0 to 3). Defaults to 2.\n        style (StyleType, optional): The style of the rule line. Defaults to NULL_STYLE.\n        rainbow (bool, optional): If True, use a rainbow gradient regardless of colors. Defaults to False.\n        hues (int, optional): Number of hues in the gradient if colors are not provided. Defaults to 10.\n        end (str, optional): End character after the rule. Defaults to newline.\n        align (AlignMethod, optional): Alignment of the rule. Defaults to \"center\".\n    \"\"\"\n\n    def __init__(\n        self,\n        title: Optional[str],\n        title_style: StyleType = Style.parse(\"bold\"),\n        colors: Optional[List[ColorType]] = None,\n        thickness: int = 2,\n        style: StyleType = NULL_STYLE,\n        rainbow: bool = False,\n        hues: int = 10,\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n    ) -&gt; None:\n        # Validate thickness input\n        if thickness &lt; 0 or thickness &gt; 3:\n            raise ValueError(\n                f\"Invalid thickness: {thickness}. Thickness must be between 0 and 3.\"\n            )\n        # Validate type\n        if title is not None and not isinstance(title, str):\n            raise TypeError(f\"title must be str, got {type(title).__name__}\")\n\n        if not isinstance(title_style, (str, Style)):\n            raise TypeError(\n                f\"title_style must be str or Style, got {type(title_style).__name__}\"\n            )\n        if not isinstance(style, (str, Style)):\n            raise TypeError(f\"style must be str or Style, got {type(style).__name__}\")\n        # Determine character based on thickness\n        self.characters = CHARACTER_MAP.get(thickness, \"\u2501\")\n        # Parse and store the title style\n        self.title_style = Style.parse(str(title_style))\n        # Initialize the base Rule with provided parameters\n        super().__init__(\n            title=title or \"\",\n            characters=self.characters,\n            style=Style.parse(str(style)),\n            end=end,\n            align=align,\n        )\n        # Parse and store the gradient colors\n        self.colors = self._parse_colors(\n            colors if colors is not None else [], rainbow, hues\n        )\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n        \"\"\"Render the gradient rule.\n\n        Args:\n            console (Console): The console to render to.\n            options (ConsoleOptions): The console options.\n\n        Yields:\n            RenderResult: The rendered segments of the gradient rule.\n        \"\"\"\n        # Prepare a base rule with no style to extract segments\n        base_rule = RichRule(\n            title=self.title or \"\",\n            characters=self.characters,\n            style=NULL_STYLE,\n            end=self.end,\n            align=cast(AlignMethod, self.align),\n        )\n        # Render the base rule to get segments\n        rule_segments = console.render(base_rule, options=options)\n        # Concatenate segment texts to form the full rule text\n        rule_text = \"\".join(seg.text for seg in rule_segments)\n\n        # If no title style, render the gradient text directly\n        if self.title_style == NULL_STYLE:\n            gradient_rule = Text(rule_text, colors=self.colors)\n            yield from console.render(gradient_rule, options)\n            return\n        # Create gradient text for the rule\n        gradient_rule = Text(rule_text, colors=self.colors)\n\n        # Extract the title string for highlighting\n        title = self.title.plain if isinstance(self.title, Text) else str(self.title)\n\n        # Apply the title style highlight after gradient generation\n        if title and self.title_style != NULL_STYLE:\n            gradient_rule.highlight_words([title], style=self.title_style)\n\n        # Yield the styled gradient text\n        yield from console.render(gradient_rule, options)\n\n    def _parse_colors(\n        self,\n        colors: Sequence[ColorType],\n        rainbow: bool,\n        hues: int,\n    ) -&gt; List[str]:\n        \"\"\"Parse colors for the gradient.\n\n        Args:\n            colors (List[ColorType]): A list of color strings.\n            rainbow (bool): If True, use a rainbow gradient.\n            hues (int): Number of hues in the gradient.\n        Raises:\n            ValueError: If any color is not a valid string.\n            ColorParseError: If a color string cannot be parsed.\n\n        Returns:\n            List[str]: A list of hex color strings for the gradient.\n        \"\"\"\n        # Use full rainbow spectrum if rainbow flag is set, or if insufficient colors\n        if rainbow:\n            return Spectrum(hues).hex\n        _colors: List[str] = []\n        if colors and len(colors) &lt; 2:\n            raise ValueError(\n                \"At least two colors are required for a gradient. \",\n                \"Please provide a list of at least two color strings.\",\n                f\"Received: {colors=}\",\n            )\n        if not colors:\n            # If no colors provided, generate a random gradient\n            return Spectrum(hues).hex\n        for color in colors:\n            # Validate color is a string\n            if not isinstance(color, str):\n                raise ValueError(\n                    f\"Invalid color: {color}. Please provide a valid color string.\"\n                )\n            try:\n                # Convert color string to hex format\n                _colors.append(Color.parse(color).get_truecolor().hex)\n            except ColorParseError as ce:\n                raise ColorParseError(\n                    f\"Invalid color: {color}. Please provide a valid color string.\"\n                ) from ce\n        return _colors\n</code></pre>"},{"location":"rule_ref/#rich_gradient.rule.Rule.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render the gradient rule.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>The console to render to.</p> required <code>options</code> <code>ConsoleOptions</code> <p>The console options.</p> required <p>Yields:</p> Name Type Description <code>RenderResult</code> <code>RenderResult</code> <p>The rendered segments of the gradient rule.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def __rich_console__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; RenderResult:\n    \"\"\"Render the gradient rule.\n\n    Args:\n        console (Console): The console to render to.\n        options (ConsoleOptions): The console options.\n\n    Yields:\n        RenderResult: The rendered segments of the gradient rule.\n    \"\"\"\n    # Prepare a base rule with no style to extract segments\n    base_rule = RichRule(\n        title=self.title or \"\",\n        characters=self.characters,\n        style=NULL_STYLE,\n        end=self.end,\n        align=cast(AlignMethod, self.align),\n    )\n    # Render the base rule to get segments\n    rule_segments = console.render(base_rule, options=options)\n    # Concatenate segment texts to form the full rule text\n    rule_text = \"\".join(seg.text for seg in rule_segments)\n\n    # If no title style, render the gradient text directly\n    if self.title_style == NULL_STYLE:\n        gradient_rule = Text(rule_text, colors=self.colors)\n        yield from console.render(gradient_rule, options)\n        return\n    # Create gradient text for the rule\n    gradient_rule = Text(rule_text, colors=self.colors)\n\n    # Extract the title string for highlighting\n    title = self.title.plain if isinstance(self.title, Text) else str(self.title)\n\n    # Apply the title style highlight after gradient generation\n    if title and self.title_style != NULL_STYLE:\n        gradient_rule.highlight_words([title], style=self.title_style)\n\n    # Yield the styled gradient text\n    yield from console.render(gradient_rule, options)\n</code></pre>"},{"location":"rule_ref/#rich_gradient.rule.Rule._parse_colors","title":"<code>_parse_colors(colors, rainbow, hues)</code>","text":"<p>Parse colors for the gradient.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>List[ColorType]</code> <p>A list of color strings.</p> required <code>rainbow</code> <code>bool</code> <p>If True, use a rainbow gradient.</p> required <code>hues</code> <code>int</code> <p>Number of hues in the gradient.</p> required <p>Raises:     ValueError: If any color is not a valid string.     ColorParseError: If a color string cannot be parsed.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of hex color strings for the gradient.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def _parse_colors(\n    self,\n    colors: Sequence[ColorType],\n    rainbow: bool,\n    hues: int,\n) -&gt; List[str]:\n    \"\"\"Parse colors for the gradient.\n\n    Args:\n        colors (List[ColorType]): A list of color strings.\n        rainbow (bool): If True, use a rainbow gradient.\n        hues (int): Number of hues in the gradient.\n    Raises:\n        ValueError: If any color is not a valid string.\n        ColorParseError: If a color string cannot be parsed.\n\n    Returns:\n        List[str]: A list of hex color strings for the gradient.\n    \"\"\"\n    # Use full rainbow spectrum if rainbow flag is set, or if insufficient colors\n    if rainbow:\n        return Spectrum(hues).hex\n    _colors: List[str] = []\n    if colors and len(colors) &lt; 2:\n        raise ValueError(\n            \"At least two colors are required for a gradient. \",\n            \"Please provide a list of at least two color strings.\",\n            f\"Received: {colors=}\",\n        )\n    if not colors:\n        # If no colors provided, generate a random gradient\n        return Spectrum(hues).hex\n    for color in colors:\n        # Validate color is a string\n        if not isinstance(color, str):\n            raise ValueError(\n                f\"Invalid color: {color}. Please provide a valid color string.\"\n            )\n        try:\n            # Convert color string to hex format\n            _colors.append(Color.parse(color).get_truecolor().hex)\n        except ColorParseError as ce:\n            raise ColorParseError(\n                f\"Invalid color: {color}. Please provide a valid color string.\"\n            ) from ce\n    return _colors\n</code></pre>"},{"location":"text/","title":"rich_gradient.text.Text","text":"<p>If you pass <code>rich_gradient.text.Text</code> a string, it will print the string to the console in a random gradient. Rich-gradient's <code>Text</code> class inherits from <code>rich.text.Text</code>. In addition to all of it's parent's parameters, <code>rich_gradient.text.Text</code> also accepts:</p> <ul> <li><code>colors</code>: (<code>List[ColorType]</code>) - A list of strings that can be parsed by <code>rich.color.Color</code>.</li> </ul> \ud83d\udcdd Note<code>rich_color_ext</code> extends rich to be able to parse:   <ul> <li>CSS color names: <ul> <li>\u25c9 rebeccapurple</li> <li>\u25c9 salmon</li> <li>\u25c9 aliceblue</li> </ul> </li><li>3-Digit Hex Color Codes: <ul> <li>\u25c9 #abc</li> <li>\u25c9 #FDC</li> <li>\u25c9 #A1f          <ul> <li><code>hues</code>: (<code>int</code>) - The number of color stops a gradient should use</li> <li><code>rainbow</code>: (<code>bool</code>) - Whether to create a gradient that spans the entire spectrum. Defaults to <code>False</code></li> <li><code>markup</code>: (<code>bool</code>) - Whether to respect the inputs existing styles. Defaults  to <code>True</code></li> </ul>"},{"location":"text/#gradient-text-with-specific-colors","title":"Gradient Text with Specific Colors","text":"<p>To have more control over the gradient that is printed, you can pass the <code>colors</code> parameter a list of colors. Colors can be parsed from: -  CSS colors names, -  3 or 6 digit hex codes, -  <code>rich.color.Color</code> instances or names, -  any string or style that <code>rich.color.Color</code> can parse.</p> <p></p>"},{"location":"text/#rainbow-gradient-text-example","title":"Rainbow Gradient Text Example","text":"<p>If four colors isn't enough, you can use the 'rainbow' parameter to generate a rainbow gradient that spans the entire spectrum of colors randomly.</p> <p></p> <p>*The rainbow gradient is generated randomly each time the code is run.</p>"},{"location":"text/#still-inherits-from-richtexttext","title":"Still inherits from <code>rich.text.Text</code>","text":"<p>Since <code>rich_gradient.text.Text</code> is a subclass of <code>rich.text.Text</code>, you can still use all the same methods and parameters as you would.</p> <p></p>"},{"location":"text_ref/","title":"Text","text":"<p>               Bases: <code>Text</code></p> <p>A rich text class that supports gradient colors and styles.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>class Text(RichText):\n    \"\"\"A rich text class that supports gradient colors and styles.\"\"\"\n\n    def __init__(\n        self,\n        text: TextType = \"\",\n        colors: Optional[Sequence[ColorType]] = None,\n        *,\n        rainbow: bool = False,\n        hues: int = 5,\n        style: StyleType = \"\",\n        justify: JustifyMethod = \"default\",\n        overflow: OverflowMethod = \"fold\",\n        no_wrap: bool = False,\n        end: str = \"\\n\",\n        tab_size: int = 4,\n        bgcolors: Optional[Sequence[ColorType]] = None,\n        markup: bool = True,\n        spans: Optional[Sequence[Span]] = None,\n    ):\n        \"\"\"Initialize the Text with gradient colors and styles.\n        Args:\n            text (TextType): The text content.\n            colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n            rainbow (bool): If True, generate a rainbow spectrum.\n            hues (int): The number of hues to generate if colors are not provided.\n            style (StyleType): The style of the text.\n            justify (JustifyMethod): Justification method for the text.\n            overflow (OverflowMethod): Overflow method for the text.\n            no_wrap (bool): If True, disable wrapping of the text.\n            end (str): The string to append at the end of the text. Default is a newline.\n            tab_size (int): The number of spaces for a tab character.\n            bgcolors (Optional[List[ColorType]]): A list of background colors as Color instances\n            markup (bool): If True, parse Rich markup tags in the input text.\n            spans (Optional[Sequence[Span]]): A list of spans to apply to the text.\n        \"\"\"\n        if markup:\n            parsed_text = RichText.from_markup(\n                text=str(text), style=style, justify=justify, overflow=overflow\n            )\n        else:\n            parsed_text = RichText(\n                strip_control_codes(str(text)),\n                style=style,\n                justify=justify,\n                overflow=overflow,\n            )\n        plain = parsed_text.plain\n        parsed_justify = parsed_text.justify\n        parsed_overflow = parsed_text.overflow\n        parsed_spans = parsed_text._spans\n\n        super().__init__(\n            plain,\n            style=style,\n            justify=parsed_justify,\n            overflow=parsed_overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            spans=parsed_spans,\n        )\n        self.colors = self.parse_colors(colors, hues, rainbow)\n        self.bgcolors = self.parse_bgcolors(bgcolors, hues)\n\n        # Handle the single-color and single-background case: apply style directly and return early\n        if len(self.colors) == 1 and len(self.bgcolors) == 1:\n            # Apply the single color style directly\n            style_with_color = Style(\n                color=self.colors[0], bgcolor=self.bgcolors[0]\n            ) + Style.parse(style)\n            for index in range(len(self.plain)):\n                self.stylize(style_with_color, index, index + 1)\n            return\n\n        # Apply the gradient coloring\n        self.apply_gradient()\n\n    @property\n    def colors(self) -&gt; list[Color]:\n        \"\"\"Return the list of colors in the gradient.\"\"\"\n        return list(self._colors) if self._colors else []\n\n    @colors.setter\n    def colors(self, value: Optional[Sequence[Color]]) -&gt; None:\n        \"\"\"Set the list of colors in the gradient.\"\"\"\n        self._colors = list(value) if value else []\n\n    @property\n    def bgcolors(self) -&gt; list[Color]:\n        \"\"\"Return the list of background colors in the gradient.\"\"\"\n        return list(self._bgcolors) if self._bgcolors else []\n\n    @bgcolors.setter\n    def bgcolors(self, value: Optional[Sequence[Color]]) -&gt; None:\n        \"\"\"Set the list of background colors in the gradient.\"\"\"\n        self._bgcolors = list(value) if value else []\n\n    @staticmethod\n    def parse_colors(\n        colors: Optional[Sequence[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of colors for the gradient.\n        Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n        Args:\n            colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color instances or strings.\n            hues (int): The number of hues to generate if colors are not provided.\n            rainbow (bool): If True, generate a rainbow spectrum.\n        Returns:\n            List[Color]: A list of Color objects.\n        \"\"\"\n        if rainbow:\n            return Spectrum(hues=18).colors\n        if colors is None or len(colors) == 0:\n            return Spectrum(hues).colors\n        # Support 3-digit hex colors and all string representations via Color.parse\n        return [c if isinstance(c, Color) else Color.parse(c) for c in colors]\n\n    def parse_bgcolors(\n        self, bgcolors: Optional[Sequence[ColorType]] = None, hues: int = 5\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of background colors for the gradient.\n        Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n        Args:\n            bgcolors (Optional[Sequence[ColorType | Color]]): A list of background colors as Color instances or strings.\n            hues (int): The number of hues to generate if bgcolors are not provided.\n        Returns:\n            List[Color]: A list of Color objects for background colors.\n        \"\"\"\n        if bgcolors is None or len(bgcolors) == 0:\n            self._interpolate_bgcolors = False\n            return [Color.parse(\"default\")] * len(self.colors)\n\n        if len(bgcolors) == 1:\n            # If only one background color is provided, repeat it for each character\n            self._interpolate_bgcolors = False\n            return [Color.parse(bgcolors[0])] * len(self.colors)\n        # Support 3-digit hex colors and all string representations via Color.parse\n        self._interpolate_bgcolors = True\n        return [c if isinstance(c, Color) else Color.parse(c) for c in bgcolors]\n\n    def interpolate_colors(\n        self, colors: Optional[Sequence[Color]] = None\n    ) -&gt; list[Color]:\n        \"\"\"Interpolate colors in the gradient.\"\"\"\n        colors = list(colors) if colors is not None else self.colors\n        if not colors:\n            raise ValueError(\"No colors to interpolate\")\n        # Prepare the text and handle edge cases\n\n        text = self.plain\n        length = len(text)\n        if length == 0:\n            return []\n        num_colors = len(colors)\n        if num_colors == 1:\n            return [colors[0]] * length\n\n        # Compute number of segments between colors\n        segments = num_colors - 1\n        result: List[Color] = []\n\n        # For each character, determine its position and blend accordingly\n        for i in range(length):\n            # Normalized position along the entire text\n            pos = i / (length - 1) if length &gt; 1 else 0.0\n            # Determine which two colors to blend between\n            float_index = pos * segments\n            index = int(float_index)\n            # Clamp to valid segment range\n            if index &gt;= segments:\n                index = segments - 1\n                t = 1.0\n            else:\n                t = float_index - index\n\n            start = colors[index]\n            end = colors[index + 1]\n            triplet1 = start.get_truecolor()\n            triplet2 = end.get_truecolor()\n\n            # Interpolate each RGB component\n            r = int(triplet1.red + (triplet2.red - triplet1.red) * t)\n            g = int(triplet1.green + (triplet2.green - triplet1.green) * t)\n            b = int(triplet1.blue + (triplet2.blue - triplet1.blue) * t)\n\n            result.append(Color.from_rgb(r, g, b))\n\n        return result\n\n    def apply_gradient(self) -&gt; None:\n        \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n        # Generate a color for each character\n        colors = self.interpolate_colors(self.colors)\n        if self._interpolate_bgcolors:\n            # Generate a background color for each character if bgcolors are interpolated\n            bgcolors = self.interpolate_colors(self.bgcolors)\n        else:\n            # If not interpolating background colors, use the first bgcolor for all characters\n            bgcolors = [self.bgcolors[0]] * len(colors)\n        # Apply a style span for each character with its corresponding color\n        for index, (color, bgcolor) in enumerate(zip(colors, bgcolors)):\n            # Build a style with the interpolated color\n            span_style = Style(color=color, bgcolor=bgcolor)\n            # Stylize the single character range\n            self.stylize(span_style, index, index + 1)\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.bgcolors","title":"<code>bgcolors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of background colors in the gradient.</p>"},{"location":"text_ref/#rich_gradient.text.Text.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of colors in the gradient.</p>"},{"location":"text_ref/#rich_gradient.text.Text.__init__","title":"<code>__init__(text='', colors=None, *, rainbow=False, hues=5, style='', justify='default', overflow='fold', no_wrap=False, end='\\n', tab_size=4, bgcolors=None, markup=True, spans=None)</code>","text":"<p>Initialize the Text with gradient colors and styles. Args:     text (TextType): The text content.     colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.     rainbow (bool): If True, generate a rainbow spectrum.     hues (int): The number of hues to generate if colors are not provided.     style (StyleType): The style of the text.     justify (JustifyMethod): Justification method for the text.     overflow (OverflowMethod): Overflow method for the text.     no_wrap (bool): If True, disable wrapping of the text.     end (str): The string to append at the end of the text. Default is a newline.     tab_size (int): The number of spaces for a tab character.     bgcolors (Optional[List[ColorType]]): A list of background colors as Color instances     markup (bool): If True, parse Rich markup tags in the input text.     spans (Optional[Sequence[Span]]): A list of spans to apply to the text.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def __init__(\n    self,\n    text: TextType = \"\",\n    colors: Optional[Sequence[ColorType]] = None,\n    *,\n    rainbow: bool = False,\n    hues: int = 5,\n    style: StyleType = \"\",\n    justify: JustifyMethod = \"default\",\n    overflow: OverflowMethod = \"fold\",\n    no_wrap: bool = False,\n    end: str = \"\\n\",\n    tab_size: int = 4,\n    bgcolors: Optional[Sequence[ColorType]] = None,\n    markup: bool = True,\n    spans: Optional[Sequence[Span]] = None,\n):\n    \"\"\"Initialize the Text with gradient colors and styles.\n    Args:\n        text (TextType): The text content.\n        colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n        rainbow (bool): If True, generate a rainbow spectrum.\n        hues (int): The number of hues to generate if colors are not provided.\n        style (StyleType): The style of the text.\n        justify (JustifyMethod): Justification method for the text.\n        overflow (OverflowMethod): Overflow method for the text.\n        no_wrap (bool): If True, disable wrapping of the text.\n        end (str): The string to append at the end of the text. Default is a newline.\n        tab_size (int): The number of spaces for a tab character.\n        bgcolors (Optional[List[ColorType]]): A list of background colors as Color instances\n        markup (bool): If True, parse Rich markup tags in the input text.\n        spans (Optional[Sequence[Span]]): A list of spans to apply to the text.\n    \"\"\"\n    if markup:\n        parsed_text = RichText.from_markup(\n            text=str(text), style=style, justify=justify, overflow=overflow\n        )\n    else:\n        parsed_text = RichText(\n            strip_control_codes(str(text)),\n            style=style,\n            justify=justify,\n            overflow=overflow,\n        )\n    plain = parsed_text.plain\n    parsed_justify = parsed_text.justify\n    parsed_overflow = parsed_text.overflow\n    parsed_spans = parsed_text._spans\n\n    super().__init__(\n        plain,\n        style=style,\n        justify=parsed_justify,\n        overflow=parsed_overflow,\n        no_wrap=no_wrap,\n        end=end,\n        tab_size=tab_size,\n        spans=parsed_spans,\n    )\n    self.colors = self.parse_colors(colors, hues, rainbow)\n    self.bgcolors = self.parse_bgcolors(bgcolors, hues)\n\n    # Handle the single-color and single-background case: apply style directly and return early\n    if len(self.colors) == 1 and len(self.bgcolors) == 1:\n        # Apply the single color style directly\n        style_with_color = Style(\n            color=self.colors[0], bgcolor=self.bgcolors[0]\n        ) + Style.parse(style)\n        for index in range(len(self.plain)):\n            self.stylize(style_with_color, index, index + 1)\n        return\n\n    # Apply the gradient coloring\n    self.apply_gradient()\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.apply_gradient","title":"<code>apply_gradient()</code>","text":"<p>Apply interpolated colors as spans to each character in the text.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def apply_gradient(self) -&gt; None:\n    \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n    # Generate a color for each character\n    colors = self.interpolate_colors(self.colors)\n    if self._interpolate_bgcolors:\n        # Generate a background color for each character if bgcolors are interpolated\n        bgcolors = self.interpolate_colors(self.bgcolors)\n    else:\n        # If not interpolating background colors, use the first bgcolor for all characters\n        bgcolors = [self.bgcolors[0]] * len(colors)\n    # Apply a style span for each character with its corresponding color\n    for index, (color, bgcolor) in enumerate(zip(colors, bgcolors)):\n        # Build a style with the interpolated color\n        span_style = Style(color=color, bgcolor=bgcolor)\n        # Stylize the single character range\n        self.stylize(span_style, index, index + 1)\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.interpolate_colors","title":"<code>interpolate_colors(colors=None)</code>","text":"<p>Interpolate colors in the gradient.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def interpolate_colors(\n    self, colors: Optional[Sequence[Color]] = None\n) -&gt; list[Color]:\n    \"\"\"Interpolate colors in the gradient.\"\"\"\n    colors = list(colors) if colors is not None else self.colors\n    if not colors:\n        raise ValueError(\"No colors to interpolate\")\n    # Prepare the text and handle edge cases\n\n    text = self.plain\n    length = len(text)\n    if length == 0:\n        return []\n    num_colors = len(colors)\n    if num_colors == 1:\n        return [colors[0]] * length\n\n    # Compute number of segments between colors\n    segments = num_colors - 1\n    result: List[Color] = []\n\n    # For each character, determine its position and blend accordingly\n    for i in range(length):\n        # Normalized position along the entire text\n        pos = i / (length - 1) if length &gt; 1 else 0.0\n        # Determine which two colors to blend between\n        float_index = pos * segments\n        index = int(float_index)\n        # Clamp to valid segment range\n        if index &gt;= segments:\n            index = segments - 1\n            t = 1.0\n        else:\n            t = float_index - index\n\n        start = colors[index]\n        end = colors[index + 1]\n        triplet1 = start.get_truecolor()\n        triplet2 = end.get_truecolor()\n\n        # Interpolate each RGB component\n        r = int(triplet1.red + (triplet2.red - triplet1.red) * t)\n        g = int(triplet1.green + (triplet2.green - triplet1.green) * t)\n        b = int(triplet1.blue + (triplet2.blue - triplet1.blue) * t)\n\n        result.append(Color.from_rgb(r, g, b))\n\n    return result\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.parse_bgcolors","title":"<code>parse_bgcolors(bgcolors=None, hues=5)</code>","text":"<p>Parse and return a list of background colors for the gradient. Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects. Args:     bgcolors (Optional[Sequence[ColorType | Color]]): A list of background colors as Color instances or strings.     hues (int): The number of hues to generate if bgcolors are not provided. Returns:     List[Color]: A list of Color objects for background colors.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def parse_bgcolors(\n    self, bgcolors: Optional[Sequence[ColorType]] = None, hues: int = 5\n) -&gt; List[Color]:\n    \"\"\"Parse and return a list of background colors for the gradient.\n    Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n    Args:\n        bgcolors (Optional[Sequence[ColorType | Color]]): A list of background colors as Color instances or strings.\n        hues (int): The number of hues to generate if bgcolors are not provided.\n    Returns:\n        List[Color]: A list of Color objects for background colors.\n    \"\"\"\n    if bgcolors is None or len(bgcolors) == 0:\n        self._interpolate_bgcolors = False\n        return [Color.parse(\"default\")] * len(self.colors)\n\n    if len(bgcolors) == 1:\n        # If only one background color is provided, repeat it for each character\n        self._interpolate_bgcolors = False\n        return [Color.parse(bgcolors[0])] * len(self.colors)\n    # Support 3-digit hex colors and all string representations via Color.parse\n    self._interpolate_bgcolors = True\n    return [c if isinstance(c, Color) else Color.parse(c) for c in bgcolors]\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.parse_colors","title":"<code>parse_colors(colors=None, hues=5, rainbow=False)</code>  <code>staticmethod</code>","text":"<p>Parse and return a list of colors for the gradient. Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects. Args:     colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color instances or strings.     hues (int): The number of hues to generate if colors are not provided.     rainbow (bool): If True, generate a rainbow spectrum. Returns:     List[Color]: A list of Color objects.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>@staticmethod\ndef parse_colors(\n    colors: Optional[Sequence[ColorType]] = None,\n    hues: int = 5,\n    rainbow: bool = False,\n) -&gt; List[Color]:\n    \"\"\"Parse and return a list of colors for the gradient.\n    Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n    Args:\n        colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color instances or strings.\n        hues (int): The number of hues to generate if colors are not provided.\n        rainbow (bool): If True, generate a rainbow spectrum.\n    Returns:\n        List[Color]: A list of Color objects.\n    \"\"\"\n    if rainbow:\n        return Spectrum(hues=18).colors\n    if colors is None or len(colors) == 0:\n        return Spectrum(hues).colors\n    # Support 3-digit hex colors and all string representations via Color.parse\n    return [c if isinstance(c, Color) else Color.parse(c) for c in colors]\n</code></pre>"}]}