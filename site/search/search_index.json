{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>This library is a wrapper of the great rich library that extends rich.text.Text to allow for the easy generation gradient text from either user entered colors or randomly if no colors are entered.</p> <p>Borrowing from rich-color-ext rich_gradient extends the rich standard colors to include:</p> <ul> <li>3 or 6 digit hex code (e.g. <code>#f00</code> or <code>#ff0000</code>)</li> <li>RGB color codes (e.g. <code>rgb(255, 0, 0)</code>)</li> <li>RGB tuples   (e.g. <code>(255, 0, 0)</code>)</li> <li>CSS3 Color Names (e.g. <code>rebeccapurple</code>)</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#uv-recommended","title":"uv (Recommended)","text":"<pre><code>uv add rich-gradient\n</code></pre>"},{"location":"#pip","title":"Pip","text":"<pre><code>pip install rich-gradient\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#text-example","title":"Text Example","text":"<p>To print a simple gradient import the <code>Text</code> class from in the <code>rich_gradient</code> library:</p> <p></p>"},{"location":"#gradient","title":"Gradient","text":"<p>If just text is boring, <code>rich_gradient.gradient.Gradient</code> allows you to apply a gradient to any <code>rich.console.ConsoleRenderable</code>. Such as a <code>rich.panel.Panel</code> or <code>rich.table.Table</code>;</p> <pre><code>table = Table(\n    title=\"Gradient Table Example\",\n    border_style=\"bold\",\n)\ntable.add_column(\n    \"Renderable\",\n    style=\"bold\",\n    vertical=\"middle\",\n    justify=\"right\"\n)\ntable.add_column(\"Works w/Gradient\", justify=\"left\", style=\"bold\")\nrenderables = [\n    \"Text\",\n    \"Panel\",\n    \"Syntax\",\n    \"Table\",\n    \"Live\",\n    \"Group\",\n    \"Markdown\"\n]\nfor renderable in renderables:\n    table.add_row(\n        renderable,\n        \"[b]:heavy_check_mark:[/b]\"\n    )\n\nconsole.print(Gradient(table, rainbow=True), justify=\"center\")\n</code></pre> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#v032-2025-06-26-added-tests-and-renamed-rulespan","title":"v0.3.2 - 2025-06-26 |  Added tests and renamed Rule,/span&gt;","text":""},{"location":"CHANGELOG/#v032-removed","title":"v0.3.2 Removed","text":"<ul> <li>Dev Dependencies</li> <li><code>snoop</code></li> <li><code>cheap-repr</code></li> </ul>"},{"location":"CHANGELOG/#v032-updated","title":"v0.3.2 Updated","text":"<ul> <li>Removed instances that were imported from:</li> <li><code>snoop</code><ul> <li><code>@snoop()</code></li> </ul> </li> <li><code>cheap-repr</code><ul> <li>`register_repr(f\"{class})(normal_repr)</li> </ul> </li> <li>Renamed GradientRule -&gt; Rule</li> <li>to match the naming of the other modules in <code>rich-gradient</code></li> </ul>"},{"location":"CHANGELOG/#v032-added","title":"v0.3.2 Added","text":"<ul> <li>Tests</li> <li><code>tests/benchmark_perf.py</code>: To benchmark the performance of generating gradients that span large amounts of characters.</li> <li><code>tests/test_edge_cases.py</code>: To cover edge cases that may otherwise break <code>rich-gradient</code>.</li> </ul>"},{"location":"CHANGELOG/#v030-2025-06-20-working-rewrite","title":"v0.3.0 - 2025-06-20 |  Working Rewrite","text":""},{"location":"CHANGELOG/#v030-added","title":"v0.3.0 Added","text":"<ul> <li>Validated working and added tests for:</li> <li><code>rich_gradient.text.Text</code></li> <li><code>rich_gradient.gradient.Gradient</code></li> <li><code>rich_gradient.rule.GradientRule</code></li> <li><code>rich_gradient.spectrum.Spectrum</code></li> <li><code>rich-color-ext</code> acting as adequate replacement for previous color logic</li> <li>Added examples directory containing:</li> <li><code>animated_gradient_example.py</code></li> <li><code>gradient_example.py</code></li> <li><code>hello_world.py</code></li> <li><code>rainbow_gradient.py</code></li> <li><code>specific_color_gradient.py</code></li> <li><code>text_markup.py</code></li> <li><code>two_color_gradients.py</code></li> <li>Generated updated exports for examples for documentation (still in the works)</li> </ul>"},{"location":"CHANGELOG/#v030-updated","title":"v0.3.0 Updated","text":"<ul> <li><code>docs/index.md</code></li> </ul>"},{"location":"CHANGELOG/#v030-todo","title":"v0.3.0 TODO","text":"<ul> <li>Update Documentation</li> <li>Expand Tests</li> <li>Work on Gradient Panel and Table Renderables</li> </ul>"},{"location":"CHANGELOG/#v030-removed","title":"v0.3.0 Removed","text":"<p>Removed all of the the archived modules from rich_gradient/archive/*</p>"},{"location":"CHANGELOG/#v021-rewrite","title":"v0.2.1 Rewrite <p>There was a lot of overhead in rich-gradient so I rewrote it from the ground up with an actual goal. I created rich-color-ext to wrap around rich's color parsing removing the need for the<code>_rgb.py</code>, <code>color.py</code>, <code>color_data.py</code>, <code>_colors.py</code>, and all of their tests.</p>","text":""},{"location":"CHANGELOG/#v020-2025-3-13-uv-pure-python-and-3132","title":"v0.2.0 - 2025-3-13 | uv, pure python, and 3.13.2 <p>There are a number of significant changes in v0.2.0:</p>","text":""},{"location":"CHANGELOG/#rye-uv","title":"<code>rye</code> \u2192 <code>uv</code>","text":"<p>Astral has done a hell of a job making python dev tools. ruff blew the existing python linters out of the water and uv pretty much did the same thing to package managers. Rich-gradient was started on rye but as Astral has since depreciated it, it's moved to their current rust powered python package manager, uv.</p>"},{"location":"CHANGELOG/#pure-python","title":"Pure Python","text":"<p>Rich-gradient is now a pure-python package. This allows it to be more easily used regardless of platform. As rich-gradient previously had pydantic as a dependency, it now just borrows the logic from <code>pydantic-extra-types.color</code>.</p>"},{"location":"CHANGELOG/#3132","title":"3.13.2","text":"<p>After switching to uv, the package has been updated to python 3.13.2.</p>"},{"location":"CHANGELOG/#v020-updated","title":"v0.2.0 Updated <ul> <li>Switched rich-gradient package manager from astral/rye to astral/uv</li> <li>Updated python to <code>3.13.2</code></li> </ul>","text":""},{"location":"CHANGELOG/#v020-changed","title":"v0.2.0 Changed <ul> <li>Removed <code>pydantic</code> and <code>pydantic-extra-types</code> dependencies.</li> <li>Updated the names of some of the colors. For example greenyellow became lawngreen.</li> <li>Updated <code>README.md</code>, <code>CHANGELOG</code>, and documentation.</li> </ul>","text":""},{"location":"CHANGELOG/#v020-added","title":"v0.2.0 Added <ul> <li><code>src/rich_gradient/_base_color.py</code>: stores the color logic from pydantic-extra-types.color modules stripped of the pydantic framwork.</li> </ul>","text":""},{"location":"CHANGELOG/#v017-2024-7-16-added-support-for-two-color-gradients","title":"v0.1.7 - 2024-7-16 | Added support for Two-Color Gradients","text":""},{"location":"CHANGELOG/#v017-updated","title":"v0.1.7 Updated <ul> <li>Updated Gradient.generate_subgradients() to default to returning a list containing a single simple gradient to allow Gradients to work when only supplied with two colors.</li> </ul>","text":""},{"location":"CHANGELOG/#v017-added","title":"v0.1.7 Added <ul> <li>Added len, int, str, and repr dunder methods to <code>rich-gradient.gradient.Gradient</code> (will simply refer to as <code>Gradient</code> from here on out).</li> <li>Added a tests/test_gradient.py for Gradient to test two color gradiets</li> </ul>","text":""},{"location":"CHANGELOG/#v016-2024-6-28-updated-rev","title":"v0.1.6 - 2024-6-28 | Updated Rev","text":"<ul> <li>Updated rev to 0.1.6.</li> </ul>"},{"location":"CHANGELOG/#v015-2024-6-28-added-tests","title":"v0.1.5 - 2024-6-28 | Added Tests","text":""},{"location":"CHANGELOG/#v015-updated","title":"v0.1.5 Updated <ul> <li>Updated requirements for minimum versions of python from 3.8 -&gt; 3.10.</li> <li>Added <code>pytest</code> to dev-dependancies.</li> </ul>","text":""},{"location":"CHANGELOG/#v015-added","title":"v0.1.5 Added <ul> <li>Tests for:</li> <li>Color</li> <li>Specturm</li> <li>SimpleGradient</li> </ul>","text":""},{"location":"CHANGELOG/#v014-2024-6-28-resolved-dependancies","title":"v0.1.4 | 2024-6-28 | Resolved Dependancies","text":""},{"location":"CHANGELOG/#v014-updated","title":"v0.1.4 Updated <ul> <li>This release is primarily to prune unnecessary dependancies.</li> <li>Removed <code>numpy</code> to avoid issues of <code>numpy</code> version 2.0.0 conflicting with <code>torch</code>.</li> </ul>","text":""},{"location":"CHANGELOG/#v013-2021-10-10","title":"v0.1.3 - 2021-10-10","text":""},{"location":"CHANGELOG/#v013-fixed","title":"v0.1.3 Fixed <ul> <li>Updated README to use GitHub pages for example gradient image.</li> </ul>","text":""},{"location":"CHANGELOG/#v012-2021-10-10","title":"v0.1.2 - 2021-10-10","text":""},{"location":"CHANGELOG/#v012-updated","title":"v0.1.2 Updated <ul> <li>Updated PyProject.toml description.</li> <li>Moved MKDocs and related dependancies to dev-dependancies.</li> </ul>","text":""},{"location":"CHANGELOG/#v012-fixed","title":"v0.1.2 Fixed <ul> <li>Updated README to use GitHub pages for banner image.</li> <li>Updated README to use GitHub pages for docs url.</li> </ul>","text":""},{"location":"CHANGELOG/#v011-2021-10-10","title":"v0.1.1 - 2021-10-10","text":""},{"location":"CHANGELOG/#v011-fixed","title":"v0.1.1 Fixed <ul> <li>Updated README to use GitHub pages for images.</li> </ul>","text":""},{"location":"CHANGELOG/#v010-2021-10-10","title":"v0.1.0 - 2021-10-10","text":"<p>Initial release. Based off of MaxGradient with a simplified color model based on pydantic-extra-types.color.Color. Re-released as rich-gradient to avoid confusion with MaxGradient.</p>"},{"location":"gradient/","title":"Gradient","text":"<p>The <code>Gradient</code> class accepts any rich.console.ConsoleRenderable and prints it to a rich.console.Console instance in gradient color.</p> <pre><code>panel = Panel(\n    \"If you are looking for a way to display more than \\\na single line of text with a gradient, \\\nyou can use the `Gradient` class to \\\ncreate a gradient that can be applied to \\\nmultiple lines of text or any rich renderable object.\",\n    title=\"Gradient Example\",\n    title_align=\"left\",\n    padding=(1, 2),\n    border_style=\"bold\",\n    width=60,\n)\nconsole.print(Gradient(panel, rainbow=True), justify=\"center\")\n</code></pre> <p></p> <p>Or if you would like an animated gradient:</p> <pre><code>console = Console(width=64, record=True)\nconsole.line(2)\npanel = Panel(\n    \"This example demonstrates an animated gradient that shifts colors over time. \\\nYou can use the `Gradient` class to create a gradient that can be applied to any \\\nrich renderable object, such as text or panels. The animation is achieved by \\\nincrementing the phase of the gradient.\",\n    title=\"Animated Gradient\",\n    padding=(1, 2),\n)\ngradient = Gradient(panel, rainbow=True, animated=True)\nlive_renderable = gradient\n# Setup Live to refresh at ~30 FPS\nwith Live(live_renderable, console=console, refresh_per_second=30):\n    with suppress(KeyboardInterrupt):\n        while True:\n            time.sleep(0.03)\n            # Increment phase to animate gradient shift\n            gradient.phase += 0.2\n</code></pre> <p></p>"},{"location":"gradient_ref/","title":"Gradient","text":"<p>Render any Rich renderable with a smooth horizontal gradient.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient--parameters","title":"Parameters","text":"<p>renderable : RenderableType     The content to render (Text, Panel, Table, etc.). colors : List[ColorType], optional     A list of Rich color identifiers (hex, names, Color).  If provided, these     are used as gradient stops.  If omitted and rainbow=False, Spectrum is used. rainbow : bool     If True, uses the full rainbow spectrum instead of custom stops. background : bool     If True, applies gradient to the background color; otherwise to foreground.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>class Gradient:\n    \"\"\"\n    Render any Rich renderable with a smooth horizontal gradient.\n\n    Parameters\n    ----------\n    renderable : RenderableType\n        The content to render (Text, Panel, Table, etc.).\n    colors : List[ColorType], optional\n        A list of Rich color identifiers (hex, names, Color).  If provided, these\n        are used as gradient stops.  If omitted and rainbow=False, Spectrum is used.\n    rainbow : bool\n        If True, uses the full rainbow spectrum instead of custom stops.\n    background : bool\n        If True, applies gradient to the background color; otherwise to foreground.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: RenderableType,\n        colors: Optional[List[Union[Color, str]]] = None,\n        *,\n        rainbow: bool = False,\n        background: bool = False,\n        animated: bool = False,\n        phase: float = 0.0,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a gradient renderer.\n\n        Parameters:\n        -----------\n        renderable: RenderableType\n            The Rich renderable (Text, Panel, Table, etc.) to which the gradient will be applied.\n        colors: Optional[List[Union[Color, str]]]\n            List of color stops as Color instances or color identifiers (hex strings or names).\n            If omitted and rainbow=False, a default spectrum of hues is used.\n        rainbow: bool\n            If True, ignore custom colors and use the full rainbow spectrum.\n        background: bool\n            If True, apply gradient to the background; otherwise to the foreground.\n        phase: float\n            Initial offset for animation (may be fractional for finer control); increments advance the gradient.\n        animated: bool\n            If True, wraps renderable with a footer panel indicating Ctrl+C to stop.\n        \"\"\"\n        if animated:\n            footer = RichPanel(\" Press Ctrl+C to stop.\", expand=False)\n            renderable = Group(renderable, Align.right(footer))\n        self.renderable = renderable\n        self.rainbow = rainbow\n        self.background = background\n        self.phase: float = phase\n        self.animated = animated\n        self._stops = self._compute_stops(colors, rainbow)\n\n    def _compute_stops(\n        self, colors: Optional[List[Union[Color, str]]], rainbow: bool\n    ) -&gt; list:\n        \"\"\"\n        Compute the color stops for the gradient.\n\n        Parameters:\n            colors: Optional[List[Union[Color, str]]]\n                List of color stops as Color instances or color identifiers.\n            rainbow: bool\n                If True, use the full rainbow spectrum.\n\n        Returns:\n            List[Tuple[int, int, int]]: List of RGB tuples.\n        \"\"\"\n        stops = []\n        if rainbow or not colors:\n            spec = Spectrum()\n            color_iter = spec.colors\n        else:\n            color_iter = [\n                c if isinstance(c, Color) else Color.parse(c) for c in colors\n            ]\n        for color in color_iter:\n            r, g, b = color.get_truecolor()\n            stops.append((r, g, b))\n        if (not rainbow and colors) and len(stops) == 1:\n            stops *= 2\n        if self.animated and len(stops) &gt; 1 and stops[0] != stops[-1]:\n            stops.append(stops[0])\n        return stops\n\n    # ---------------------------\n    # Layout measurement hook\n    # ---------------------------\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; Measurement:\n        \"\"\"\n        Measure the size required by the inner renderable under given console constraints.\n\n        Returns:\n            Measurement: Width constraints for rendering.\n        \"\"\"\n        # Delegate layout measurement to the inner renderable\n        return Measurement.get(console, options, self.renderable)\n\n    # ---------------------------\n    # Console render hook\n    # ---------------------------\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n        \"\"\"\n        Render each line of the inner renderable, applying the gradient per character.\n\n        Yields:\n            Segment: Styled text segments with gradient coloring.\n        \"\"\"\n        # Use the renderable's width constraint for gradient span\n        target_width = console.width or 80\n\n        # Include padding (borders, margins) in the rendered lines\n        lines = console.render_lines(\n            self.renderable, options, pad=True, new_lines=False\n        )\n\n        for line_no, segments in enumerate(lines):\n            # Compute total visible width of this line\n            col = 0\n            for seg in segments:\n                text = seg.text\n                base_style = seg.style or Style()\n                cluster = \"\"\n                cluster_width = 0\n                for ch in text:\n                    w = get_character_cell_size(\n                        ch\n                    )  # Use rich.text.cells instead of wcwidth\n                    if w &lt;= 0:\n                        cluster += ch\n                        continue\n                    # flush any accumulated cluster\n                    if cluster:\n                        color = self._color_at(\n                            col - cluster_width, cluster_width, target_width\n                        )\n                        yield Segment(cluster, self._styled(base_style, color))\n                        cluster = \"\"\n                        cluster_width = 0\n                    cluster = ch\n                    cluster_width = w\n                    col += w\n                if cluster:\n                    color = self._color_at(\n                        col - cluster_width, cluster_width, target_width\n                    )\n                    yield Segment(cluster, self._styled(base_style, color))\n            # end-of-line: newline if not last\n            if line_no &lt; len(lines) - 1:\n                yield Segment.line()\n\n    # ---------------------------\n    # Gradient color calculation\n    # ---------------------------\n    def _color_at(self, position: int, width: int, span: int) -&gt; str:\n        \"\"\"\n        Compute the hex color code at a given character position within the span.\n\n        Parameters:\n            position: int\n                Starting cell index of the character or cluster.\n            width: int\n                Cell width of the character or cluster.\n            span: int\n                Total available width for gradient calculation.\n\n        Returns:\n            str: A hex color string (#rrggbb).\n        \"\"\"\n        frac = self._compute_frac(position, width, span)\n        stops = self._stops\n        count = len(stops)\n        if count == 0:\n            return \"\"\n        r, g, b = self._interpolated_color(frac, stops, count)\n        return f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n\n    def _compute_frac(self, position: int, width: int, span: int) -&gt; float:\n        \"\"\"Compute the fractional position for the gradient, including phase shift.\"\"\"\n        frac = (position + width / 2 + self.phase) / max(span - 1, 1)\n        return frac % 1.0 if self.animated else min(frac, 1.0)\n\n    def _interpolated_color(self, frac: float, stops: list, count: int):\n        \"\"\"Interpolate the color at the given fractional position.\"\"\"\n        if frac &lt;= 0:\n            return stops[0]\n        elif frac &gt;= 1:\n            return stops[-1]\n        else:\n            seg = frac * (count - 1)\n            idx = int(seg)\n            t = seg - idx\n            r1, g1, b1 = stops[idx]\n            r2, g2, b2 = stops[min(idx + 1, count - 1)]\n            r = r1 + (r2 - r1) * t\n            g = g1 + (g2 - g1) * t\n            b = b1 + (b2 - b1) * t\n            return r, g, b\n\n    # ---------------------------\n    # Style application helper\n    # ---------------------------\n    def _styled(self, original: Style, color: str) -&gt; Style:\n        \"\"\"\n        Combine the original style with a gradient color applied to foreground or background.\n\n        Parameters:\n            original: Style\n                The existing Rich style for the segment.\n            color: str\n                Hex color string to apply.\n\n        Returns:\n            Style: A new Style with gradient coloring merged.\n        \"\"\"\n        grad = Style(bgcolor=color) if self.background else Style(color=color)\n        return Style.combine([original, grad])\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__init__","title":"<code>__init__(renderable, colors=None, *, rainbow=False, background=False, animated=False, phase=0.0)</code>","text":"<p>Initialize a gradient renderer.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__init__--parameters","title":"Parameters:","text":"<p>renderable: RenderableType     The Rich renderable (Text, Panel, Table, etc.) to which the gradient will be applied. colors: Optional[List[Union[Color, str]]]     List of color stops as Color instances or color identifiers (hex strings or names).     If omitted and rainbow=False, a default spectrum of hues is used. rainbow: bool     If True, ignore custom colors and use the full rainbow spectrum. background: bool     If True, apply gradient to the background; otherwise to the foreground. phase: float     Initial offset for animation (may be fractional for finer control); increments advance the gradient. animated: bool     If True, wraps renderable with a footer panel indicating Ctrl+C to stop.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __init__(\n    self,\n    renderable: RenderableType,\n    colors: Optional[List[Union[Color, str]]] = None,\n    *,\n    rainbow: bool = False,\n    background: bool = False,\n    animated: bool = False,\n    phase: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Initialize a gradient renderer.\n\n    Parameters:\n    -----------\n    renderable: RenderableType\n        The Rich renderable (Text, Panel, Table, etc.) to which the gradient will be applied.\n    colors: Optional[List[Union[Color, str]]]\n        List of color stops as Color instances or color identifiers (hex strings or names).\n        If omitted and rainbow=False, a default spectrum of hues is used.\n    rainbow: bool\n        If True, ignore custom colors and use the full rainbow spectrum.\n    background: bool\n        If True, apply gradient to the background; otherwise to the foreground.\n    phase: float\n        Initial offset for animation (may be fractional for finer control); increments advance the gradient.\n    animated: bool\n        If True, wraps renderable with a footer panel indicating Ctrl+C to stop.\n    \"\"\"\n    if animated:\n        footer = RichPanel(\" Press Ctrl+C to stop.\", expand=False)\n        renderable = Group(renderable, Align.right(footer))\n    self.renderable = renderable\n    self.rainbow = rainbow\n    self.background = background\n    self.phase: float = phase\n    self.animated = animated\n    self._stops = self._compute_stops(colors, rainbow)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render each line of the inner renderable, applying the gradient per character.</p> <p>Yields:</p> Name Type Description <code>Segment</code> <code>RenderResult</code> <p>Styled text segments with gradient coloring.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __rich_console__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; RenderResult:\n    \"\"\"\n    Render each line of the inner renderable, applying the gradient per character.\n\n    Yields:\n        Segment: Styled text segments with gradient coloring.\n    \"\"\"\n    # Use the renderable's width constraint for gradient span\n    target_width = console.width or 80\n\n    # Include padding (borders, margins) in the rendered lines\n    lines = console.render_lines(\n        self.renderable, options, pad=True, new_lines=False\n    )\n\n    for line_no, segments in enumerate(lines):\n        # Compute total visible width of this line\n        col = 0\n        for seg in segments:\n            text = seg.text\n            base_style = seg.style or Style()\n            cluster = \"\"\n            cluster_width = 0\n            for ch in text:\n                w = get_character_cell_size(\n                    ch\n                )  # Use rich.text.cells instead of wcwidth\n                if w &lt;= 0:\n                    cluster += ch\n                    continue\n                # flush any accumulated cluster\n                if cluster:\n                    color = self._color_at(\n                        col - cluster_width, cluster_width, target_width\n                    )\n                    yield Segment(cluster, self._styled(base_style, color))\n                    cluster = \"\"\n                    cluster_width = 0\n                cluster = ch\n                cluster_width = w\n                col += w\n            if cluster:\n                color = self._color_at(\n                    col - cluster_width, cluster_width, target_width\n                )\n                yield Segment(cluster, self._styled(base_style, color))\n        # end-of-line: newline if not last\n        if line_no &lt; len(lines) - 1:\n            yield Segment.line()\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__rich_measure__","title":"<code>__rich_measure__(console, options)</code>","text":"<p>Measure the size required by the inner renderable under given console constraints.</p> <p>Returns:</p> Name Type Description <code>Measurement</code> <code>Measurement</code> <p>Width constraints for rendering.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __rich_measure__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; Measurement:\n    \"\"\"\n    Measure the size required by the inner renderable under given console constraints.\n\n    Returns:\n        Measurement: Width constraints for rendering.\n    \"\"\"\n    # Delegate layout measurement to the inner renderable\n    return Measurement.get(console, options, self.renderable)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._color_at","title":"<code>_color_at(position, width, span)</code>","text":"<p>Compute the hex color code at a given character position within the span.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>int Starting cell index of the character or cluster.</p> required <code>width</code> <code>int</code> <p>int Cell width of the character or cluster.</p> required <code>span</code> <code>int</code> <p>int Total available width for gradient calculation.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A hex color string (#rrggbb).</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _color_at(self, position: int, width: int, span: int) -&gt; str:\n    \"\"\"\n    Compute the hex color code at a given character position within the span.\n\n    Parameters:\n        position: int\n            Starting cell index of the character or cluster.\n        width: int\n            Cell width of the character or cluster.\n        span: int\n            Total available width for gradient calculation.\n\n    Returns:\n        str: A hex color string (#rrggbb).\n    \"\"\"\n    frac = self._compute_frac(position, width, span)\n    stops = self._stops\n    count = len(stops)\n    if count == 0:\n        return \"\"\n    r, g, b = self._interpolated_color(frac, stops, count)\n    return f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._compute_frac","title":"<code>_compute_frac(position, width, span)</code>","text":"<p>Compute the fractional position for the gradient, including phase shift.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _compute_frac(self, position: int, width: int, span: int) -&gt; float:\n    \"\"\"Compute the fractional position for the gradient, including phase shift.\"\"\"\n    frac = (position + width / 2 + self.phase) / max(span - 1, 1)\n    return frac % 1.0 if self.animated else min(frac, 1.0)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._compute_stops","title":"<code>_compute_stops(colors, rainbow)</code>","text":"<p>Compute the color stops for the gradient.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>Optional[List[Union[Color, str]]]</code> <p>Optional[List[Union[Color, str]]] List of color stops as Color instances or color identifiers.</p> required <code>rainbow</code> <code>bool</code> <p>bool If True, use the full rainbow spectrum.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List[Tuple[int, int, int]]: List of RGB tuples.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _compute_stops(\n    self, colors: Optional[List[Union[Color, str]]], rainbow: bool\n) -&gt; list:\n    \"\"\"\n    Compute the color stops for the gradient.\n\n    Parameters:\n        colors: Optional[List[Union[Color, str]]]\n            List of color stops as Color instances or color identifiers.\n        rainbow: bool\n            If True, use the full rainbow spectrum.\n\n    Returns:\n        List[Tuple[int, int, int]]: List of RGB tuples.\n    \"\"\"\n    stops = []\n    if rainbow or not colors:\n        spec = Spectrum()\n        color_iter = spec.colors\n    else:\n        color_iter = [\n            c if isinstance(c, Color) else Color.parse(c) for c in colors\n        ]\n    for color in color_iter:\n        r, g, b = color.get_truecolor()\n        stops.append((r, g, b))\n    if (not rainbow and colors) and len(stops) == 1:\n        stops *= 2\n    if self.animated and len(stops) &gt; 1 and stops[0] != stops[-1]:\n        stops.append(stops[0])\n    return stops\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._interpolated_color","title":"<code>_interpolated_color(frac, stops, count)</code>","text":"<p>Interpolate the color at the given fractional position.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _interpolated_color(self, frac: float, stops: list, count: int):\n    \"\"\"Interpolate the color at the given fractional position.\"\"\"\n    if frac &lt;= 0:\n        return stops[0]\n    elif frac &gt;= 1:\n        return stops[-1]\n    else:\n        seg = frac * (count - 1)\n        idx = int(seg)\n        t = seg - idx\n        r1, g1, b1 = stops[idx]\n        r2, g2, b2 = stops[min(idx + 1, count - 1)]\n        r = r1 + (r2 - r1) * t\n        g = g1 + (g2 - g1) * t\n        b = b1 + (b2 - b1) * t\n        return r, g, b\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient._styled","title":"<code>_styled(original, color)</code>","text":"<p>Combine the original style with a gradient color applied to foreground or background.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>Style</code> <p>Style The existing Rich style for the segment.</p> required <code>color</code> <code>str</code> <p>str Hex color string to apply.</p> required <p>Returns:</p> Name Type Description <code>Style</code> <code>Style</code> <p>A new Style with gradient coloring merged.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def _styled(self, original: Style, color: str) -&gt; Style:\n    \"\"\"\n    Combine the original style with a gradient color applied to foreground or background.\n\n    Parameters:\n        original: Style\n            The existing Rich style for the segment.\n        color: str\n            Hex color string to apply.\n\n    Returns:\n        Style: A new Style with gradient coloring merged.\n    \"\"\"\n    grad = Style(bgcolor=color) if self.background else Style(color=color)\n    return Style.combine([original, grad])\n</code></pre>"},{"location":"rule/","title":"Rule","text":""},{"location":"rule/#rule","title":"Rule","text":"<p>The 'Rule` class is based off of the rich.rule.Rule class and is used to define a rule in gradient color and variable thickness.</p>"},{"location":"rule/#usage","title":"Usage","text":"<pre><code>from rich.console import Console\nfrom rich_gradient.rule import Rule\n\nconsole = Console()\nconsole.print(\n    Rule(\n        \"Hello, world!\",\n    )\n)\n</code></pre>"},{"location":"rule/#alignment","title":"Alignment","text":"<p>The <code>Rule</code> class supports the same alignment options as the <code>Rule</code> class.</p>"},{"location":"rule/#left-aligned-rule","title":"Left Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"\u2190 This is a left aligned rule.\",\n        align=\"left\",\n    )\n)\n</code></pre>"},{"location":"rule/#right-aligned-rule","title":"Right Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a right aligned rule. \u2192,\n        align=\"right\"\n    )\n)\n</code></pre>"},{"location":"rule/#center-aligned-rule","title":"Center Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"\u2192 This is a center aligned rule. \u2190\",\n        align=\"center\"\n    )\n)\n</code></pre> <p>Note</p> <p>The default behavior of rich_gradient.rule.Rule is center aligned.</p>"},{"location":"rule/#thickness","title":"Thickness","text":"<p>The <code>Rule</code> class add the ability to determine the thickness of the rule. Valid values are:</p> <ol> <li><code>thin</code> (<code>\u2500</code>)</li> <li><code>double</code> (<code>\u2550</code>)</li> <li><code>medium</code> (<code>\u2501</code>) (default)</li> <li><code>thick</code> (<code>\u2588</code>)</li> </ol>"},{"location":"rule/#thin-rule","title":"Thin Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a thin rule\",\n        thickness=1\n    )\n)\n</code></pre>"},{"location":"rule/#double-line-rule","title":"Double-line Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a double-line rule\",\n        thickness=2\n    )\n)\n</code></pre>"},{"location":"rule/#medium-rule","title":"Medium Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a medium rule\",\n        thickness=3\n    )\n)\n</code></pre>"},{"location":"rule/#thick-rule","title":"Thick Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a thick rule\",\n        thickness=4\n    )\n)\n</code></pre>"},{"location":"rule/#custom-colored-rule","title":"Custom Colored Rule","text":"<p>To create a rule with custom colors, simply supply the <code>colors</code> parameter with a list of colors (as CSS color names, 3 or 6 digit hex codes, rich color names, or rgb color codes).</p> console.print( Rule( \"This rule has custom colors!\", colors=[ \"#f00\", # red \"#f90\", # orange \"#ff0\", # yellow \"#9f0\", # yellow-green ]    \u00a0\u00a0) )  <p></p> <p></p>"},{"location":"rule/#custom-title-style","title":"Custom Title Style","text":"<p>If you would like some distinction between the rule and it's title, simply pass a rich style to the <code>title_style</code> parameter:</p> <pre><code>console.print(\n     Rule(\n         \"Custom Styled Rule Title\",\n         title_style=\"bold white\",\n         align=\"center\"\n     )\n)\n</code></pre> <p></p>"},{"location":"rule_ref/","title":"Rule Reference","text":"<p>               Bases: <code>Rule</code></p> <p>A Rule with a gradient background.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Optional[str]</code> <p>The text to display as the title.</p> required <code>title_style</code> <code>StyleType</code> <p>The style to apply to the title text. Defaults to NULL_STYLE.</p> <code>parse('bold')</code> <code>colors</code> <code>List[ColorType]</code> <p>A list of color strings for the gradient. Defaults to empty list.</p> <code>None</code> <code>thickness</code> <code>int</code> <p>Thickness level of the rule (0 to 3). Defaults to 2.</p> <code>2</code> <code>style</code> <code>StyleType</code> <p>The style of the rule line. Defaults to NULL_STYLE.</p> <code>NULL_STYLE</code> <code>rainbow</code> <code>bool</code> <p>If True, use a rainbow gradient regardless of colors. Defaults to False.</p> <code>False</code> <code>hues</code> <code>int</code> <p>Number of hues in the gradient if colors are not provided. Defaults to 10.</p> <code>10</code> <code>end</code> <code>str</code> <p>End character after the rule. Defaults to newline.</p> <code>'\\n'</code> <code>align</code> <code>AlignMethod</code> <p>Alignment of the rule. Defaults to \"center\".</p> <code>'center'</code> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>class Rule(RichRule):\n    \"\"\"A Rule with a gradient background.\n\n    Args:\n        title (Optional[str]): The text to display as the title.\n        title_style (StyleType, optional): The style to apply to the title text. Defaults to NULL_STYLE.\n        colors (List[ColorType], optional): A list of color strings for the gradient. Defaults to empty list.\n        thickness (int, optional): Thickness level of the rule (0 to 3). Defaults to 2.\n        style (StyleType, optional): The style of the rule line. Defaults to NULL_STYLE.\n        rainbow (bool, optional): If True, use a rainbow gradient regardless of colors. Defaults to False.\n        hues (int, optional): Number of hues in the gradient if colors are not provided. Defaults to 10.\n        end (str, optional): End character after the rule. Defaults to newline.\n        align (AlignMethod, optional): Alignment of the rule. Defaults to \"center\".\n    \"\"\"\n\n    def __init__(\n        self,\n        title: Optional[str],\n        title_style: StyleType = Style.parse(\"bold\"),\n        colors: Optional[List[ColorInputType]] = None,\n        thickness: int = 2,\n        style: StyleType = NULL_STYLE,\n        rainbow: bool = False,\n        hues: int = 10,\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n    ) -&gt; None:\n        # Validate thickness input\n        if thickness &lt; 0 or thickness &gt; 3:\n            raise ValueError(\n                f\"Invalid thickness: {thickness}. Thickness must be between 0 and 3.\"\n            )\n        # Validate type\n        if title is not None and not isinstance(title, str):\n            raise TypeError(f\"title must be str, got {type(title).__name__}\")\n\n        if not isinstance(title_style, (str, Style)):\n            raise TypeError(\n                f\"title_style must be str or Style, got {type(title_style).__name__}\"\n            )\n        if not isinstance(style, (str, Style)):\n            raise TypeError(f\"style must be str or Style, got {type(style).__name__}\")\n        # Determine character based on thickness\n        self.characters = CHARACTER_MAP.get(thickness, \"\u2501\")\n        # Parse and store the title style\n        self.title_style = Style.parse(str(title_style))\n        # Initialize the base Rule with provided parameters\n        super().__init__(\n            title=title or \"\",\n            characters=self.characters,\n            style=Style.parse(str(style)),\n            end=end,\n            align=align,\n        )\n        # Parse and store the gradient colors\n        self.colors = self._parse_colors(\n            colors if colors is not None else [], rainbow, hues\n        )\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n        \"\"\"Render the gradient rule.\n\n        Args:\n            console (Console): The console to render to.\n            options (ConsoleOptions): The console options.\n\n        Yields:\n            RenderResult: The rendered segments of the gradient rule.\n        \"\"\"\n        # Prepare a base rule with no style to extract segments\n        base_rule = RichRule(\n            title=self.title or \"\",\n            characters=self.characters,\n            style=NULL_STYLE,\n            end=self.end,\n            align=cast(AlignMethod, self.align),\n        )\n        # Render the base rule to get segments\n        rule_segments = console.render(base_rule, options=options)\n        # Concatenate segment texts to form the full rule text\n        rule_text = \"\".join(seg.text for seg in rule_segments)\n\n        # If no title style, render the gradient text directly\n        if self.title_style == NULL_STYLE:\n            gradient_rule = Text(rule_text, colors=self.colors)\n            yield from console.render(gradient_rule, options)\n            return\n        # Create gradient text for the rule\n        gradient_rule = Text(rule_text, colors=self.colors)\n\n        # Extract the title string for highlighting\n        title = self.title.plain if isinstance(self.title, Text) else str(self.title)\n\n        # Apply the title style highlight after gradient generation\n        if title and self.title_style != NULL_STYLE:\n            gradient_rule.highlight_words([title], style=self.title_style)\n\n        # Yield the styled gradient text\n        yield from console.render(gradient_rule, options)\n\n    def _parse_colors(\n        self,\n        colors: Sequence[ColorInputType],\n        rainbow: bool,\n        hues: int,\n    ) -&gt; List[str]:\n        \"\"\"Parse colors for the gradient.\n\n        Args:\n            colors (List[ColorType]): A list of color strings.\n            rainbow (bool): If True, use a rainbow gradient.\n            hues (int): Number of hues in the gradient.\n        Raises:\n            ValueError: If any color is not a valid string.\n            ColorParseError: If a color string cannot be parsed.\n\n        Returns:\n            List[str]: A list of hex color strings for the gradient.\n        \"\"\"\n        # Use full rainbow spectrum if rainbow flag is set, or if insufficient colors\n        if rainbow:\n            return Spectrum(hues).hex\n        _colors: List[str] = []\n        if colors and len(colors) &lt; 2:\n            raise ValueError(\n                \"At least two colors are required for a gradient. \",\n                \"Please provide a list of at least two color strings.\",\n                f\"Received: {colors=}\",\n            )\n        if not colors:\n            # If no colors provided, generate a random gradient\n            return Spectrum(hues).hex\n        for color in colors:\n            # Validate color is a string\n            if not isinstance(color, str):\n                raise ValueError(\n                    f\"Invalid color: {color}. Please provide a valid color string.\"\n                )\n            try:\n                # Convert color string to hex format\n                _colors.append(Color.parse(color).get_truecolor().hex)\n            except ColorParseError as ce:\n                raise ColorParseError(\n                    f\"Invalid color: {color}. Please provide a valid color string.\"\n                ) from ce\n        return _colors\n</code></pre>"},{"location":"rule_ref/#rich_gradient.rule.Rule.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render the gradient rule.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>The console to render to.</p> required <code>options</code> <code>ConsoleOptions</code> <p>The console options.</p> required <p>Yields:</p> Name Type Description <code>RenderResult</code> <code>RenderResult</code> <p>The rendered segments of the gradient rule.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def __rich_console__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; RenderResult:\n    \"\"\"Render the gradient rule.\n\n    Args:\n        console (Console): The console to render to.\n        options (ConsoleOptions): The console options.\n\n    Yields:\n        RenderResult: The rendered segments of the gradient rule.\n    \"\"\"\n    # Prepare a base rule with no style to extract segments\n    base_rule = RichRule(\n        title=self.title or \"\",\n        characters=self.characters,\n        style=NULL_STYLE,\n        end=self.end,\n        align=cast(AlignMethod, self.align),\n    )\n    # Render the base rule to get segments\n    rule_segments = console.render(base_rule, options=options)\n    # Concatenate segment texts to form the full rule text\n    rule_text = \"\".join(seg.text for seg in rule_segments)\n\n    # If no title style, render the gradient text directly\n    if self.title_style == NULL_STYLE:\n        gradient_rule = Text(rule_text, colors=self.colors)\n        yield from console.render(gradient_rule, options)\n        return\n    # Create gradient text for the rule\n    gradient_rule = Text(rule_text, colors=self.colors)\n\n    # Extract the title string for highlighting\n    title = self.title.plain if isinstance(self.title, Text) else str(self.title)\n\n    # Apply the title style highlight after gradient generation\n    if title and self.title_style != NULL_STYLE:\n        gradient_rule.highlight_words([title], style=self.title_style)\n\n    # Yield the styled gradient text\n    yield from console.render(gradient_rule, options)\n</code></pre>"},{"location":"rule_ref/#rich_gradient.rule.Rule._parse_colors","title":"<code>_parse_colors(colors, rainbow, hues)</code>","text":"<p>Parse colors for the gradient.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>List[ColorType]</code> <p>A list of color strings.</p> required <code>rainbow</code> <code>bool</code> <p>If True, use a rainbow gradient.</p> required <code>hues</code> <code>int</code> <p>Number of hues in the gradient.</p> required <p>Raises:     ValueError: If any color is not a valid string.     ColorParseError: If a color string cannot be parsed.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of hex color strings for the gradient.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def _parse_colors(\n    self,\n    colors: Sequence[ColorInputType],\n    rainbow: bool,\n    hues: int,\n) -&gt; List[str]:\n    \"\"\"Parse colors for the gradient.\n\n    Args:\n        colors (List[ColorType]): A list of color strings.\n        rainbow (bool): If True, use a rainbow gradient.\n        hues (int): Number of hues in the gradient.\n    Raises:\n        ValueError: If any color is not a valid string.\n        ColorParseError: If a color string cannot be parsed.\n\n    Returns:\n        List[str]: A list of hex color strings for the gradient.\n    \"\"\"\n    # Use full rainbow spectrum if rainbow flag is set, or if insufficient colors\n    if rainbow:\n        return Spectrum(hues).hex\n    _colors: List[str] = []\n    if colors and len(colors) &lt; 2:\n        raise ValueError(\n            \"At least two colors are required for a gradient. \",\n            \"Please provide a list of at least two color strings.\",\n            f\"Received: {colors=}\",\n        )\n    if not colors:\n        # If no colors provided, generate a random gradient\n        return Spectrum(hues).hex\n    for color in colors:\n        # Validate color is a string\n        if not isinstance(color, str):\n            raise ValueError(\n                f\"Invalid color: {color}. Please provide a valid color string.\"\n            )\n        try:\n            # Convert color string to hex format\n            _colors.append(Color.parse(color).get_truecolor().hex)\n        except ColorParseError as ce:\n            raise ColorParseError(\n                f\"Invalid color: {color}. Please provide a valid color string.\"\n            ) from ce\n    return _colors\n</code></pre>"},{"location":"text/","title":"rich_gradient.text.Text","text":"<p>If you pass <code>rich_gradient.text.Text</code> a string, it will print the string to the console in a random gradient. Rich-gradient's <code>Text</code> class inherits from <code>rich.text.Text</code>. In addition to all of it's parent's parameters, <code>rich_gradient.text.Text</code> also accepts:</p> <ul> <li><code>colors</code>: (<code>List[ColorType]</code>) - A list of strings that can be parsed by <code>rich.color.Color</code>.</li> </ul> \ud83d\udcdd Note<code>rich_color_ext</code> extends rich to be able to parse:   <ul> <li>CSS color names: <ul> <li>\u25c9 rebeccapurple</li> <li>\u25c9 salmon</li> <li>\u25c9 aliceblue</li> </ul> </li><li>3-Digit Hex Color Codes: <ul> <li>\u25c9 #abc</li> <li>\u25c9 #FDC</li> <li>\u25c9 #A1f          <ul> <li><code>hues</code>: (<code>int</code>) - The number of color stops a gradient should use</li> <li><code>rainbow</code>: (<code>bool</code>) - Whether to create a gradient that spans the entire spectrum. Defaults to <code>False</code></li> <li><code>markup</code>: (<code>bool</code>) - Whether to respect the inputs existing styles. Defaults  to <code>True</code></li> </ul>"},{"location":"text/#gradient-text-with-specific-colors","title":"Gradient Text with Specific Colors","text":"<p>To have more control over the gradient that is printed, you can pass the <code>colors</code> parameter a list of colors. Colors can be parsed from: -  CSS colors names, -  3 or 6 digit hex codes, -  <code>rich.color.Color</code> instances or names, -  any string or style that <code>rich.color.Color</code> can parse.</p> <p></p>"},{"location":"text/#rainbow-gradient-text-example","title":"Rainbow Gradient Text Example","text":"<p>If four colors isn't enough, you can use the 'rainbow' parameter to generate a rainbow gradient that spans the entire spectrum of colors randomly.</p> <p></p> <p>*The rainbow gradient is generated randomly each time the code is run.</p>"},{"location":"text/#still-inherits-from-richtexttext","title":"Still inherits from <code>rich.text.Text</code>","text":"<p>Since <code>rich_gradient.text.Text</code> is a subclass of <code>rich.text.Text</code>, you can still use all the same methods and parameters as you would.</p> <p></p>"},{"location":"text_ref/","title":"Text","text":"<p>               Bases: <code>Text</code></p> <p>A rich text class that supports gradient colors and styles.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>class Text(RichText):\n    \"\"\"A rich text class that supports gradient colors and styles.\"\"\"\n\n    def __init__(\n        self,\n        text: TextType = \"\",\n        colors: Optional[Sequence[ColorInputType]] = None,\n        *,\n        rainbow: bool = False,\n        hues: int = 5,\n        style: StyleType = \"\",\n        justify: JustifyMethod = \"default\",\n        overflow: OverflowMethod = \"fold\",\n        no_wrap: bool = False,\n        end: str = \"\\n\",\n        tab_size: int = 4,\n        markup: bool = True,\n    ):\n        \"\"\"Initialize the Text with gradient colors and styles.\n        Args:\n            text (TextType): The text content.\n            colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n            rainbow (bool): If True, generate a rainbow spectrum.\n            hues (int): The number of hues to generate if colors are not provided.\n            style (StyleType): The style of the text.\n            justify (JustifyMethod): Justification method for the text.\n            overflow (OverflowMethod): Overflow method for the text.\n            no_wrap (bool): If True, disable wrapping of the text.\n            markup (bool): If True, parse Rich markup tags in the input text.\n        \"\"\"\n        # Extract out complex expressions for clarity\n        parsed_text = RichText.from_markup(\n            text=str(text), style=style, justify=justify, overflow=overflow\n        )\n        plain = parsed_text.plain\n        parsed_justify = parsed_text.justify\n        parsed_overflow = parsed_text.overflow\n        parsed_spans = parsed_text._spans\n\n        super().__init__(\n            plain,\n            justify=parsed_justify,\n            overflow=parsed_overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            spans=parsed_spans,\n        )\n        self.colors = self.parse_colors(colors, hues, rainbow)\n        # Handle the single color case: apply style directly and return early\n        if len(self.colors) == 1:\n            # Apply the single color style directly\n            style_with_color = Style(color=self.colors[0]) + Style.parse(style)\n            for index in range(len(self.plain)):\n                self.stylize(style_with_color, index, index + 1)\n            return\n        # Apply the gradient coloring\n        self.apply_gradient()\n\n    @property\n    def colors(self) -&gt; Sequence[Color]:\n        \"\"\"Return the list of colors in the gradient.\"\"\"\n        return self._colors\n\n    @colors.setter\n    def colors(self, value: Optional[Sequence[Color]]) -&gt; None:\n        \"\"\"Set the list of colors in the gradient.\"\"\"\n        self._colors = value or []\n\n    @staticmethod\n    def parse_colors(\n        colors: Optional[Sequence[ColorInputType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of colors for the gradient.\n        Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n        Args:\n            colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color instances or strings.\n            hues (int): The number of hues to generate if colors are not provided.\n            rainbow (bool): If True, generate a rainbow spectrum.\n        Returns:\n            List[Color]: A list of Color objects.\n        \"\"\"\n        if rainbow:\n            return Spectrum(hues=18).colors\n        if colors is None or len(colors) == 0:\n            return Spectrum(hues).colors\n        # Support 3-digit hex colors and all string representations via Color.parse\n        return [c if isinstance(c, Color) else Color.parse(c) for c in colors]\n\n    def interpolate_colors(self) -&gt; List[Color]:\n        \"\"\"Interpolate colors in the gradient.\"\"\"\n        if not self.colors:\n            raise ValueError(\"No colors to interpolate\")\n        # Prepare the text and handle edge cases\n        text = self.plain\n        length = len(text)\n        if length == 0:\n            return []\n        num_colors = len(self.colors)\n        if num_colors == 1:\n            return [self.colors[0]] * length\n\n        # Compute number of segments between colors\n        segments = num_colors - 1\n        result: List[Color] = []\n\n        # For each character, determine its position and blend accordingly\n        for i in range(length):\n            # Normalized position along the entire text\n            pos = i / (length - 1) if length &gt; 1 else 0.0\n            # Determine which two colors to blend between\n            float_index = pos * segments\n            index = int(float_index)\n            # Clamp to valid segment range\n            if index &gt;= segments:\n                index = segments - 1\n                t = 1.0\n            else:\n                t = float_index - index\n\n            start = self.colors[index]\n            end = self.colors[index + 1]\n            triplet1 = start.get_truecolor()\n            triplet2 = end.get_truecolor()\n\n            # Interpolate each RGB component\n            r = int(triplet1.red + (triplet2.red - triplet1.red) * t)\n            g = int(triplet1.green + (triplet2.green - triplet1.green) * t)\n            b = int(triplet1.blue + (triplet2.blue - triplet1.blue) * t)\n\n            result.append(Color.from_rgb(r, g, b))\n\n        return result\n\n    def apply_gradient(self) -&gt; None:\n        \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n        # Generate a color for each character\n        colors = self.interpolate_colors()\n        # Apply a style span for each character with its corresponding color\n        for index, color in enumerate(colors):\n            # Build a style with the interpolated color\n            span_style = Style(color=color)\n            # Stylize the single character range\n            self.stylize(span_style, index, index + 1)\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of colors in the gradient.</p>"},{"location":"text_ref/#rich_gradient.text.Text.__init__","title":"<code>__init__(text='', colors=None, *, rainbow=False, hues=5, style='', justify='default', overflow='fold', no_wrap=False, end='\\n', tab_size=4, markup=True)</code>","text":"<p>Initialize the Text with gradient colors and styles. Args:     text (TextType): The text content.     colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.     rainbow (bool): If True, generate a rainbow spectrum.     hues (int): The number of hues to generate if colors are not provided.     style (StyleType): The style of the text.     justify (JustifyMethod): Justification method for the text.     overflow (OverflowMethod): Overflow method for the text.     no_wrap (bool): If True, disable wrapping of the text.     markup (bool): If True, parse Rich markup tags in the input text.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def __init__(\n    self,\n    text: TextType = \"\",\n    colors: Optional[Sequence[ColorInputType]] = None,\n    *,\n    rainbow: bool = False,\n    hues: int = 5,\n    style: StyleType = \"\",\n    justify: JustifyMethod = \"default\",\n    overflow: OverflowMethod = \"fold\",\n    no_wrap: bool = False,\n    end: str = \"\\n\",\n    tab_size: int = 4,\n    markup: bool = True,\n):\n    \"\"\"Initialize the Text with gradient colors and styles.\n    Args:\n        text (TextType): The text content.\n        colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n        rainbow (bool): If True, generate a rainbow spectrum.\n        hues (int): The number of hues to generate if colors are not provided.\n        style (StyleType): The style of the text.\n        justify (JustifyMethod): Justification method for the text.\n        overflow (OverflowMethod): Overflow method for the text.\n        no_wrap (bool): If True, disable wrapping of the text.\n        markup (bool): If True, parse Rich markup tags in the input text.\n    \"\"\"\n    # Extract out complex expressions for clarity\n    parsed_text = RichText.from_markup(\n        text=str(text), style=style, justify=justify, overflow=overflow\n    )\n    plain = parsed_text.plain\n    parsed_justify = parsed_text.justify\n    parsed_overflow = parsed_text.overflow\n    parsed_spans = parsed_text._spans\n\n    super().__init__(\n        plain,\n        justify=parsed_justify,\n        overflow=parsed_overflow,\n        no_wrap=no_wrap,\n        end=end,\n        tab_size=tab_size,\n        spans=parsed_spans,\n    )\n    self.colors = self.parse_colors(colors, hues, rainbow)\n    # Handle the single color case: apply style directly and return early\n    if len(self.colors) == 1:\n        # Apply the single color style directly\n        style_with_color = Style(color=self.colors[0]) + Style.parse(style)\n        for index in range(len(self.plain)):\n            self.stylize(style_with_color, index, index + 1)\n        return\n    # Apply the gradient coloring\n    self.apply_gradient()\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.apply_gradient","title":"<code>apply_gradient()</code>","text":"<p>Apply interpolated colors as spans to each character in the text.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def apply_gradient(self) -&gt; None:\n    \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n    # Generate a color for each character\n    colors = self.interpolate_colors()\n    # Apply a style span for each character with its corresponding color\n    for index, color in enumerate(colors):\n        # Build a style with the interpolated color\n        span_style = Style(color=color)\n        # Stylize the single character range\n        self.stylize(span_style, index, index + 1)\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.interpolate_colors","title":"<code>interpolate_colors()</code>","text":"<p>Interpolate colors in the gradient.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def interpolate_colors(self) -&gt; List[Color]:\n    \"\"\"Interpolate colors in the gradient.\"\"\"\n    if not self.colors:\n        raise ValueError(\"No colors to interpolate\")\n    # Prepare the text and handle edge cases\n    text = self.plain\n    length = len(text)\n    if length == 0:\n        return []\n    num_colors = len(self.colors)\n    if num_colors == 1:\n        return [self.colors[0]] * length\n\n    # Compute number of segments between colors\n    segments = num_colors - 1\n    result: List[Color] = []\n\n    # For each character, determine its position and blend accordingly\n    for i in range(length):\n        # Normalized position along the entire text\n        pos = i / (length - 1) if length &gt; 1 else 0.0\n        # Determine which two colors to blend between\n        float_index = pos * segments\n        index = int(float_index)\n        # Clamp to valid segment range\n        if index &gt;= segments:\n            index = segments - 1\n            t = 1.0\n        else:\n            t = float_index - index\n\n        start = self.colors[index]\n        end = self.colors[index + 1]\n        triplet1 = start.get_truecolor()\n        triplet2 = end.get_truecolor()\n\n        # Interpolate each RGB component\n        r = int(triplet1.red + (triplet2.red - triplet1.red) * t)\n        g = int(triplet1.green + (triplet2.green - triplet1.green) * t)\n        b = int(triplet1.blue + (triplet2.blue - triplet1.blue) * t)\n\n        result.append(Color.from_rgb(r, g, b))\n\n    return result\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.parse_colors","title":"<code>parse_colors(colors=None, hues=5, rainbow=False)</code>  <code>staticmethod</code>","text":"<p>Parse and return a list of colors for the gradient. Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects. Args:     colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color instances or strings.     hues (int): The number of hues to generate if colors are not provided.     rainbow (bool): If True, generate a rainbow spectrum. Returns:     List[Color]: A list of Color objects.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>@staticmethod\ndef parse_colors(\n    colors: Optional[Sequence[ColorInputType]] = None,\n    hues: int = 5,\n    rainbow: bool = False,\n) -&gt; List[Color]:\n    \"\"\"Parse and return a list of colors for the gradient.\n    Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n    Args:\n        colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color instances or strings.\n        hues (int): The number of hues to generate if colors are not provided.\n        rainbow (bool): If True, generate a rainbow spectrum.\n    Returns:\n        List[Color]: A list of Color objects.\n    \"\"\"\n    if rainbow:\n        return Spectrum(hues=18).colors\n    if colors is None or len(colors) == 0:\n        return Spectrum(hues).colors\n    # Support 3-digit hex colors and all string representations via Color.parse\n    return [c if isinstance(c, Color) else Color.parse(c) for c in colors]\n</code></pre>"}]}