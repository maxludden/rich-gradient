{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>This library is a wrapper of the great rich library that extends rich.text.Text to allow for the easy generation gradient text from either user entered colors or randomly if no colors are entered.</p> <p>Borrowing from pydantic-extra-types' Color class, rich_gradient extends the rich standard colors to include:</p> <ul> <li>3 or 6 digit hex code (e.g. <code>#f00</code> or <code>#ff0000</code>)</li> <li>RGB color codes (e.g. <code>rgb(255, 0, 0)</code>)</li> <li>RGB tuples   (e.g. <code>(255, 0, 0)</code>)</li> <li>CSS3 Color Names (e.g. <code>red</code>)</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#rye-recommended","title":"Rye (Recommended)","text":"<pre><code>rye add rich-gradient\n</code></pre>"},{"location":"#pip","title":"Pip","text":"<pre><code>pip install rich-gradient\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#basic-gradient-example","title":"Basic Gradient Example","text":"<p>To print a simple gradient just substitue the <code>Gradient</code> class for the <code>Text</code> class in the rich library.</p> <pre><code>from rich.console import Console\nfrom rich_gradient import Gradient\n\nconsole = Console()\nconsole.print(Gradient(\"Hello, World!\")\n</code></pre> <p></p>"},{"location":"#gradient-with-specific-colors","title":"Gradient with Specific Colors","text":"<p>If you want a bit more control of the gradient, you can specify the colors you want to use in the gradient by passing them as a list of colors to the <code>colors</code> parameter.</p>"},{"location":"#color-formats","title":"Color Formats","text":"<p>Color can be parsed from a variety of formats including:</p> <p></p>"},{"location":"#example-code","title":"Example Code","text":"<pre><code>console.print(\n    Gradient(\n        \"This a gradient with specific colors.\",\n        colors=[\"red\", \"#ff9900\", \"#ff0\", \"Lime\"],\n        justify=\"center\"\n    )\n)\n</code></pre>"},{"location":"#specific-color-gradient-result","title":"Specific Color Gradient Result","text":""},{"location":"#rainbow-gradient-example","title":"Rainbow Gradient Example","text":"<p>If four colors isn't enough, you can use the 'rainbow' parameter to generate a rainbow gradient that spans the entire spectrum of colors randomly.</p> <pre><code>console.print(\n    Gradient(\n        \"This is a rainbow gradient.\",\n        rainbow=True,\n        justify=\"center\"\n    )\n)\n</code></pre> <p></p> <p>*The rainbow gradient is generated randomly each time the code is run.</p>"},{"location":"#still-inherits-from-richtexttext","title":"Still inherits from <code>rich.text.Text</code>","text":"<p>Since <code>Gradient</code> is a subclass of <code>Text</code>, you can still use all the same methods and properties as you would with <code>Text</code>.</p> <pre><code>console.print(\n    Gradient(\n        \"This is an underlined rainbow gradient.\",\n        rainbow=True,\n        style=\"underline\"\n    ),\n    justify=\"center\"\n)\nconsole.line()\nconsole.print(\n    Gradient(\n        \"This is a bold italic gradient.\",\n        style=\"bold italic\"\n    ),\n    justify=\"center\"\n)\nconsole.line()\n</code></pre> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#v017-2024-7-16-added-support-for-two-color-gradients","title":"v0.1.7 - 2024-7-16 | Added support for Two-Color Gradients","text":""},{"location":"CHANGELOG/#v017-updated","title":"v0.1.7 Updated","text":"<ul> <li>Updated Gradient.generate_subgradients() to default to returning a list containing a single simple gradient to allow Gradients to work when only supplied with two colors.</li> </ul>"},{"location":"CHANGELOG/#v017-added","title":"v0.1.7 Added","text":"<ul> <li>Added len, int, str, and repr dunder methods to <code>rich-gradient.gradient.Gradient</code> (will simply refer to as <code>Gradient</code> from here on out).</li> <li>Added a tests/test_gradient.py for Gradient to test two color gradiets</li> </ul>"},{"location":"CHANGELOG/#v016-2024-6-28-updated-rev","title":"v0.1.6 - 2024-6-28 | Updated Rev","text":"<ul> <li>Updated rev to 0.1.6.</li> </ul>"},{"location":"CHANGELOG/#v015-2024-6-28-added-tests","title":"v0.1.5 - 2024-6-28 | Added Tests","text":""},{"location":"CHANGELOG/#v015-updated","title":"v0.1.5 Updated","text":"<ul> <li>Updated requirements for minimum versions of python from 3.8 -&gt; 3.10.</li> <li>Added <code>pytest</code> to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v015-added","title":"v0.1.5 Added","text":"<ul> <li>Tests for:</li> <li>Color</li> <li>Specturm</li> <li>SimpleGradient</li> </ul>"},{"location":"CHANGELOG/#v014-2024-6-28-resolved-dependancies","title":"v0.1.4 | 2024-6-28 | Resolved Dependancies","text":""},{"location":"CHANGELOG/#v014-updated","title":"v0.1.4 Updated","text":"<ul> <li>This release is primarily to prune unnecessary dependancies.</li> <li>Removed <code>numpy</code> to avoid issues of <code>numpy</code> version 2.0.0 conflicting with <code>torch</code>.</li> </ul>"},{"location":"CHANGELOG/#v013-2021-10-10","title":"v0.1.3 - 2021-10-10","text":""},{"location":"CHANGELOG/#v013-fixed","title":"v0.1.3 Fixed","text":"<ul> <li>Updated README to use GitHub pages for example gradient image.</li> </ul>"},{"location":"CHANGELOG/#v012-2021-10-10","title":"v0.1.2 - 2021-10-10","text":""},{"location":"CHANGELOG/#v012-updated","title":"v0.1.2 Updated","text":"<ul> <li>Updated PyProject.toml description.</li> <li>Moved MKDocs and related dependancies to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v012-fixed","title":"v0.1.2 Fixed","text":"<ul> <li>Updated README to use GitHub pages for banner image.</li> <li>Updated README to use GitHub pages for docs url.</li> </ul>"},{"location":"CHANGELOG/#v011-2021-10-10","title":"v0.1.1 - 2021-10-10","text":""},{"location":"CHANGELOG/#v011-fixed","title":"v0.1.1 Fixed","text":"<ul> <li>Updated README to use GitHub pages for images.</li> </ul>"},{"location":"CHANGELOG/#v010-2021-10-10","title":"v0.1.0 - 2021-10-10","text":"<p>Initial release. Based off of MaxGradient with a simplified color model based on pydantic-extra-types.color.Color. Re-released as rich-gradient to avoid confusion with MaxGradient.</p>"},{"location":"color/","title":"Color","text":"<p><code>rich-gradient</code>'s Color class is a subclass of <code>pydantic_extra_types.color.Color</code> that extends the rich standard colors to include:</p> <ul> <li>3 digit hex codes (e.g. <code>#f00</code>)</li> <li>6 digit hex codes (e.g. <code>#ff0000</code>)</li> <li>RGB color codes (e.g. <code>rgb(255, 0, 0)</code>)</li> <li>RGB tuples (e.g. <code>(255, 0, 0)</code>)</li> <li>CSS3 Color Names (e.g. <code>red</code>)</li> </ul> <p></p>"},{"location":"color_ref/","title":"Color","text":"<p>               Bases: <code>Color</code></p> <p>A color from which to generate a gradient.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>class Color(PyColor):\n    \"\"\"A color from which to generate a gradient.\"\"\"\n\n    def __init__(self, value: PyColorType) -&gt; None:\n        \"\"\"Initialize a color.\n\n        Args:\n            value (pydantic_extra_types.color.ColorType): The color value.\n        \"\"\"\n        try:\n            if value in self.COLORS_BY_NAME:\n                value = self.COLORS_BY_NAME[str(value)]\n        except PydanticCustomError:\n            raise ColorParsingError(f\"Unable to parse color: {value}\")\n        super().__init__(value)\n\n    def as_rich(self) -&gt; RichColor:\n        \"\"\"Convert the color to a rich color.\n\n        Returns:\n            RichColor: The color as a rich color.\n\n        Raises:\n            ColorParsingError: If the color cannot be parsed\n        \"\"\"\n        try:\n            hex = self.as_hex(format=\"long\")\n            return RichColor.parse(hex)\n        except PydanticCustomError:\n            raise ColorParsingError(f\"Unable to parse color: {self}\")\n\n    @property\n    def rich(self) -&gt; RichColor:\n        \"\"\"The color as a rich color.\n\n        Returns:\n            RichColor: The color as a rich color.\n        \"\"\"\n        return self.as_rich()  # type: ignore\n\n    def __rich__(self) -&gt; Text:\n        \"\"\"Return a rich text representation of the color.\n\n        Returns:\n            Text: The rich text representation of the color.\"\"\"\n        return Text.assemble(\n            *[\n                Text(\"Color\", style=\"bold #ffffff\"),\n                Text(\"(\", style=\"bold #ffffff\"),\n                Text(f\"{self.as_named()}\", style=f\"bold {self.as_hex}\"),\n                Text(\")\", style=\"bold #ffffff\"),\n            ]\n        )\n\n    @property\n    def style(self) -&gt; Style:\n        \"\"\"The color as a rich style.\n\n        Returns:\n            Style: The color as a rich style.\"\"\"\n        return self.as_style()\n\n    def as_style(\n        self,\n        bgcolor: Optional[RichColor] = None,\n        bold: Optional[bool] = None,\n        dim: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        underline: Optional[bool] = None,\n        blink: Optional[bool] = None,\n        blink2: Optional[bool] = None,\n        reverse: Optional[bool] = None,\n        conceal: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        underline2: Optional[bool] = None,\n        frame: Optional[bool] = None,\n        encircle: Optional[bool] = None,\n        overline: Optional[bool] = None,\n        link: Optional[str] = None,\n        meta: Optional[Dict[str, Any]] = None,\n    ) -&gt; Style:\n        \"\"\"\n                A terminal style.\n\n        A terminal style consists of the color (color), a background color (bgcolor), and a number of attributes, such\n        as bold, italic etc. The attributes have 3 states: they can either be on (True), off (False), or not set (None).\n\n        Args:\n            bgcolor (RichColor, optional): Background color. Defaults to None.\n            bold (bool, optional): Enable bold text. Defaults to None.\n            dim (bool, optional): Enable dim text. Defaults to None.\n            italic (bool, optional): Enable italic text. Defaults to None.\n            underline (bool, optional): Enable underlined text. Defaults to None.\n            blink (bool, optional): Enabled blinking text. Defaults to None.\n            blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n            reverse (bool, optional): Enabled reverse text. Defaults to None.\n            conceal (bool, optional): Enable concealed text. Defaults to None.\n            strike (bool, optional): Enable strikethrough text. Defaults to None.\n            underline2 (bool, optional): Enable doubly underlined text. Defaults to None.\n            frame (bool, optional): Enable framed text. Defaults to None.\n            encircle (bool, optional): Enable encircled text. Defaults to None.\n            overline (bool, optional): Enable overlined text. Defaults to None.\n            link (str, link): Link URL. Defaults to None.\n\n        Returns:\n            rich.style.Style: A rich.style.Style with the foreground set to the color.\n        \"\"\"\n\n        return Style(\n            color=self.rich,\n            bgcolor=bgcolor,\n            bold=bold,\n            dim=dim,\n            italic=italic,\n            underline=underline,\n            blink=blink,\n            blink2=blink2,\n            reverse=reverse,\n            conceal=conceal,\n            strike=strike,\n            underline2=underline2,\n            frame=frame,\n            encircle=encircle,\n            overline=overline,\n            link=link,\n            meta=meta,\n        )\n\n    @property\n    def bg_style(self) -&gt; Style:\n        \"\"\"The color as a background style.\n\n        Returns:\n            Style: The color as a background style.\n        \"\"\"\n        return self.as_bg_style()\n\n    def as_bg_style(\n        self,\n        color: Optional[RichColor] = None,\n        bold: Optional[bool] = True,\n        dim: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        underline: Optional[bool] = None,\n        blink: Optional[bool] = None,\n        blink2: Optional[bool] = None,\n        reverse: Optional[bool] = None,\n        conceal: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        underline2: Optional[bool] = None,\n        frame: Optional[bool] = None,\n        encircle: Optional[bool] = None,\n        overline: Optional[bool] = None,\n        link: Optional[str] = None,\n        meta: Optional[Dict[str, Any]] = None,\n    ) -&gt; Style:\n        \"\"\"\n                A terminal style.\n\n        A terminal style consists of the color (color), a background color (bgcolor), and a number of attributes, such\n        as bold, italic etc. The attributes have 3 states: they can either be on (True), off (False), or not set (None).\n\n        Args:\n            color (RichColor, optional): Foreground color. Defaults to None, which will generate a foreground color based on the contrast ratio.\n            bold (bool, optional): Enable bold text. Defaults to True.\n            dim (bool, optional): Enable dim text. Defaults to None.\n            italic (bool, optional): Enable italic text. Defaults to None.\n            underline (bool, optional): Enable underlined text. Defaults to None.\n            blink (bool, optional): Enabled blinking text. Defaults to None.\n            blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n            reverse (bool, optional): Enabled reverse text. Defaults to None.\n            conceal (bool, optional): Enable concealed text. Defaults to None.\n            strike (bool, optional): Enable strikethrough text. Defaults to None.\n            underline2 (bool, optional): Enable doubly underlined text. Defaults to None.\n            frame (bool, optional): Enable framed text. Defaults to None.\n            encircle (bool, optional): Enable encircled text. Defaults to None.\n            overline (bool, optional): Enable overlined text. Defaults to None.\n            link (str, link): Link URL. Defaults to None.\n\n        Returns:\n            Style: The style.\n        \"\"\"\n        if color is None:\n            color = self.get_contrast()\n        return Style(\n            color=color,\n            bgcolor=self.rich,\n            bold=bold,\n            dim=dim,\n            italic=italic,\n            underline=underline,\n            blink=blink,\n            blink2=blink2,\n            reverse=reverse,\n            conceal=conceal,\n            strike=strike,\n            underline2=underline2,\n            frame=frame,\n            encircle=encircle,\n            overline=overline,\n            link=link,\n            meta=meta,\n        )\n\n    @property\n    def hex(self) -&gt; str:\n        \"\"\"Return the hex value of the color.\n\n        Returns:\n            str: The hex value of the color.\n        \"\"\"\n        return self.as_hex(\"long\")\n\n    @property\n    def rgb(self) -&gt; str:\n        \"\"\"Return the RGB value of the color.\n\n        Returns:\n            str: The RGB value of the color.\"\"\"\n        return self.as_rgb()\n\n    @property\n    def triplet(self) -&gt; ColorTriplet:\n        \"\"\"The `rich.color_triplet.ColorTriplet` respresentation of the color.\"\"\"\n        return self.as_triplet()\n\n    def as_triplet(self) -&gt; ColorTriplet:\n        \"\"\"Convert the color to a `rich.color_triplet.ColorTriplet`.\n\n        Returns:\n            ColorTriplet: The color as a color triplet.\n        \"\"\"\n        red = int(self._rgba.r * 255)\n        green = int(self._rgba.g * 255)\n        blue = int(self._rgba.b * 255)\n        return ColorTriplet(red, green, blue)\n\n    def get_contrast(self) -&gt; RichColor:\n        \"\"\"Generate a foreground color for the color style.\n\n        Generate a foreground color for the color style based on the color's\n        contrast ratio. If the color is dark, the foreground color will be\n        white. If the color is light, the foreground color will be black.\n\n        Returns:\n            str: The foreground color.\n        \"\"\"\n        import colorsys\n\n        def rgb_to_hsv(color: Color) -&gt; Tuple[float, float, float]:\n            \"\"\"Convert an RGB color to HSV.\n\n            Args:\n                color (Color): The color to convert.\n\n            Returns:\n                Tuple[float, float, float]: The HSV values.\n            \"\"\"\n            rgba: RGBA = color._rgba\n            h, s, v = colorsys.rgb_to_hsv(r=rgba.r, g=rgba.g, b=rgba.b)\n            return h, s, v\n\n        def hsv_to_hsl(hue, saturation, value) -&gt; Tuple[float, float, float]:\n            \"\"\"Convert an HSV color to HSL.\n\n            Args:\n                hue (float): The hue value.\n                saturation (float): The saturation value.\n                value (float): The value value.\n\n            Returns:\n                Tuple[float, float, float]: The HSL values.\n            \"\"\"\n            lightness = (\n                (2 - saturation) * value / 2\n                if value &lt;= 0.5\n                else saturation * value / (2 - saturation)\n            )\n            saturation = (\n                0\n                if lightness == 0 or lightness == 1\n                else (value - lightness) / min(lightness, 1 - lightness)\n            )\n            return hue, saturation, lightness\n\n        def color_distance(color1: Color, color2: Color) -&gt; float:\n            \"\"\"Calculate the distance between two colors.\n\n            Args:\n                color1 (Color): The first color.\n                color2 (Color): The second color.\n\n            Returns:\n                float: The distance between the two colors.\n            \"\"\"\n            h1, s1, v1 = rgb_to_hsv(color1)\n            h2, s2, v2 = rgb_to_hsv(color2)\n            dh: float = min(abs(h1 - h2), 1 - abs(h1 - h2))\n            ds: float = abs(s1 - s2)\n            dv: float = abs(v1 - v2)\n            color_distance: float = dh + ds + dv\n            return color_distance\n\n        def find_closest_color(color1: Color, color_list: List[Color]) -&gt; Color:\n            \"\"\"Calculate the closest color in a list.\n\n            Args:\n                color1 (Color): The color to compare.\n                color_list (List[Color]): The list of colors to compare against.\n\n            Returns:\n                Color: The closest color.\n            \"\"\"\n            closest_color = None\n            min_distance = float(\"inf\")\n            for color in color_list:\n                distance = color_distance(color1, color)\n                if distance &lt; min_distance:\n                    min_distance = distance\n                    closest_color = color\n            assert closest_color is not None, \"No closest color found.\"\n            return closest_color\n\n        color_list: List[Color] = [Color(\"#000000\"), Color(\"#ffffff\")]\n        closest = find_closest_color(\n            self,\n            color_list=color_list,\n        )\n        if closest == Color(\"#000000\"):\n            return Color(\"#ffffff\").rich\n        else:\n            return Color(\"#000000\").rich\n\n    @classmethod\n    def colortitle(cls, title: str) -&gt; Text:\n        \"\"\"Manually color a title.\n\n        Args:\n            title (str): The title to style.\n\n        Returns:\n            Text: The styled title.\n        \"\"\"\n        title_list: List[str] = list(title)\n        length = len(title)\n        COLORS = cycle(\n            [\n                \"#FF00FF\",\n                \"#AF00FF\",\n                \"#5F00FF\",\n                \"#0000FF\",\n                \"#0055FF\",\n                \"#0080FF\",\n                \"#00C0FF\",\n                \"#00FFFF\",\n                \"#00FFAF\",\n                \"#00FF00\",\n                \"#AFFF00\",\n                \"#FFFF00\",\n                \"#FFAF00\",\n                \"#FF8700\",\n                \"#FF4B00\",\n                \"#FF0000\",\n                \"#FF005F\",\n            ]\n        )\n        color_title = Text()\n        # randomize\n        for _ in range(randint(0, 16)):\n            next(COLORS)\n        for index in range(length):\n            char: str = title_list[index]\n            color: str = next(COLORS)\n            color_title.append(Text(char, style=f\"bold {color}\"))\n        return color_title\n\n    @classmethod\n    def generate_table(\n        cls, title: str, show_index: bool = True, caption: Optional[Text] = None\n    ) -&gt; Table:\n        \"\"\"\n        Generate a table to display colors.\n\n        Args:\n            title: The title for the table.\n            show_index: Whether to show the index column.\n\n        Returns:\n            A `rich.table.Table` instance.\n        \"\"\"\n        color_title = cls.colortitle(title)\n        table = Table(\n            title=color_title, expand=False, caption=caption, caption_justify=\"right\"\n        )\n        if show_index:\n            table.add_column(cls.colortitle(\"Index\"), style=\"bold\", justify=\"right\")\n        table.add_column(cls.colortitle(\"Sample\"), style=\"bold\", justify=\"center\")\n        table.add_column(cls.colortitle(\"Name\"), style=\"bold\", justify=\"left\")\n        table.add_column(cls.colortitle(\"Hex\"), style=\"bold\", justify=\"left\")\n        table.add_column(cls.colortitle(\"RGB\"), style=\"bold\", justify=\"left\")\n        return table\n\n    @classmethod\n    def color_table(\n        cls,\n        title: str,\n        start: int,\n        end: int,\n        caption: Optional[Text] = None,\n        *,\n        show_index: bool = False,\n    ) -&gt; Table:\n        \"\"\"Generate a table of colors.\n\n        Args:\n            title (str): The title of the color table.\n            start (int): The starting index.\n            end (int): The ending index.\n            caption (Optional[Text], optional): The caption of the color table. Defaults to None.\n            show_index (bool, optional): Whether to show the index of the color. Defaults to False.\n\n        Returns:\n            Table: The color table.\n        \"\"\"\n        table = cls.generate_table(title, show_index, caption)\n        for index, (key, _) in enumerate(cls.COLORS_BY_NAME.items()):\n            if index &lt; start:\n                continue\n            elif index &gt; end:\n                break\n            color = Color(key)\n\n            color_index = Text(f\"{index: &gt;3}\", style=color.as_style(bold=True))\n            style = color.as_style(bold=True)\n            sample = Text(f\"{'\u2588' * 10}\", style=style)\n            name = Text(f\"{key.capitalize(): &lt;20}\", style=style)\n            hex_str = f\" {color.as_hex('long').upper()} \"\n            hex = Text(f\"{hex_str: ^7}\", style=color.as_bg_style())\n            r, g, b = color._rgba.r, color._rgba.g, color._rgba.b\n            r_int = int(r * 255)\n            g_int = int(g * 255)\n            b_int = int(b * 255)\n            rgb = Text.assemble(\n                *[\n                    Text(\"rgb\", style=color.as_style(bold=True)),\n                    Text(\"(\", style=\"b #ffffff\"),\n                    Text(f\"{r_int: &gt;3}\", style=\"b #ff0000\"),\n                    Text(\",\", style=\"b #ffffff\"),\n                    Text(f\"{g_int: &gt;3}\", style=\"b #00ff00\"),\n                    Text(\",\", style=\"b #ffffff\"),\n                    Text(f\"{b_int: &gt;3}\", style=\"b #0099ff\"),\n                    Text(\")\", style=\"b #ffffff\"),\n                ]\n            )\n            if show_index:\n                table.add_row(color_index, sample, name, hex, rgb)\n            else:\n                table.add_row(sample, name, hex, rgb)\n        return table\n\n    @classmethod\n    def example(cls, record: bool = False) -&gt; None:\n        \"\"\"Generate a example of the color class.\n\n        Args:\n            record (bool): Whether to record the example as an svg.\n        \"\"\"\n\n\n        from rich_gradient.theme import GRADIENT_TERMINAL_THEME\n        console = Console(record=True, width=80) if record else Console()\n\n        def table_generator() -&gt; Generator:\n            \"\"\"Generate the tables for the example.\"\"\"\n            tables: List[Tuple[str, int, int, Optional[Text]]] = [\n                (\n                    \"Gradient Colors\",\n                    0,\n                    17,\n                    Text(\n                        \"These colors have been adapted to make naming easier.\",\n                        style=\"i d #ffffff\",\n                    ),\n                ),\n                (\"CSS3 Colors\", 18, 147, None),\n                (\"Rich Colors\", 148, 342, None),\n            ]\n            for table in tables:\n                yield table\n\n        for title, start, end, caption in table_generator():\n            console.line(2)\n            table = cls.color_table(title, start, end, caption=caption)\n            console.print(table, justify=\"center\")\n            console.line(2)\n\n        if record:\n            try:\n                console.save_svg(\n                    \"docs/img/colors.svg\",\n                    theme=GRADIENT_TERMINAL_THEME,\n                    title=\"Colors\"\n                    )\n            except TypeError:\n                pass\n\n    COLORS_BY_NAME: Dict[str, Tuple[int, int, int]] = {\n        \"magenta\": (255, 0, 255),\n        \"purple\": (175, 0, 255),\n        \"violet\": (95, 0, 255),\n        \"blue\": (0, 0, 255),\n        \"dodgerblue\": (0, 85, 255),\n        \"deepskyblue\": (0, 135, 255),\n        \"lightskyblue\": (0, 195, 255),\n        \"cyan\": (0, 255, 255),\n        \"springgreen\": (0, 255, 175),\n        \"lime\": (0, 255, 0),\n        \"greenyellow\": (175, 255, 0),\n        \"yellow\": (255, 255, 0),\n        \"orange\": (255, 175, 0),\n        \"darkorange\": (255, 135, 0),\n        \"tomato\": (255, 75, 0),\n        \"red\": (255, 0, 0),\n        \"deeppink\": (255, 0, 95),\n        \"hotpink\": (255, 0, 175),\n        \"aliceblue\": (240, 248, 255),\n        \"antiquewhite\": (250, 235, 215),\n        \"aquamarine\": (127, 255, 212),\n        \"azure\": (240, 255, 255),\n        \"beige\": (245, 245, 220),\n        \"bisque\": (255, 228, 196),\n        \"black\": (0, 0, 0),\n        \"blanchedalmond\": (255, 235, 205),\n        \"brown\": (165, 42, 42),\n        \"burlywood\": (222, 184, 135),\n        \"cadetblue\": (95, 158, 160),\n        \"chartreuse\": (127, 255, 0),\n        \"chocolate\": (210, 105, 30),\n        \"coral\": (255, 127, 80),\n        \"cornflowerblue\": (100, 149, 237),\n        \"cornsilk\": (255, 248, 220),\n        \"crimson\": (220, 20, 60),\n        \"darkblue\": (0, 0, 139),\n        \"darkcyan\": (0, 139, 139),\n        \"darkgoldenrod\": (184, 134, 11),\n        \"darkgray\": (169, 169, 169),\n        \"darkgreen\": (0, 100, 0),\n        \"darkgrey\": (169, 169, 169),\n        \"darkkhaki\": (189, 183, 107),\n        \"darkmagenta\": (139, 0, 139),\n        \"darkolivegreen\": (85, 107, 47),\n        # \"cssdarkorange\": (255, 140, 0),\n        \"darkorchid\": (153, 50, 204),\n        \"darkred\": (139, 0, 0),\n        \"darksalmon\": (233, 150, 122),\n        \"darkseagreen\": (143, 188, 143),\n        \"darkslateblue\": (72, 61, 139),\n        \"darkslategray\": (47, 79, 79),\n        \"darkslategrey\": (47, 79, 79),\n        \"darkturquoise\": (0, 206, 209),\n        \"darkviolet\": (148, 0, 211),\n        # \"deepskyblue_css\": (0, 191, 255),\n        \"dimgray\": (105, 105, 105),\n        \"dimgrey\": (105, 105, 105),\n        # \"dodgerblue_css\": (30, 144, 255),\n        \"firebrick\": (178, 34, 34),\n        \"floralwhite\": (255, 250, 240),\n        \"forestgreen\": (34, 139, 34),\n        \"gainsboro\": (220, 220, 220),\n        \"ghostwhite\": (248, 248, 255),\n        \"gold\": (255, 215, 0),\n        \"goldenrod\": (218, 165, 32),\n        \"gray\": (128, 128, 128),\n        \"green\": (0, 128, 0),\n        # \"greenyellow_css\": (173, 255, 47),\n        \"grey\": (128, 128, 128),\n        \"honeydew\": (240, 255, 240),\n        # \"hotpink_css\": (255, 105, 180),\n        \"indianred\": (205, 92, 92),\n        \"indigo\": (75, 0, 130),\n        \"ivory\": (255, 255, 240),\n        \"khaki\": (240, 230, 140),\n        \"lavender\": (230, 230, 250),\n        \"lavenderblush\": (255, 240, 245),\n        \"lawngreen\": (124, 252, 0),\n        \"lemonchiffon\": (255, 250, 205),\n        \"lightblue\": (173, 216, 230),\n        \"lightcoral\": (240, 128, 128),\n        \"lightcyan\": (224, 255, 255),\n        \"lightgoldenrodyellow\": (250, 250, 210),\n        \"lightgray\": (211, 211, 211),\n        \"lightgreen\": (144, 238, 144),\n        \"lightgrey\": (211, 211, 211),\n        \"lightpink\": (255, 182, 193),\n        \"lightsalmon\": (255, 160, 122),\n        \"lightseagreen\": (32, 178, 170),\n        # \"lightskyblue_css\": (135, 206, 250),\n        \"lightslategray\": (119, 136, 153),\n        \"lightslategrey\": (119, 136, 153),\n        \"lightsteelblue\": (176, 196, 222),\n        \"lightyellow\": (255, 255, 224),\n        \"limegreen\": (50, 205, 50),\n        \"linen\": (250, 240, 230),\n        \"maroon\": (128, 0, 0),\n        \"mediumaquamarine\": (102, 205, 170),\n        \"mediumblue\": (0, 0, 205),\n        \"mediumorchid\": (186, 85, 211),\n        \"mediumpurple\": (147, 112, 219),\n        \"mediumseagreen\": (60, 179, 113),\n        \"mediumslateblue\": (123, 104, 238),\n        \"mediumspringgreen\": (0, 250, 154),\n        \"mediumturquoise\": (72, 209, 204),\n        \"mediumvioletred\": (199, 21, 133),\n        \"midnightblue\": (25, 25, 112),\n        \"mintcream\": (245, 255, 250),\n        \"mistyrose\": (255, 228, 225),\n        \"moccasin\": (255, 228, 181),\n        \"navajowhite\": (255, 222, 173),\n        \"navy\": (0, 0, 128),\n        \"oldlace\": (253, 245, 230),\n        \"olive\": (128, 128, 0),\n        \"olivedrab\": (107, 142, 35),\n        \"orchid\": (218, 112, 214),\n        \"palegoldenrod\": (238, 232, 170),\n        \"palegreen\": (152, 251, 152),\n        \"paleturquoise\": (175, 238, 238),\n        \"palevioletred\": (219, 112, 147),\n        \"papayawhip\": (255, 239, 213),\n        \"peachpuff\": (255, 218, 185),\n        \"peru\": (205, 133, 63),\n        \"pink\": (255, 192, 203),\n        \"plum\": (221, 160, 221),\n        \"powderblue\": (176, 224, 230),\n        \"rosybrown\": (188, 143, 143),\n        \"royalblue\": (65, 105, 225),\n        \"saddlebrown\": (139, 69, 19),\n        \"salmon\": (250, 128, 114),\n        \"sandybrown\": (244, 164, 96),\n        \"seagreen\": (46, 139, 87),\n        \"seashell\": (255, 245, 238),\n        \"sienna\": (160, 82, 45),\n        \"silver\": (192, 192, 192),\n        \"slateblue\": (106, 90, 205),\n        \"slategray\": (112, 128, 144),\n        \"slategrey\": (112, 128, 144),\n        \"snow\": (255, 250, 250),\n        \"steelblue\": (70, 130, 180),\n        \"tan\": (210, 180, 140),\n        \"teal\": (0, 128, 128),\n        \"thistle\": (216, 191, 216),\n        # \"csstomato\": (255, 99, 71),\n        \"turquoise\": (64, 224, 208),\n        # \"violet_css\": (238, 130, 238),\n        \"wheat\": (245, 222, 179),\n        \"white\": (255, 255, 255),\n        \"whitesmoke\": (245, 245, 245),\n        \"yellowgreen\": (154, 205, 50),\n        \"bright_black\": (45, 45, 45),\n        \"bright_red\": (210, 0, 0),\n        \"bright_green\": (0, 210, 0),\n        \"bright_yellow\": (210, 210, 0),\n        \"bright_blue\": (0, 0, 210),\n        \"bright_magenta\": (210, 0, 210),\n        \"bright_cyan\": (0, 210, 210),\n        \"bright_white\": (210, 210, 210),\n        \"grey0\": (0, 0, 0),\n        \"navy_blue\": (0, 0, 95),\n        \"dark_blue\": (0, 0, 135),\n        \"blue3\": (0, 0, 215),\n        \"dark_green\": (0, 95, 0),\n        \"deep_sky_blue4\": (0, 95, 175),\n        \"dodger_blue3\": (0, 95, 215),\n        \"green4\": (0, 135, 0),\n        \"spring_green4\": (0, 135, 95),\n        \"turquoise4\": (0, 135, 135),\n        \"deep_sky_blue3\": (0, 135, 215),\n        \"dark_cyan\": (0, 175, 135),\n        \"light_sea_green\": (0, 175, 175),\n        \"deep_sky_blue2\": (0, 175, 215),\n        \"green3\": (0, 215, 0),\n        \"spring_green3\": (0, 215, 95),\n        \"cyan3\": (0, 215, 175),\n        \"dark_turquoise\": (0, 215, 215),\n        \"turquoise2\": (0, 215, 255),\n        \"spring_green2\": (0, 255, 95),\n        \"cyan2\": (0, 255, 215),\n        \"purple4\": (95, 0, 175),\n        \"purple3\": (95, 0, 215),\n        \"grey37\": (95, 95, 95),\n        \"medium_purple4\": (95, 95, 135),\n        \"slate_blue3\": (95, 95, 215),\n        \"royal_blue1\": (95, 95, 255),\n        \"chartreuse4\": (95, 135, 0),\n        \"pale_turquoise4\": (95, 135, 135),\n        \"steel_blue\": (95, 135, 175),\n        \"steel_blue3\": (95, 135, 215),\n        \"cornflower_blue\": (95, 135, 255),\n        \"dark_sea_green4\": (95, 175, 95),\n        \"cadet_blue\": (95, 175, 175),\n        \"sky_blue3\": (95, 175, 215),\n        \"chartreuse3\": (95, 215, 0),\n        \"sea_green3\": (95, 215, 135),\n        \"aquamarine3\": (95, 215, 175),\n        \"medium_turquoise\": (95, 215, 215),\n        \"steel_blue1\": (95, 215, 255),\n        \"sea_green2\": (95, 255, 95),\n        \"sea_green1\": (95, 255, 175),\n        \"dark_slate_gray2\": (95, 255, 255),\n        \"dark_red\": (135, 0, 0),\n        \"dark_magenta\": (135, 0, 175),\n        \"orange4\": (135, 95, 0),\n        \"light_pink4\": (135, 95, 95),\n        \"plum4\": (135, 95, 135),\n        \"medium_purple3\": (135, 95, 215),\n        \"slate_blue1\": (135, 95, 255),\n        \"wheat4\": (135, 135, 95),\n        \"grey53\": (135, 135, 135),\n        \"light_slate_grey\": (135, 135, 175),\n        \"medium_purple\": (135, 135, 215),\n        \"light_slate_blue\": (135, 135, 255),\n        \"yellow4\": (135, 175, 0),\n        \"dark_sea_green\": (135, 175, 135),\n        \"light_sky_blue3\": (135, 175, 215),\n        \"sky_blue2\": (135, 175, 255),\n        \"chartreuse2\": (135, 215, 0),\n        \"pale_green3\": (135, 215, 135),\n        \"dark_slate_gray3\": (135, 215, 215),\n        \"sky_blue1\": (135, 215, 255),\n        \"light_green\": (135, 255, 135),\n        \"aquamarine1\": (135, 255, 215),\n        \"dark_slate_gray1\": (135, 255, 255),\n        \"deep_pink4\": (175, 0, 95),\n        \"medium_violet_red\": (175, 0, 135),\n        \"dark_violet\": (175, 0, 215),\n        \"medium_orchid3\": (175, 95, 175),\n        \"medium_orchid\": (175, 95, 215),\n        \"dark_goldenrod\": (175, 135, 0),\n        \"rosy_brown\": (175, 135, 135),\n        \"grey63\": (175, 135, 175),\n        \"medium_purple2\": (175, 135, 215),\n        \"medium_purple1\": (175, 135, 255),\n        \"dark_khaki\": (175, 175, 95),\n        \"navajo_white3\": (175, 175, 135),\n        \"grey69\": (175, 175, 175),\n        \"light_steel_blue3\": (175, 175, 215),\n        \"light_steel_blue\": (175, 175, 255),\n        \"dark_olive_green3\": (175, 215, 95),\n        \"dark_sea_green3\": (175, 215, 135),\n        \"light_cyan3\": (175, 215, 215),\n        \"light_sky_blue1\": (175, 215, 255),\n        \"dark_olive_green2\": (175, 255, 95),\n        \"pale_green1\": (175, 255, 135),\n        \"dark_sea_green2\": (175, 255, 175),\n        \"pale_turquoise1\": (175, 255, 255),\n        \"red3\": (215, 0, 0),\n        \"deep_pink3\": (215, 0, 135),\n        \"magenta3\": (215, 0, 215),\n        \"dark_orange3\": (215, 95, 0),\n        \"indian_red\": (215, 95, 95),\n        \"hot_pink3\": (215, 95, 135),\n        \"hot_pink2\": (215, 95, 175),\n        \"orange3\": (215, 135, 0),\n        \"light_salmon3\": (215, 135, 95),\n        \"light_pink3\": (215, 135, 135),\n        \"pink3\": (215, 135, 175),\n        \"plum3\": (215, 135, 215),\n        \"gold3\": (215, 175, 0),\n        \"light_goldenrod3\": (215, 175, 95),\n        \"misty_rose3\": (215, 175, 175),\n        \"thistle3\": (215, 175, 215),\n        \"plum2\": (215, 175, 255),\n        \"yellow3\": (215, 215, 0),\n        \"khaki3\": (215, 215, 95),\n        \"light_yellow3\": (215, 215, 175),\n        \"grey84\": (215, 215, 215),\n        \"light_steel_blue1\": (215, 215, 255),\n        \"yellow2\": (215, 255, 0),\n        \"dark_olive_green1\": (215, 255, 135),\n        \"dark_sea_green1\": (215, 255, 175),\n        \"honeydew2\": (215, 255, 215),\n        \"light_cyan1\": (215, 255, 255),\n        \"magenta2\": (255, 0, 215),\n        \"indian_red1\": (255, 95, 135),\n        \"hot_pink\": (255, 95, 215),\n        \"medium_orchid1\": (255, 95, 255),\n        \"dark_orange\": (255, 135, 0),\n        \"salmon1\": (255, 135, 95),\n        \"light_coral\": (255, 135, 135),\n        \"pale_violet_red1\": (255, 135, 175),\n        \"orchid2\": (255, 135, 215),\n        \"orchid1\": (255, 135, 255),\n        \"sandy_brown\": (255, 175, 95),\n        \"light_salmon1\": (255, 175, 135),\n        \"light_pink1\": (255, 175, 175),\n        \"pink1\": (255, 175, 215),\n        \"plum1\": (255, 175, 255),\n        \"gold1\": (255, 215, 0),\n        \"light_goldenrod2\": (255, 215, 135),\n        \"navajo_white1\": (255, 215, 175),\n        \"misty_rose1\": (255, 215, 215),\n        \"thistle1\": (255, 215, 255),\n        \"light_goldenrod1\": (255, 255, 95),\n        \"khaki1\": (255, 255, 135),\n        \"wheat1\": (255, 255, 175),\n        \"cornsilk1\": (255, 255, 215),\n        \"grey100\": (255, 255, 255),\n        \"grey3\": (8, 8, 8),\n        \"grey7\": (18, 18, 18),\n        \"grey11\": (28, 28, 28),\n        \"grey15\": (38, 38, 38),\n        \"grey19\": (48, 48, 48),\n        \"grey23\": (58, 58, 58),\n        \"grey27\": (68, 68, 68),\n        \"grey30\": (78, 78, 78),\n        \"grey35\": (88, 88, 88),\n        \"grey39\": (98, 98, 98),\n        \"grey42\": (108, 108, 108),\n        \"grey46\": (118, 118, 118),\n        \"grey50\": (128, 128, 128),\n        \"grey54\": (138, 138, 138),\n        \"grey58\": (148, 148, 148),\n        \"grey62\": (158, 158, 158),\n        \"grey66\": (168, 168, 168),\n        \"grey70\": (178, 178, 178),\n        \"grey74\": (188, 188, 188),\n        \"grey78\": (198, 198, 198),\n        \"grey82\": (208, 208, 208),\n        \"grey85\": (218, 218, 218),\n        \"grey89\": (228, 228, 228),\n        \"grey93\": (238, 238, 238),\n    }\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.bg_style","title":"<code>bg_style: Style</code>  <code>property</code>","text":"<p>The color as a background style.</p> <p>Returns:</p> Name Type Description <code>Style</code> <code>Style</code> <p>The color as a background style.</p>"},{"location":"color_ref/#rich_gradient.color.Color.hex","title":"<code>hex: str</code>  <code>property</code>","text":"<p>Return the hex value of the color.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hex value of the color.</p>"},{"location":"color_ref/#rich_gradient.color.Color.rgb","title":"<code>rgb: str</code>  <code>property</code>","text":"<p>Return the RGB value of the color.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The RGB value of the color.</p>"},{"location":"color_ref/#rich_gradient.color.Color.rich","title":"<code>rich: RichColor</code>  <code>property</code>","text":"<p>The color as a rich color.</p> <p>Returns:</p> Name Type Description <code>RichColor</code> <code>Color</code> <p>The color as a rich color.</p>"},{"location":"color_ref/#rich_gradient.color.Color.style","title":"<code>style: Style</code>  <code>property</code>","text":"<p>The color as a rich style.</p> <p>Returns:</p> Name Type Description <code>Style</code> <code>Style</code> <p>The color as a rich style.</p>"},{"location":"color_ref/#rich_gradient.color.Color.triplet","title":"<code>triplet: ColorTriplet</code>  <code>property</code>","text":"<p>The <code>rich.color_triplet.ColorTriplet</code> respresentation of the color.</p>"},{"location":"color_ref/#rich_gradient.color.Color.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a color.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ColorType</code> <p>The color value.</p> required Source code in <code>src/rich_gradient/color.py</code> <pre><code>def __init__(self, value: PyColorType) -&gt; None:\n    \"\"\"Initialize a color.\n\n    Args:\n        value (pydantic_extra_types.color.ColorType): The color value.\n    \"\"\"\n    try:\n        if value in self.COLORS_BY_NAME:\n            value = self.COLORS_BY_NAME[str(value)]\n    except PydanticCustomError:\n        raise ColorParsingError(f\"Unable to parse color: {value}\")\n    super().__init__(value)\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.__rich__","title":"<code>__rich__()</code>","text":"<p>Return a rich text representation of the color.</p> <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>The rich text representation of the color.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>def __rich__(self) -&gt; Text:\n    \"\"\"Return a rich text representation of the color.\n\n    Returns:\n        Text: The rich text representation of the color.\"\"\"\n    return Text.assemble(\n        *[\n            Text(\"Color\", style=\"bold #ffffff\"),\n            Text(\"(\", style=\"bold #ffffff\"),\n            Text(f\"{self.as_named()}\", style=f\"bold {self.as_hex}\"),\n            Text(\")\", style=\"bold #ffffff\"),\n        ]\n    )\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.as_bg_style","title":"<code>as_bg_style(color=None, bold=True, dim=None, italic=None, underline=None, blink=None, blink2=None, reverse=None, conceal=None, strike=None, underline2=None, frame=None, encircle=None, overline=None, link=None, meta=None)</code>","text":"<pre><code>    A terminal style.\n</code></pre> <p>A terminal style consists of the color (color), a background color (bgcolor), and a number of attributes, such as bold, italic etc. The attributes have 3 states: they can either be on (True), off (False), or not set (None).</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>Foreground color. Defaults to None, which will generate a foreground color based on the contrast ratio.</p> <code>None</code> <code>bold</code> <code>bool</code> <p>Enable bold text. Defaults to True.</p> <code>True</code> <code>dim</code> <code>bool</code> <p>Enable dim text. Defaults to None.</p> <code>None</code> <code>italic</code> <code>bool</code> <p>Enable italic text. Defaults to None.</p> <code>None</code> <code>underline</code> <code>bool</code> <p>Enable underlined text. Defaults to None.</p> <code>None</code> <code>blink</code> <code>bool</code> <p>Enabled blinking text. Defaults to None.</p> <code>None</code> <code>blink2</code> <code>bool</code> <p>Enable fast blinking text. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Enabled reverse text. Defaults to None.</p> <code>None</code> <code>conceal</code> <code>bool</code> <p>Enable concealed text. Defaults to None.</p> <code>None</code> <code>strike</code> <code>bool</code> <p>Enable strikethrough text. Defaults to None.</p> <code>None</code> <code>underline2</code> <code>bool</code> <p>Enable doubly underlined text. Defaults to None.</p> <code>None</code> <code>frame</code> <code>bool</code> <p>Enable framed text. Defaults to None.</p> <code>None</code> <code>encircle</code> <code>bool</code> <p>Enable encircled text. Defaults to None.</p> <code>None</code> <code>overline</code> <code>bool</code> <p>Enable overlined text. Defaults to None.</p> <code>None</code> <code>link</code> <code>(str, link)</code> <p>Link URL. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Style</code> <code>Style</code> <p>The style.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>def as_bg_style(\n    self,\n    color: Optional[RichColor] = None,\n    bold: Optional[bool] = True,\n    dim: Optional[bool] = None,\n    italic: Optional[bool] = None,\n    underline: Optional[bool] = None,\n    blink: Optional[bool] = None,\n    blink2: Optional[bool] = None,\n    reverse: Optional[bool] = None,\n    conceal: Optional[bool] = None,\n    strike: Optional[bool] = None,\n    underline2: Optional[bool] = None,\n    frame: Optional[bool] = None,\n    encircle: Optional[bool] = None,\n    overline: Optional[bool] = None,\n    link: Optional[str] = None,\n    meta: Optional[Dict[str, Any]] = None,\n) -&gt; Style:\n    \"\"\"\n            A terminal style.\n\n    A terminal style consists of the color (color), a background color (bgcolor), and a number of attributes, such\n    as bold, italic etc. The attributes have 3 states: they can either be on (True), off (False), or not set (None).\n\n    Args:\n        color (RichColor, optional): Foreground color. Defaults to None, which will generate a foreground color based on the contrast ratio.\n        bold (bool, optional): Enable bold text. Defaults to True.\n        dim (bool, optional): Enable dim text. Defaults to None.\n        italic (bool, optional): Enable italic text. Defaults to None.\n        underline (bool, optional): Enable underlined text. Defaults to None.\n        blink (bool, optional): Enabled blinking text. Defaults to None.\n        blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n        reverse (bool, optional): Enabled reverse text. Defaults to None.\n        conceal (bool, optional): Enable concealed text. Defaults to None.\n        strike (bool, optional): Enable strikethrough text. Defaults to None.\n        underline2 (bool, optional): Enable doubly underlined text. Defaults to None.\n        frame (bool, optional): Enable framed text. Defaults to None.\n        encircle (bool, optional): Enable encircled text. Defaults to None.\n        overline (bool, optional): Enable overlined text. Defaults to None.\n        link (str, link): Link URL. Defaults to None.\n\n    Returns:\n        Style: The style.\n    \"\"\"\n    if color is None:\n        color = self.get_contrast()\n    return Style(\n        color=color,\n        bgcolor=self.rich,\n        bold=bold,\n        dim=dim,\n        italic=italic,\n        underline=underline,\n        blink=blink,\n        blink2=blink2,\n        reverse=reverse,\n        conceal=conceal,\n        strike=strike,\n        underline2=underline2,\n        frame=frame,\n        encircle=encircle,\n        overline=overline,\n        link=link,\n        meta=meta,\n    )\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.as_rich","title":"<code>as_rich()</code>","text":"<p>Convert the color to a rich color.</p> <p>Returns:</p> Name Type Description <code>RichColor</code> <code>Color</code> <p>The color as a rich color.</p> <p>Raises:</p> Type Description <code>ColorParsingError</code> <p>If the color cannot be parsed</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>def as_rich(self) -&gt; RichColor:\n    \"\"\"Convert the color to a rich color.\n\n    Returns:\n        RichColor: The color as a rich color.\n\n    Raises:\n        ColorParsingError: If the color cannot be parsed\n    \"\"\"\n    try:\n        hex = self.as_hex(format=\"long\")\n        return RichColor.parse(hex)\n    except PydanticCustomError:\n        raise ColorParsingError(f\"Unable to parse color: {self}\")\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.as_style","title":"<code>as_style(bgcolor=None, bold=None, dim=None, italic=None, underline=None, blink=None, blink2=None, reverse=None, conceal=None, strike=None, underline2=None, frame=None, encircle=None, overline=None, link=None, meta=None)</code>","text":"<pre><code>    A terminal style.\n</code></pre> <p>A terminal style consists of the color (color), a background color (bgcolor), and a number of attributes, such as bold, italic etc. The attributes have 3 states: they can either be on (True), off (False), or not set (None).</p> <p>Parameters:</p> Name Type Description Default <code>bgcolor</code> <code>Color</code> <p>Background color. Defaults to None.</p> <code>None</code> <code>bold</code> <code>bool</code> <p>Enable bold text. Defaults to None.</p> <code>None</code> <code>dim</code> <code>bool</code> <p>Enable dim text. Defaults to None.</p> <code>None</code> <code>italic</code> <code>bool</code> <p>Enable italic text. Defaults to None.</p> <code>None</code> <code>underline</code> <code>bool</code> <p>Enable underlined text. Defaults to None.</p> <code>None</code> <code>blink</code> <code>bool</code> <p>Enabled blinking text. Defaults to None.</p> <code>None</code> <code>blink2</code> <code>bool</code> <p>Enable fast blinking text. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Enabled reverse text. Defaults to None.</p> <code>None</code> <code>conceal</code> <code>bool</code> <p>Enable concealed text. Defaults to None.</p> <code>None</code> <code>strike</code> <code>bool</code> <p>Enable strikethrough text. Defaults to None.</p> <code>None</code> <code>underline2</code> <code>bool</code> <p>Enable doubly underlined text. Defaults to None.</p> <code>None</code> <code>frame</code> <code>bool</code> <p>Enable framed text. Defaults to None.</p> <code>None</code> <code>encircle</code> <code>bool</code> <p>Enable encircled text. Defaults to None.</p> <code>None</code> <code>overline</code> <code>bool</code> <p>Enable overlined text. Defaults to None.</p> <code>None</code> <code>link</code> <code>(str, link)</code> <p>Link URL. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Style</code> <p>rich.style.Style: A rich.style.Style with the foreground set to the color.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>def as_style(\n    self,\n    bgcolor: Optional[RichColor] = None,\n    bold: Optional[bool] = None,\n    dim: Optional[bool] = None,\n    italic: Optional[bool] = None,\n    underline: Optional[bool] = None,\n    blink: Optional[bool] = None,\n    blink2: Optional[bool] = None,\n    reverse: Optional[bool] = None,\n    conceal: Optional[bool] = None,\n    strike: Optional[bool] = None,\n    underline2: Optional[bool] = None,\n    frame: Optional[bool] = None,\n    encircle: Optional[bool] = None,\n    overline: Optional[bool] = None,\n    link: Optional[str] = None,\n    meta: Optional[Dict[str, Any]] = None,\n) -&gt; Style:\n    \"\"\"\n            A terminal style.\n\n    A terminal style consists of the color (color), a background color (bgcolor), and a number of attributes, such\n    as bold, italic etc. The attributes have 3 states: they can either be on (True), off (False), or not set (None).\n\n    Args:\n        bgcolor (RichColor, optional): Background color. Defaults to None.\n        bold (bool, optional): Enable bold text. Defaults to None.\n        dim (bool, optional): Enable dim text. Defaults to None.\n        italic (bool, optional): Enable italic text. Defaults to None.\n        underline (bool, optional): Enable underlined text. Defaults to None.\n        blink (bool, optional): Enabled blinking text. Defaults to None.\n        blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n        reverse (bool, optional): Enabled reverse text. Defaults to None.\n        conceal (bool, optional): Enable concealed text. Defaults to None.\n        strike (bool, optional): Enable strikethrough text. Defaults to None.\n        underline2 (bool, optional): Enable doubly underlined text. Defaults to None.\n        frame (bool, optional): Enable framed text. Defaults to None.\n        encircle (bool, optional): Enable encircled text. Defaults to None.\n        overline (bool, optional): Enable overlined text. Defaults to None.\n        link (str, link): Link URL. Defaults to None.\n\n    Returns:\n        rich.style.Style: A rich.style.Style with the foreground set to the color.\n    \"\"\"\n\n    return Style(\n        color=self.rich,\n        bgcolor=bgcolor,\n        bold=bold,\n        dim=dim,\n        italic=italic,\n        underline=underline,\n        blink=blink,\n        blink2=blink2,\n        reverse=reverse,\n        conceal=conceal,\n        strike=strike,\n        underline2=underline2,\n        frame=frame,\n        encircle=encircle,\n        overline=overline,\n        link=link,\n        meta=meta,\n    )\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.as_triplet","title":"<code>as_triplet()</code>","text":"<p>Convert the color to a <code>rich.color_triplet.ColorTriplet</code>.</p> <p>Returns:</p> Name Type Description <code>ColorTriplet</code> <code>ColorTriplet</code> <p>The color as a color triplet.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>def as_triplet(self) -&gt; ColorTriplet:\n    \"\"\"Convert the color to a `rich.color_triplet.ColorTriplet`.\n\n    Returns:\n        ColorTriplet: The color as a color triplet.\n    \"\"\"\n    red = int(self._rgba.r * 255)\n    green = int(self._rgba.g * 255)\n    blue = int(self._rgba.b * 255)\n    return ColorTriplet(red, green, blue)\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.color_table","title":"<code>color_table(title, start, end, caption=None, *, show_index=False)</code>  <code>classmethod</code>","text":"<p>Generate a table of colors.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the color table.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> required <code>end</code> <code>int</code> <p>The ending index.</p> required <code>caption</code> <code>Optional[Text]</code> <p>The caption of the color table. Defaults to None.</p> <code>None</code> <code>show_index</code> <code>bool</code> <p>Whether to show the index of the color. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>The color table.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>@classmethod\ndef color_table(\n    cls,\n    title: str,\n    start: int,\n    end: int,\n    caption: Optional[Text] = None,\n    *,\n    show_index: bool = False,\n) -&gt; Table:\n    \"\"\"Generate a table of colors.\n\n    Args:\n        title (str): The title of the color table.\n        start (int): The starting index.\n        end (int): The ending index.\n        caption (Optional[Text], optional): The caption of the color table. Defaults to None.\n        show_index (bool, optional): Whether to show the index of the color. Defaults to False.\n\n    Returns:\n        Table: The color table.\n    \"\"\"\n    table = cls.generate_table(title, show_index, caption)\n    for index, (key, _) in enumerate(cls.COLORS_BY_NAME.items()):\n        if index &lt; start:\n            continue\n        elif index &gt; end:\n            break\n        color = Color(key)\n\n        color_index = Text(f\"{index: &gt;3}\", style=color.as_style(bold=True))\n        style = color.as_style(bold=True)\n        sample = Text(f\"{'\u2588' * 10}\", style=style)\n        name = Text(f\"{key.capitalize(): &lt;20}\", style=style)\n        hex_str = f\" {color.as_hex('long').upper()} \"\n        hex = Text(f\"{hex_str: ^7}\", style=color.as_bg_style())\n        r, g, b = color._rgba.r, color._rgba.g, color._rgba.b\n        r_int = int(r * 255)\n        g_int = int(g * 255)\n        b_int = int(b * 255)\n        rgb = Text.assemble(\n            *[\n                Text(\"rgb\", style=color.as_style(bold=True)),\n                Text(\"(\", style=\"b #ffffff\"),\n                Text(f\"{r_int: &gt;3}\", style=\"b #ff0000\"),\n                Text(\",\", style=\"b #ffffff\"),\n                Text(f\"{g_int: &gt;3}\", style=\"b #00ff00\"),\n                Text(\",\", style=\"b #ffffff\"),\n                Text(f\"{b_int: &gt;3}\", style=\"b #0099ff\"),\n                Text(\")\", style=\"b #ffffff\"),\n            ]\n        )\n        if show_index:\n            table.add_row(color_index, sample, name, hex, rgb)\n        else:\n            table.add_row(sample, name, hex, rgb)\n    return table\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.colortitle","title":"<code>colortitle(title)</code>  <code>classmethod</code>","text":"<p>Manually color a title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title to style.</p> required <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>The styled title.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>@classmethod\ndef colortitle(cls, title: str) -&gt; Text:\n    \"\"\"Manually color a title.\n\n    Args:\n        title (str): The title to style.\n\n    Returns:\n        Text: The styled title.\n    \"\"\"\n    title_list: List[str] = list(title)\n    length = len(title)\n    COLORS = cycle(\n        [\n            \"#FF00FF\",\n            \"#AF00FF\",\n            \"#5F00FF\",\n            \"#0000FF\",\n            \"#0055FF\",\n            \"#0080FF\",\n            \"#00C0FF\",\n            \"#00FFFF\",\n            \"#00FFAF\",\n            \"#00FF00\",\n            \"#AFFF00\",\n            \"#FFFF00\",\n            \"#FFAF00\",\n            \"#FF8700\",\n            \"#FF4B00\",\n            \"#FF0000\",\n            \"#FF005F\",\n        ]\n    )\n    color_title = Text()\n    # randomize\n    for _ in range(randint(0, 16)):\n        next(COLORS)\n    for index in range(length):\n        char: str = title_list[index]\n        color: str = next(COLORS)\n        color_title.append(Text(char, style=f\"bold {color}\"))\n    return color_title\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.example","title":"<code>example(record=False)</code>  <code>classmethod</code>","text":"<p>Generate a example of the color class.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>bool</code> <p>Whether to record the example as an svg.</p> <code>False</code> Source code in <code>src/rich_gradient/color.py</code> <pre><code>@classmethod\ndef example(cls, record: bool = False) -&gt; None:\n    \"\"\"Generate a example of the color class.\n\n    Args:\n        record (bool): Whether to record the example as an svg.\n    \"\"\"\n\n\n    from rich_gradient.theme import GRADIENT_TERMINAL_THEME\n    console = Console(record=True, width=80) if record else Console()\n\n    def table_generator() -&gt; Generator:\n        \"\"\"Generate the tables for the example.\"\"\"\n        tables: List[Tuple[str, int, int, Optional[Text]]] = [\n            (\n                \"Gradient Colors\",\n                0,\n                17,\n                Text(\n                    \"These colors have been adapted to make naming easier.\",\n                    style=\"i d #ffffff\",\n                ),\n            ),\n            (\"CSS3 Colors\", 18, 147, None),\n            (\"Rich Colors\", 148, 342, None),\n        ]\n        for table in tables:\n            yield table\n\n    for title, start, end, caption in table_generator():\n        console.line(2)\n        table = cls.color_table(title, start, end, caption=caption)\n        console.print(table, justify=\"center\")\n        console.line(2)\n\n    if record:\n        try:\n            console.save_svg(\n                \"docs/img/colors.svg\",\n                theme=GRADIENT_TERMINAL_THEME,\n                title=\"Colors\"\n                )\n        except TypeError:\n            pass\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.generate_table","title":"<code>generate_table(title, show_index=True, caption=None)</code>  <code>classmethod</code>","text":"<p>Generate a table to display colors.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title for the table.</p> required <code>show_index</code> <code>bool</code> <p>Whether to show the index column.</p> <code>True</code> <p>Returns:</p> Type Description <code>Table</code> <p>A <code>rich.table.Table</code> instance.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>@classmethod\ndef generate_table(\n    cls, title: str, show_index: bool = True, caption: Optional[Text] = None\n) -&gt; Table:\n    \"\"\"\n    Generate a table to display colors.\n\n    Args:\n        title: The title for the table.\n        show_index: Whether to show the index column.\n\n    Returns:\n        A `rich.table.Table` instance.\n    \"\"\"\n    color_title = cls.colortitle(title)\n    table = Table(\n        title=color_title, expand=False, caption=caption, caption_justify=\"right\"\n    )\n    if show_index:\n        table.add_column(cls.colortitle(\"Index\"), style=\"bold\", justify=\"right\")\n    table.add_column(cls.colortitle(\"Sample\"), style=\"bold\", justify=\"center\")\n    table.add_column(cls.colortitle(\"Name\"), style=\"bold\", justify=\"left\")\n    table.add_column(cls.colortitle(\"Hex\"), style=\"bold\", justify=\"left\")\n    table.add_column(cls.colortitle(\"RGB\"), style=\"bold\", justify=\"left\")\n    return table\n</code></pre>"},{"location":"color_ref/#rich_gradient.color.Color.get_contrast","title":"<code>get_contrast()</code>","text":"<p>Generate a foreground color for the color style.</p> <p>Generate a foreground color for the color style based on the color's contrast ratio. If the color is dark, the foreground color will be white. If the color is light, the foreground color will be black.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Color</code> <p>The foreground color.</p> Source code in <code>src/rich_gradient/color.py</code> <pre><code>def get_contrast(self) -&gt; RichColor:\n    \"\"\"Generate a foreground color for the color style.\n\n    Generate a foreground color for the color style based on the color's\n    contrast ratio. If the color is dark, the foreground color will be\n    white. If the color is light, the foreground color will be black.\n\n    Returns:\n        str: The foreground color.\n    \"\"\"\n    import colorsys\n\n    def rgb_to_hsv(color: Color) -&gt; Tuple[float, float, float]:\n        \"\"\"Convert an RGB color to HSV.\n\n        Args:\n            color (Color): The color to convert.\n\n        Returns:\n            Tuple[float, float, float]: The HSV values.\n        \"\"\"\n        rgba: RGBA = color._rgba\n        h, s, v = colorsys.rgb_to_hsv(r=rgba.r, g=rgba.g, b=rgba.b)\n        return h, s, v\n\n    def hsv_to_hsl(hue, saturation, value) -&gt; Tuple[float, float, float]:\n        \"\"\"Convert an HSV color to HSL.\n\n        Args:\n            hue (float): The hue value.\n            saturation (float): The saturation value.\n            value (float): The value value.\n\n        Returns:\n            Tuple[float, float, float]: The HSL values.\n        \"\"\"\n        lightness = (\n            (2 - saturation) * value / 2\n            if value &lt;= 0.5\n            else saturation * value / (2 - saturation)\n        )\n        saturation = (\n            0\n            if lightness == 0 or lightness == 1\n            else (value - lightness) / min(lightness, 1 - lightness)\n        )\n        return hue, saturation, lightness\n\n    def color_distance(color1: Color, color2: Color) -&gt; float:\n        \"\"\"Calculate the distance between two colors.\n\n        Args:\n            color1 (Color): The first color.\n            color2 (Color): The second color.\n\n        Returns:\n            float: The distance between the two colors.\n        \"\"\"\n        h1, s1, v1 = rgb_to_hsv(color1)\n        h2, s2, v2 = rgb_to_hsv(color2)\n        dh: float = min(abs(h1 - h2), 1 - abs(h1 - h2))\n        ds: float = abs(s1 - s2)\n        dv: float = abs(v1 - v2)\n        color_distance: float = dh + ds + dv\n        return color_distance\n\n    def find_closest_color(color1: Color, color_list: List[Color]) -&gt; Color:\n        \"\"\"Calculate the closest color in a list.\n\n        Args:\n            color1 (Color): The color to compare.\n            color_list (List[Color]): The list of colors to compare against.\n\n        Returns:\n            Color: The closest color.\n        \"\"\"\n        closest_color = None\n        min_distance = float(\"inf\")\n        for color in color_list:\n            distance = color_distance(color1, color)\n            if distance &lt; min_distance:\n                min_distance = distance\n                closest_color = color\n        assert closest_color is not None, \"No closest color found.\"\n        return closest_color\n\n    color_list: List[Color] = [Color(\"#000000\"), Color(\"#ffffff\")]\n    closest = find_closest_color(\n        self,\n        color_list=color_list,\n    )\n    if closest == Color(\"#000000\"):\n        return Color(\"#ffffff\").rich\n    else:\n        return Color(\"#000000\").rich\n</code></pre>"},{"location":"gradient/","title":"Gradient","text":"<p>The <code>Gradient</code> class is a subclass of <code>Text</code> that allows you to create gradients of color in your text. You can just enter text and allow rich-gradient to generate a random gradient of color for you text,specify the colors you want to use, or generate a random rainbow gradient.</p>"},{"location":"gradient/#random-gradient","title":"Random Gradient","text":"<pre><code>    from rich import Console\n    from rich_gradient import Gradient\n\n    console = Console()\n    console.print(\n        Gradient(\n            \"The quick brown fox jumps over the lazy dog.\"\n        )\n    )\n</code></pre>"},{"location":"gradient/#specific-color-gradient","title":"Specific Color Gradient","text":"<p>You can specify the colors you want to use in your gradient by passing a list of color names, hex color codes, rgb color codes, or <code>rich_gradient.color.Color</code>  to the <code>colors</code> parameter.</p>"},{"location":"gradient/#two-color-gradint","title":"Two Color Gradint","text":"<pre><code>    console.print(\n        Gradient(\n            \"This a gradient with two colors.\",\n            colors=[\"red\", \"orange\"]\n        ),\n        justify=\"center\"\n    )\n</code></pre> <pre><code>    console.print(\n        Gradient(\n            \"This a gradient with specific colors.\",\n            colors=[\"red\", \"#ff9900\", \"#ff0\", \"Lime\"],\n            justify=\"center\"\n        )\n    )\n</code></pre>"},{"location":"gradient_ref/","title":"Gradient","text":"<p>               Bases: <code>Text</code></p> <p>Text styled with gradient color.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code> `str` | `rich.text.Text` </code> <p>The text to print. Defaults to <code>\"\"</code>.</p> <code>''</code> <code>colors</code> <code> `GradientColors`, optional </code> <p>An optional list of colors [1]_ from which to make the Gradient. Defaults to None.</p> <code>None</code> <code>rainbow</code> <code> `bool` </code> <p>Whether to print the gradient text in rainbow colors across the spectrum. Defaults to False.</p> <code>False</code> <code>hues</code> <code> `int` </code> <p>The number of colors in the gradient. Defaults to <code>3</code>.</p> <code>4</code> <code>style</code> <code> `StyleType` </code> <p>The style of the gradient text. Defaults to None.</p> <code>null()</code> <code>verbose</code> <code> `bool` </code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <code>justify</code> <code> `JustifyMethod`</code> <p>Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.</p> <code>DEFAULT_JUSTIFY</code> <code>overflow</code> <code>Optional[OverflowMethod]</code> <p>Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.</p> <code>DEFAULT_OVERFLOW</code> <code>end</code> <code>str</code> <p>Character to end text with. Defaults to \"\\n\".</p> <code>'\\n'</code> <code>no_wrap</code> <code>bool</code> <p>Disable text wrapping, or None for default. Defaults to None.</p> <code>None</code> <code>tab_size</code> <code>int</code> <p>Number of spaces per tab, or <code>None</code> to use <code>console.tab_size</code>. Defaults to 4.</p> <code>4</code> <code>spans</code> <code>List[Span]</code> <p>A list of predefined style spans. Defaults to None.</p> <p>.. [1] colors: List[Optional[Color|Tuple|str|int]</p> <code>None</code> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>class Gradient(Text):\n    \"\"\"Text styled with gradient color.\n\n    Args:\n        text ( `str` | `rich.text.Text` ): The text to print. Defaults to `\"\"`.\n        colors ( `GradientColors`, optional ): An optional list of colors [1]_ from\n            which to make the Gradient. Defaults to None.\n        rainbow ( `bool` ): Whether to print the gradient text in rainbow colors\n            across the spectrum. Defaults to False.\n        hues ( `int` ): The number of colors in the gradient. Defaults to `3`.\n        style ( `StyleType` ): The style of the gradient text. Defaults to None.\n        verbose ( `bool` ): Whether to print verbose output. Defaults to False.\n        justify ( `JustifyMethod`, optional): Justify method: \"left\", \"center\",\n            \"full\", \"right\". Defaults to None.\n        overflow (Optional[OverflowMethod]):  Overflow method: \"crop\", \"fold\",\n            \"ellipsis\". Defaults to None.\n        end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\n        no_wrap (bool, optional): Disable text wrapping, or None for default.\n            Defaults to None.\n        tab_size (int): Number of spaces per tab, or `None` to use\n            `console.tab_size`. Defaults to 4.\n        spans (List[Span], optional): A list of predefined style spans.\n            Defaults to None.\n\n\n            .. [1] colors: List[Optional[Color|Tuple|str|int]\n    \"\"\"\n\n\n    __slots__ = [\n        \"_colors\",\n        \"_text\",\n        \"_length\",\n        \"length\",\n        \"_end\",\n        \"_hues\",\n        \"_justify\",\n        \"_no_wrap\",\n        \"overflow\",\n        \"_overflow\",\n        \"simple\",\n        \"style\",\n        \"_style\",\n        \"_spans\",\n        \"_rainbow\",\n        \"verbose\",\n    ]\n\n    def __init__(\n        self,\n        text: str | Text = \"\",\n        colors: GradientColors = None,\n        *,\n        rainbow: bool = False,\n        hues: int = 4,\n        style: StyleType = Style.null(),\n        justify: Optional[JustifyMethod] = DEFAULT_JUSTIFY,\n        overflow: Optional[OverflowMethod] = DEFAULT_OVERFLOW,\n        no_wrap: Optional[bool] = None,\n        end: str = \"\\n\",\n        tab_size: Optional[int] = 4,\n        verbose: bool = False,\n        spans: Optional[List[Span]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Text styled with gradient color.\n\n        Args:\n            text (text): The text to print. Defaults to `\"\"`.\\n\n            colors (List[Optional[Color|Tuple|str|int]]): A list of colors to use \\\n                for the gradient. Defaults to None.\\n\n            rainbow (bool): Whether to print the gradient text in rainbow colors\\\n                  across the spectrum. Defaults to False.\\n\n            hues (int): The number of colors in the gradient. Defaults to `4`.\\n\n            style (StyleType): The style of the gradient text. Defaults to None.\\n\n            verbose (bool): Whether to print verbose output. Defaults to False.\n            justify (Optional[JustifyMethod]): Justify method: \"left\", \"center\",\\\n                \"full\", \"right\". Defaults to None.\\n\n            overflow (Optional[OverflowMethod]):  Overflow method: \"crop\", \"fold\", \\\n                \"ellipsis\". Defaults to None.\\n\n            end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\\n\n            no_wrap (bool, optional): Disable text wrapping, or None for default.\\\n                Defaults to None.\\n\n            tab_size (int): Number of spaces per tab, or `None` to use\\\n                `console.tab_size`. Defaults to 4.\\n\n            spans (List[Span], optional): A list of predefined style spans.\\\n                Defaults to None.\\n\n\n        \"\"\"\n        self.simple = False\n        self.verbose = verbose or False\n        self.text = text  # type: ignore\n        self.hues = hues\n        self.justify = justify or DEFAULT_JUSTIFY\n        self.overflow = overflow or DEFAULT_OVERFLOW\n        self.style: StyleType = Style.parse(style) if isinstance(style, str) else style\n        self.colors = self.validate_colors(colors or [], rainbow=rainbow)  # type: ignore\n        if len(self.colors) == 2:\n            self.simple = True\n        if len(self.colors) &gt; 2:\n            self.hues = len(self.colors)\n        else:\n            self.hues = hues\n        self.verbose = verbose\n\n        super().__init__(\n            text=self.text,\n            style=style,\n            justify=justify,\n            overflow=overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size or 4,\n            spans=spans,\n        )\n        indexes = self.generate_indexes()\n        substrings = self.generate_substrings(indexes)\n        subgradients = self.generate_subgradients(substrings)\n        self._spans = self.join_subgradients(subgradients).spans\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the length of the gradient text.\"\"\"\n        return self._length\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the gradient text as a string.\"\"\"\n        return self.text\n\n    def __int__(self) -&gt; int:\n        \"\"\"Return the number of colors in the gradient.\"\"\"\n        return len(self.colors)\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"\n        Returns the concatenated string representation of the `_text` attribute.\n\n        Returns:\n            str: The concatenated string representation of the `_text` attribute.\n        \"\"\"\n        return \"\".join(self._text) if isinstance(self._text, list) else self._text\n\n    @text.setter\n    def text(self, value: Optional[str] | Optional[Text]) -&gt; None:\n        \"\"\"\n        Setter for the text attribute.\n\n        Args:\n            value (str|Text): The value to set for the text attribute.\n\n        Returns:\n            None\n        \"\"\"\n        if isinstance(value, Text):\n            self._length = value._length\n            self._text = value._text\n            self._spans = value.spans\n        elif isinstance(value, str):\n            sanitized_text = strip_control_codes(value)\n            self._length = len(sanitized_text)\n            self._text = list(sanitized_text)\n        elif value is None:\n            raise ValueError(\"Text cannot be None.\")\n        else:\n            raise TypeError(f\"Text must be a string or Text, not {type(value)}\")\n\n    @property\n    def hues(self) -&gt; int:\n        \"\"\"The number of colors in the gradient.\"\"\"\n        return self._hues\n\n    @hues.setter\n    def hues(self, hues: int) -&gt; None:\n        \"\"\"Set the number of colors in the gradient.\n\n        Args:\n            hues (int): The number of colors in the gradient. Defaults to `4`.\n        \"\"\"\n        if hues &lt; 2:\n            raise ValueError(\"Gradient must have at least two colors.\")\n        self._hues = hues\n\n    @property  # type: ignore\n    def justify(self) -&gt; JustifyMethod:\n        \"\"\"The justify method of the gradient.\"\"\"\n        if not hasattr(self, \"_justify\"):\n            return DEFAULT_JUSTIFY\n        return self._justify  # type: ignore\n\n    @justify.setter\n    def justify(self, justify: JustifyMethod) -&gt; None:\n        \"\"\"Set the justify method of the gradient.\n\n        Args:\n            justify (JustifyMethod): The justify method of the gradient.\n        \"\"\"\n        self._justify = justify\n\n    @property\n    def no_wrap(self) -&gt; Optional[bool]:\n        \"\"\"Whether to wrap the gradient text.\"\"\"\n        try:\n            return self._no_wrap\n        except AttributeError:\n            return None\n\n    @no_wrap.setter\n    def no_wrap(self, no_wrap: Optional[bool]) -&gt; None:\n        \"\"\"Set whether to wrap the gradient text.\n\n        Args:\n            no_wrap (bool): Whether to wrap the gradient text.\n        \"\"\"\n        self._no_wrap = no_wrap\n\n    @property\n    def colors(self) -&gt; List[Color]:\n        \"\"\"The colors in the gradient.\"\"\"\n        return self._colors\n\n    @colors.setter\n    def colors(self, values: Optional[List[ColorType]] | Optional[List[Color]]) -&gt; None:\n        \"\"\"Set the colors in the gradient.\n\n        Args:\n            colors (List[Color]): The colors in the gradient.\n        \"\"\"\n        self._colors = self.validate_colors(values)\n        self._hues = len(self._colors)\n\n    def validate_colors(\n        self,\n        colors: Optional[List[ColorType]] | Optional[List[Color]],\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Validate input colors, and convert them into `Color` objects.\n\n        Colors may be passed in as strings or tuples, names, or Color objects.\n        If no colors are provided, a random gradient will be generated.\n\n        Args:\n            colors (List[ColorType]): The colors to validate and convert\n\n        Returns:\n            List[Color]: The validated colors.\n\n        Raises:\n            PydanticCustomError: If any of the colors are invalid.\n        \"\"\"\n        _colors: List[Color] = []\n        if colors is None or colors == []:\n            if not rainbow:\n                color_list = Spectrum()\n                for index, color in enumerate(color_list):\n                    _colors.append(color)\n                    if index == self.hues - 1:\n                        break\n                return _colors\n            else:\n                self.hues = 20\n                if self._length &lt; 20:\n                    self.hues = self._length\n                color_list = Spectrum()\n                for index, color in enumerate(color_list):\n                    _colors.append(color)\n                    if index == self.hues - 1:\n                        break\n                return _colors\n        elif isinstance(colors, tuple):\n            for color in colors:\n                try:\n                    color = Color(color)\n                except PydanticCustomError as pce:\n                    raise pce\n                else:\n                    _colors.append(color)\n            assert len(_colors) &gt;= 2, \"Gradient must have at least two colors.\"\n            return _colors\n        elif isinstance(colors, list):\n            for color in colors:  # type: ignore\n                try:\n                    color = Color(color)\n                except PydanticCustomError as pce:\n                    raise pce\n                else:\n                    _colors.append(color)\n            assert len(_colors) &gt;= 2, \"Gradient must have at least two colors.\"\n            return _colors\n        else:\n            raise TypeError(f\"Colors must be a list or tuple, not {type(colors)}.\")\n\n    def _base_span(self) -&gt; None:\n        if not hasattr(self, \"_spans\"):\n            self._spans = [Span(0, self._length - 1, self.style)]\n\n    @property\n    def spans(self) -&gt; List[Span]:\n        \"\"\"The spans of the gradient.\"\"\"\n        self._base_span()\n        return self._spans\n\n    @spans.setter\n    def spans(self, spans: List[Span]) -&gt; None:\n        \"\"\"Set the spans of the gradient.\n\n        Args:\n            spans (List[Span]): The spans of the gradient.\n        \"\"\"\n        self._spans = spans\n\n    @staticmethod\n    def arange(start, stop=None, step=1, dtype=None):\n        if stop is None:\n            # If only one argument is provided, it's the stop value, and start is 0\n            start, stop = 0, start\n\n        if step == 0:\n            raise ValueError(\"Step must be non-zero\")\n\n        if dtype is None:\n            # Automatically detect dtype\n            if isinstance(start, int) and (\n                isinstance(stop, float) or isinstance(step, float)\n            ):\n                dtype = float\n            else:\n                dtype = type(start)\n\n        current = start\n        result = []\n\n        # Determine the comparison operation based on the sign of the step\n        if step &gt; 0:\n            while current &lt; stop:\n                result.append(dtype(current))\n                current += step\n        else:\n            while current &gt; stop:\n                result.append(dtype(current))\n                current += step\n\n        return result\n\n    @staticmethod\n    def array_split(arr, indices_or_sections):\n        if isinstance(indices_or_sections, int):\n            if indices_or_sections &lt;= 0:\n                raise ValueError(\"Number of sections must be greater than 0.\")\n\n            # Calculate the size of each section\n            section_size = len(arr) // indices_or_sections\n            remainder = len(arr) % indices_or_sections\n\n            sections = []\n            start = 0\n\n            for i in range(indices_or_sections):\n                end = start + section_size + (1 if i &lt; remainder else 0)\n                sections.append(arr[start:end])\n                start = end\n\n            return sections\n\n        elif isinstance(indices_or_sections, (list, tuple)):\n            sections = []\n            prev_index = 0\n\n            for index in indices_or_sections:\n                sections.append(arr[prev_index:index])\n                prev_index = index\n\n            sections.append(arr[prev_index:])\n\n            return sections\n\n        else:\n            raise TypeError(\n                \"indices_or_sections must be an integer or a list/tuple of integers.\"\n            )\n\n    def generate_indexes(self) -&gt; List[List[int]]:\n        \"\"\"Chunk the text into a list of strings.\n\n        Returns:\n            List[str]: The list of strings.\n        \"\"\"\n        result = self.array_split(self.arange(self._length), self.hues - 1)  # noqa: F722\n        indexes: List[List[int]] = [sublist for sublist in result]\n        return indexes\n\n    def generate_substrings(self, indexes: List[List[int]]) -&gt; List[str]:\n        \"\"\"Split the text into substrings based on the indexes.\n\n        Args:\n            indexes (List[List[int]]): The indexes to split the text on.\n\n        Returns:\n            List[str]: The list of substrings.\n        \"\"\"\n        substrings: List[str] = []\n        slices: List[Tuple[int, int]] = []\n\n        # For each index get the first and last element\n        for index in indexes:\n            start = index[0]\n            end = index[-1] + 1\n            slices.append((start, end))  #  # Slice the text\n\n        # If the text is a list, join it into a single string\n        if isinstance(self.text, list):\n            text = \" \".join(self.text)\n        elif isinstance(self.text, str):\n            text = self.text\n        else:\n            raise TypeError(f\"Text must be a string or list, not {type(self.text)}\")\n\n        # split the text into substrings\n        for index, (start, end) in enumerate(slices, 1):  # type: ignore\n            substring = text[start:end]\n            substrings.append(substring)\n        return substrings\n\n    def generate_subgradients(self, substrings: List[str]) -&gt; List[SimpleGradient]:\n        \"\"\"Generate simple gradients.\n\n        Args:\n            substrings (List[str]): The substrings to generate gradients for.\n\n        Returns:\n            List[SimpleGradient]: The list of simple gradients.\n        \"\"\"\n        subgradients: List[SimpleGradient] = []\n\n        if self.simple:\n            return [\n                SimpleGradient(\n                    self.text,\n                    color1=self.colors[0].hex,\n                    color2=self.colors[1].hex,\n                    style=self.style,\n                    justify=self.justify or DEFAULT_JUSTIFY,\n                    overflow=self.overflow or DEFAULT_OVERFLOW,\n                    no_wrap=self.no_wrap or False,\n                    end=self.end or \"\\n\",\n                    spans=self.spans,\n                )\n            ]\n        else:\n            for index, substring in enumerate(substrings):\n                # Get the colors for the gradient\n                color_1 = self.colors[index]\n                color_2 = self.colors[index + 1]\n\n                assert self.overflow is not None, \"Overflow must be set.\"\n\n                # Create a simple gradient\n                gradient = SimpleGradient(\n                    substring,  # type: ignore\n                    color1=color_1.hex,\n                    color2=color_2.hex,\n                    justify=self.justify,\n                    overflow=self.overflow,\n                    style=self.style,\n                    no_wrap=self.no_wrap or False,\n                    end=self.end or \"\\n\",\n                    spans=self.spans,\n                )\n\n                subgradients.append(gradient)\n            return subgradients\n\n    def join_subgradients(self, subgradients: List[SimpleGradient]) -&gt; Text:\n        \"\"\"Join the subgradients into a single gradient.\n\n        Args:\n            subgradients (List[SimpleGradient]): The list of subgradients.\n\n        Returns:\n            Text: The joined gradient.\n        \"\"\"\n        result = Text()\n        for gradient in subgradients:\n            result.append(gradient)\n        return result\n\n    def as_text(self) -&gt; Text:\n        \"\"\"Convert the gradient to a `Text`.\n\n        Returns:\n            Text: The gradient as a `rich.text.Text` object.\n        \"\"\"\n        overflow: OverflowMethod = DEFAULT_OVERFLOW\n        justify: JustifyMethod = DEFAULT_JUSTIFY\n        if self.justify is None:\n            justify = DEFAULT_JUSTIFY\n        if self.overflow is None:\n            overflow = DEFAULT_OVERFLOW\n        return Text(\n            text=self.text,\n            style=self.style,\n            justify=justify,\n            overflow=overflow,\n            no_wrap=self.no_wrap,\n            end=self.end or \"\\n\",\n            tab_size=self.tab_size,\n            spans=self._spans,\n        )\n\n    @classmethod\n    def named_gradient_example(\n        cls,\n        save: bool = False,\n        path: str = str(Path.cwd() / \"docs\" / \"img\" / \"named_gradient_example.svg\"),\n    ) -&gt; None:\n        \"\"\"\n        Generate an example of a gradient with defined colors.\n\n        Args:\n            save (bool, optional): Whether to save the gradient to a file. Defaults to False.\n            path (Optional[Path], optional): The filename to save the gradient to. Defaults \\\n        to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\").\n                console (Console, optional): The console to print the gradient to. Defaults to console.\n        \"\"\"\n        if save:\n            console = Console(width=60, record=True)\n        else:\n            console = Console(width=60)\n        gradient = Gradient(\n            \"The quick brown fox jumps over the lazy dog.\",\n            colors=[\"magenta\", \"purple\", \"violet\"],\n        )\n        panel_content = Text.assemble(\n            gradient,\n            Text(\"\\n\\nThis gradient starts with \"),\n            Text(\"magenta\", style=\"b #ff00ff\"),\n            Text(\". It fades to \"),\n            Text(\"purple\", style=\"b #af00ff\"),\n            Text(\", and ends in \"),\n            Text(\"violet\", style=\"b #5f00ff\"),\n            Text(\".\"),\n            justify=\"center\",\n        )\n        console.line(2)\n        console.print(\n            Panel(panel_content, title=\"[b #ffffff]Named Gradient[/]\", padding=(1, 4)),\n            justify=\"center\",\n        )\n        console.print(\n            \"[dim i]Named gradients are graidents that have user \\\nspecified colors[/]\",\n            justify=\"center\",\n        )\n        if save:\n            console.save_svg(path, title=\"rich-gradient\", theme=GRADIENT_TERMINAL_THEME)\n\n    @classmethod\n    def random_gradient_example(\n        cls,\n        save: bool = False,\n        path: str = str(Path.cwd() / \"docs\" / \"img\" / \"random_gradient_example.svg\"),\n    ) -&gt; None:\n        \"\"\"\n        Generate an example of a gradient with random adjacent colors.\n\n        Args:\n            save (bool, optional): Whether to save the gradient to a file. Defaults to False.\n            path (Optional[Path], optional): The filename to save the gradient to. Defaults \\\n        to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\").\n                console (Console, optional): The console to print the gradient to. Defaults to console.\n        \"\"\"\n        if save:\n            console = Console(width=60, record=True)\n        else:\n            console = Console(width=60)\n        console.line()\n        console.print(\n            Panel(\n                Gradient(\n                    text=\"The quick brown fox jumps over the lazy dog.\",\n                    justify=\"center\",\n                ),\n                title=\"[b #ffffff]Random Gradient[/b #ffffff]\",\n                padding=(1, 4),\n            ),\n            justify=\"center\",\n        )\n        console.print(\n            \"[i dim]Random gradients are randomly generated by \\\ngradient automatically.[/]\",\n            justify=\"center\",\n        )\n        console.line()\n        if save:\n            console.save_svg(path, title=\"rich-gradient\", theme=GRADIENT_TERMINAL_THEME)\n\n    @classmethod\n    def rainbow_gradient_example(\n        cls,\n        save: bool = False,\n        path: str = str(Path.cwd() / \"docs\" / \"img\" / \"rainbow_gradient_example.svg\"),\n    ) -&gt; None:\n        \"\"\"\n        Generate an example of a gradient with the whole spectrum of colors.\n\n        Args:\n            save (bool, optional): Whether to save the gradient to a file. Defaults to False.\n            path (Optional[Path], optional): The filename to save the gradient to. Defaults \\\n        to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\").\n                console (Console, optional): The console to print the gradient to. Defaults to console.\n        \"\"\"\n        if save:\n            console = Console(width=60, record=True)\n        else:\n            console = Console(width=60)\n\n        console.line(1)\n        console.print(\n            Panel(\n                Gradient(\n                    text=\"The quick brown fox jumps over the lazy dog.\",\n                    rainbow=True,\n                    justify=\"center\",\n                ),\n                title=Gradient(\"Rainbow Gradient\", rainbow=True),\n                padding=(1, 4),\n            ),\n            justify=\"center\",\n        )\n        console.print(\n            \"[dim i]Rainbow gradients are also automated and will randomly \\\nspan a gradient from one point on the spectrum (randomly) all the way around \\\nuntil it returns to it's starting color.\",\n            justify=\"center\",\n        )\n        console.line(1)\n        if save:\n            console.save_svg(path, title=\"rich-gradient\", theme=GRADIENT_TERMINAL_THEME)\n\n    @classmethod\n    def example(cls) -&gt; None:\n        Gradient.named_gradient_example(True)\n        Gradient.random_gradient_example(True)\n        Gradient.rainbow_gradient_example(True)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.colors","title":"<code>colors: List[Color]</code>  <code>property</code> <code>writable</code>","text":"<p>The colors in the gradient.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.hues","title":"<code>hues: int</code>  <code>property</code> <code>writable</code>","text":"<p>The number of colors in the gradient.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.justify","title":"<code>justify: JustifyMethod</code>  <code>property</code> <code>writable</code>","text":"<p>The justify method of the gradient.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.no_wrap","title":"<code>no_wrap: Optional[bool]</code>  <code>property</code> <code>writable</code>","text":"<p>Whether to wrap the gradient text.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.spans","title":"<code>spans: List[Span]</code>  <code>property</code> <code>writable</code>","text":"<p>The spans of the gradient.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.text","title":"<code>text: str</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the concatenated string representation of the <code>_text</code> attribute.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The concatenated string representation of the <code>_text</code> attribute.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__init__","title":"<code>__init__(text='', colors=None, *, rainbow=False, hues=4, style=Style.null(), justify=DEFAULT_JUSTIFY, overflow=DEFAULT_OVERFLOW, no_wrap=None, end='\\n', tab_size=4, verbose=False, spans=None)</code>","text":"<p>Text styled with gradient color.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>text</code> <p>The text to print. Defaults to <code>\"\"</code>.</p> <code>''</code> <code>colors</code> <code>List[Optional[Color | Tuple | str | int]]</code> <p>A list of colors to use                 for the gradient. Defaults to None.</p> <code>None</code> <code>rainbow</code> <code>bool</code> <p>Whether to print the gradient text in rainbow colors                  across the spectrum. Defaults to False.</p> <code>False</code> <code>hues</code> <code>int</code> <p>The number of colors in the gradient. Defaults to <code>4</code>.</p> <code>4</code> <code>style</code> <code>StyleType</code> <p>The style of the gradient text. Defaults to None.</p> <code>null()</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <code>justify</code> <code>Optional[JustifyMethod]</code> <p>Justify method: \"left\", \"center\",                \"full\", \"right\". Defaults to None.</p> <code>DEFAULT_JUSTIFY</code> <code>overflow</code> <code>Optional[OverflowMethod]</code> <p>Overflow method: \"crop\", \"fold\",                 \"ellipsis\". Defaults to None.</p> <code>DEFAULT_OVERFLOW</code> <code>end</code> <code>str</code> <p>Character to end text with. Defaults to \"\\n\".</p> <code>'\\n'</code> <code>no_wrap</code> <code>bool</code> <p>Disable text wrapping, or None for default.                Defaults to None.</p> <code>None</code> <code>tab_size</code> <code>int</code> <p>Number of spaces per tab, or <code>None</code> to use                <code>console.tab_size</code>. Defaults to 4.</p> <code>4</code> <code>spans</code> <code>List[Span]</code> <p>A list of predefined style spans.                Defaults to None.</p> <code>None</code> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __init__(\n    self,\n    text: str | Text = \"\",\n    colors: GradientColors = None,\n    *,\n    rainbow: bool = False,\n    hues: int = 4,\n    style: StyleType = Style.null(),\n    justify: Optional[JustifyMethod] = DEFAULT_JUSTIFY,\n    overflow: Optional[OverflowMethod] = DEFAULT_OVERFLOW,\n    no_wrap: Optional[bool] = None,\n    end: str = \"\\n\",\n    tab_size: Optional[int] = 4,\n    verbose: bool = False,\n    spans: Optional[List[Span]] = None,\n) -&gt; None:\n    \"\"\"\n    Text styled with gradient color.\n\n    Args:\n        text (text): The text to print. Defaults to `\"\"`.\\n\n        colors (List[Optional[Color|Tuple|str|int]]): A list of colors to use \\\n            for the gradient. Defaults to None.\\n\n        rainbow (bool): Whether to print the gradient text in rainbow colors\\\n              across the spectrum. Defaults to False.\\n\n        hues (int): The number of colors in the gradient. Defaults to `4`.\\n\n        style (StyleType): The style of the gradient text. Defaults to None.\\n\n        verbose (bool): Whether to print verbose output. Defaults to False.\n        justify (Optional[JustifyMethod]): Justify method: \"left\", \"center\",\\\n            \"full\", \"right\". Defaults to None.\\n\n        overflow (Optional[OverflowMethod]):  Overflow method: \"crop\", \"fold\", \\\n            \"ellipsis\". Defaults to None.\\n\n        end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\\n\n        no_wrap (bool, optional): Disable text wrapping, or None for default.\\\n            Defaults to None.\\n\n        tab_size (int): Number of spaces per tab, or `None` to use\\\n            `console.tab_size`. Defaults to 4.\\n\n        spans (List[Span], optional): A list of predefined style spans.\\\n            Defaults to None.\\n\n\n    \"\"\"\n    self.simple = False\n    self.verbose = verbose or False\n    self.text = text  # type: ignore\n    self.hues = hues\n    self.justify = justify or DEFAULT_JUSTIFY\n    self.overflow = overflow or DEFAULT_OVERFLOW\n    self.style: StyleType = Style.parse(style) if isinstance(style, str) else style\n    self.colors = self.validate_colors(colors or [], rainbow=rainbow)  # type: ignore\n    if len(self.colors) == 2:\n        self.simple = True\n    if len(self.colors) &gt; 2:\n        self.hues = len(self.colors)\n    else:\n        self.hues = hues\n    self.verbose = verbose\n\n    super().__init__(\n        text=self.text,\n        style=style,\n        justify=justify,\n        overflow=overflow,\n        no_wrap=no_wrap,\n        end=end,\n        tab_size=tab_size or 4,\n        spans=spans,\n    )\n    indexes = self.generate_indexes()\n    substrings = self.generate_substrings(indexes)\n    subgradients = self.generate_subgradients(substrings)\n    self._spans = self.join_subgradients(subgradients).spans\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__int__","title":"<code>__int__()</code>","text":"<p>Return the number of colors in the gradient.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __int__(self) -&gt; int:\n    \"\"\"Return the number of colors in the gradient.\"\"\"\n    return len(self.colors)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the gradient text.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the length of the gradient text.\"\"\"\n    return self._length\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__str__","title":"<code>__str__()</code>","text":"<p>Return the gradient text as a string.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the gradient text as a string.\"\"\"\n    return self.text\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.as_text","title":"<code>as_text()</code>","text":"<p>Convert the gradient to a <code>Text</code>.</p> <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>The gradient as a <code>rich.text.Text</code> object.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def as_text(self) -&gt; Text:\n    \"\"\"Convert the gradient to a `Text`.\n\n    Returns:\n        Text: The gradient as a `rich.text.Text` object.\n    \"\"\"\n    overflow: OverflowMethod = DEFAULT_OVERFLOW\n    justify: JustifyMethod = DEFAULT_JUSTIFY\n    if self.justify is None:\n        justify = DEFAULT_JUSTIFY\n    if self.overflow is None:\n        overflow = DEFAULT_OVERFLOW\n    return Text(\n        text=self.text,\n        style=self.style,\n        justify=justify,\n        overflow=overflow,\n        no_wrap=self.no_wrap,\n        end=self.end or \"\\n\",\n        tab_size=self.tab_size,\n        spans=self._spans,\n    )\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.generate_indexes","title":"<code>generate_indexes()</code>","text":"<p>Chunk the text into a list of strings.</p> <p>Returns:</p> Type Description <code>List[List[int]]</code> <p>List[str]: The list of strings.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def generate_indexes(self) -&gt; List[List[int]]:\n    \"\"\"Chunk the text into a list of strings.\n\n    Returns:\n        List[str]: The list of strings.\n    \"\"\"\n    result = self.array_split(self.arange(self._length), self.hues - 1)  # noqa: F722\n    indexes: List[List[int]] = [sublist for sublist in result]\n    return indexes\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.generate_subgradients","title":"<code>generate_subgradients(substrings)</code>","text":"<p>Generate simple gradients.</p> <p>Parameters:</p> Name Type Description Default <code>substrings</code> <code>List[str]</code> <p>The substrings to generate gradients for.</p> required <p>Returns:</p> Type Description <code>List[SimpleGradient]</code> <p>List[SimpleGradient]: The list of simple gradients.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def generate_subgradients(self, substrings: List[str]) -&gt; List[SimpleGradient]:\n    \"\"\"Generate simple gradients.\n\n    Args:\n        substrings (List[str]): The substrings to generate gradients for.\n\n    Returns:\n        List[SimpleGradient]: The list of simple gradients.\n    \"\"\"\n    subgradients: List[SimpleGradient] = []\n\n    if self.simple:\n        return [\n            SimpleGradient(\n                self.text,\n                color1=self.colors[0].hex,\n                color2=self.colors[1].hex,\n                style=self.style,\n                justify=self.justify or DEFAULT_JUSTIFY,\n                overflow=self.overflow or DEFAULT_OVERFLOW,\n                no_wrap=self.no_wrap or False,\n                end=self.end or \"\\n\",\n                spans=self.spans,\n            )\n        ]\n    else:\n        for index, substring in enumerate(substrings):\n            # Get the colors for the gradient\n            color_1 = self.colors[index]\n            color_2 = self.colors[index + 1]\n\n            assert self.overflow is not None, \"Overflow must be set.\"\n\n            # Create a simple gradient\n            gradient = SimpleGradient(\n                substring,  # type: ignore\n                color1=color_1.hex,\n                color2=color_2.hex,\n                justify=self.justify,\n                overflow=self.overflow,\n                style=self.style,\n                no_wrap=self.no_wrap or False,\n                end=self.end or \"\\n\",\n                spans=self.spans,\n            )\n\n            subgradients.append(gradient)\n        return subgradients\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.generate_substrings","title":"<code>generate_substrings(indexes)</code>","text":"<p>Split the text into substrings based on the indexes.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>List[List[int]]</code> <p>The indexes to split the text on.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The list of substrings.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def generate_substrings(self, indexes: List[List[int]]) -&gt; List[str]:\n    \"\"\"Split the text into substrings based on the indexes.\n\n    Args:\n        indexes (List[List[int]]): The indexes to split the text on.\n\n    Returns:\n        List[str]: The list of substrings.\n    \"\"\"\n    substrings: List[str] = []\n    slices: List[Tuple[int, int]] = []\n\n    # For each index get the first and last element\n    for index in indexes:\n        start = index[0]\n        end = index[-1] + 1\n        slices.append((start, end))  #  # Slice the text\n\n    # If the text is a list, join it into a single string\n    if isinstance(self.text, list):\n        text = \" \".join(self.text)\n    elif isinstance(self.text, str):\n        text = self.text\n    else:\n        raise TypeError(f\"Text must be a string or list, not {type(self.text)}\")\n\n    # split the text into substrings\n    for index, (start, end) in enumerate(slices, 1):  # type: ignore\n        substring = text[start:end]\n        substrings.append(substring)\n    return substrings\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.join_subgradients","title":"<code>join_subgradients(subgradients)</code>","text":"<p>Join the subgradients into a single gradient.</p> <p>Parameters:</p> Name Type Description Default <code>subgradients</code> <code>List[SimpleGradient]</code> <p>The list of subgradients.</p> required <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>The joined gradient.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def join_subgradients(self, subgradients: List[SimpleGradient]) -&gt; Text:\n    \"\"\"Join the subgradients into a single gradient.\n\n    Args:\n        subgradients (List[SimpleGradient]): The list of subgradients.\n\n    Returns:\n        Text: The joined gradient.\n    \"\"\"\n    result = Text()\n    for gradient in subgradients:\n        result.append(gradient)\n    return result\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.named_gradient_example","title":"<code>named_gradient_example(save=False, path=str(Path.cwd() / 'docs' / 'img' / 'named_gradient_example.svg'))</code>  <code>classmethod</code>","text":"<p>Generate an example of a gradient with defined colors.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Whether to save the gradient to a file. Defaults to False.</p> <code>False</code> <code>path</code> <code>Optional[Path]</code> <p>The filename to save the gradient to. Defaults         to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\"). console (Console, optional): The console to print the gradient to. Defaults to console.</p> <code>str(cwd() / 'docs' / 'img' / 'named_gradient_example.svg')</code> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>    @classmethod\n    def named_gradient_example(\n        cls,\n        save: bool = False,\n        path: str = str(Path.cwd() / \"docs\" / \"img\" / \"named_gradient_example.svg\"),\n    ) -&gt; None:\n        \"\"\"\n        Generate an example of a gradient with defined colors.\n\n        Args:\n            save (bool, optional): Whether to save the gradient to a file. Defaults to False.\n            path (Optional[Path], optional): The filename to save the gradient to. Defaults \\\n        to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\").\n                console (Console, optional): The console to print the gradient to. Defaults to console.\n        \"\"\"\n        if save:\n            console = Console(width=60, record=True)\n        else:\n            console = Console(width=60)\n        gradient = Gradient(\n            \"The quick brown fox jumps over the lazy dog.\",\n            colors=[\"magenta\", \"purple\", \"violet\"],\n        )\n        panel_content = Text.assemble(\n            gradient,\n            Text(\"\\n\\nThis gradient starts with \"),\n            Text(\"magenta\", style=\"b #ff00ff\"),\n            Text(\". It fades to \"),\n            Text(\"purple\", style=\"b #af00ff\"),\n            Text(\", and ends in \"),\n            Text(\"violet\", style=\"b #5f00ff\"),\n            Text(\".\"),\n            justify=\"center\",\n        )\n        console.line(2)\n        console.print(\n            Panel(panel_content, title=\"[b #ffffff]Named Gradient[/]\", padding=(1, 4)),\n            justify=\"center\",\n        )\n        console.print(\n            \"[dim i]Named gradients are graidents that have user \\\nspecified colors[/]\",\n            justify=\"center\",\n        )\n        if save:\n            console.save_svg(path, title=\"rich-gradient\", theme=GRADIENT_TERMINAL_THEME)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.rainbow_gradient_example","title":"<code>rainbow_gradient_example(save=False, path=str(Path.cwd() / 'docs' / 'img' / 'rainbow_gradient_example.svg'))</code>  <code>classmethod</code>","text":"<p>Generate an example of a gradient with the whole spectrum of colors.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Whether to save the gradient to a file. Defaults to False.</p> <code>False</code> <code>path</code> <code>Optional[Path]</code> <p>The filename to save the gradient to. Defaults         to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\"). console (Console, optional): The console to print the gradient to. Defaults to console.</p> <code>str(cwd() / 'docs' / 'img' / 'rainbow_gradient_example.svg')</code> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>    @classmethod\n    def rainbow_gradient_example(\n        cls,\n        save: bool = False,\n        path: str = str(Path.cwd() / \"docs\" / \"img\" / \"rainbow_gradient_example.svg\"),\n    ) -&gt; None:\n        \"\"\"\n        Generate an example of a gradient with the whole spectrum of colors.\n\n        Args:\n            save (bool, optional): Whether to save the gradient to a file. Defaults to False.\n            path (Optional[Path], optional): The filename to save the gradient to. Defaults \\\n        to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\").\n                console (Console, optional): The console to print the gradient to. Defaults to console.\n        \"\"\"\n        if save:\n            console = Console(width=60, record=True)\n        else:\n            console = Console(width=60)\n\n        console.line(1)\n        console.print(\n            Panel(\n                Gradient(\n                    text=\"The quick brown fox jumps over the lazy dog.\",\n                    rainbow=True,\n                    justify=\"center\",\n                ),\n                title=Gradient(\"Rainbow Gradient\", rainbow=True),\n                padding=(1, 4),\n            ),\n            justify=\"center\",\n        )\n        console.print(\n            \"[dim i]Rainbow gradients are also automated and will randomly \\\nspan a gradient from one point on the spectrum (randomly) all the way around \\\nuntil it returns to it's starting color.\",\n            justify=\"center\",\n        )\n        console.line(1)\n        if save:\n            console.save_svg(path, title=\"rich-gradient\", theme=GRADIENT_TERMINAL_THEME)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.random_gradient_example","title":"<code>random_gradient_example(save=False, path=str(Path.cwd() / 'docs' / 'img' / 'random_gradient_example.svg'))</code>  <code>classmethod</code>","text":"<p>Generate an example of a gradient with random adjacent colors.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Whether to save the gradient to a file. Defaults to False.</p> <code>False</code> <code>path</code> <code>Optional[Path]</code> <p>The filename to save the gradient to. Defaults         to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\"). console (Console, optional): The console to print the gradient to. Defaults to console.</p> <code>str(cwd() / 'docs' / 'img' / 'random_gradient_example.svg')</code> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>    @classmethod\n    def random_gradient_example(\n        cls,\n        save: bool = False,\n        path: str = str(Path.cwd() / \"docs\" / \"img\" / \"random_gradient_example.svg\"),\n    ) -&gt; None:\n        \"\"\"\n        Generate an example of a gradient with random adjacent colors.\n\n        Args:\n            save (bool, optional): Whether to save the gradient to a file. Defaults to False.\n            path (Optional[Path], optional): The filename to save the gradient to. Defaults \\\n        to Path(\"/Users/maxludden/dev/py/MaxGradient/docs/img/named_gradient_example.svg\").\n                console (Console, optional): The console to print the gradient to. Defaults to console.\n        \"\"\"\n        if save:\n            console = Console(width=60, record=True)\n        else:\n            console = Console(width=60)\n        console.line()\n        console.print(\n            Panel(\n                Gradient(\n                    text=\"The quick brown fox jumps over the lazy dog.\",\n                    justify=\"center\",\n                ),\n                title=\"[b #ffffff]Random Gradient[/b #ffffff]\",\n                padding=(1, 4),\n            ),\n            justify=\"center\",\n        )\n        console.print(\n            \"[i dim]Random gradients are randomly generated by \\\ngradient automatically.[/]\",\n            justify=\"center\",\n        )\n        console.line()\n        if save:\n            console.save_svg(path, title=\"rich-gradient\", theme=GRADIENT_TERMINAL_THEME)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.validate_colors","title":"<code>validate_colors(colors, rainbow=False)</code>","text":"<p>Validate input colors, and convert them into <code>Color</code> objects.</p> <p>Colors may be passed in as strings or tuples, names, or Color objects. If no colors are provided, a random gradient will be generated.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>List[ColorType]</code> <p>The colors to validate and convert</p> required <p>Returns:</p> Type Description <code>List[Color]</code> <p>List[Color]: The validated colors.</p> <p>Raises:</p> Type Description <code>PydanticCustomError</code> <p>If any of the colors are invalid.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def validate_colors(\n    self,\n    colors: Optional[List[ColorType]] | Optional[List[Color]],\n    rainbow: bool = False,\n) -&gt; List[Color]:\n    \"\"\"Validate input colors, and convert them into `Color` objects.\n\n    Colors may be passed in as strings or tuples, names, or Color objects.\n    If no colors are provided, a random gradient will be generated.\n\n    Args:\n        colors (List[ColorType]): The colors to validate and convert\n\n    Returns:\n        List[Color]: The validated colors.\n\n    Raises:\n        PydanticCustomError: If any of the colors are invalid.\n    \"\"\"\n    _colors: List[Color] = []\n    if colors is None or colors == []:\n        if not rainbow:\n            color_list = Spectrum()\n            for index, color in enumerate(color_list):\n                _colors.append(color)\n                if index == self.hues - 1:\n                    break\n            return _colors\n        else:\n            self.hues = 20\n            if self._length &lt; 20:\n                self.hues = self._length\n            color_list = Spectrum()\n            for index, color in enumerate(color_list):\n                _colors.append(color)\n                if index == self.hues - 1:\n                    break\n            return _colors\n    elif isinstance(colors, tuple):\n        for color in colors:\n            try:\n                color = Color(color)\n            except PydanticCustomError as pce:\n                raise pce\n            else:\n                _colors.append(color)\n        assert len(_colors) &gt;= 2, \"Gradient must have at least two colors.\"\n        return _colors\n    elif isinstance(colors, list):\n        for color in colors:  # type: ignore\n            try:\n                color = Color(color)\n            except PydanticCustomError as pce:\n                raise pce\n            else:\n                _colors.append(color)\n        assert len(_colors) &gt;= 2, \"Gradient must have at least two colors.\"\n        return _colors\n    else:\n        raise TypeError(f\"Colors must be a list or tuple, not {type(colors)}.\")\n</code></pre>"},{"location":"gradient_rule/","title":"GradientRule","text":""},{"location":"gradient_rule/#gradientrule","title":"GradientRule","text":"<p>The 'GradientRule` class is based off of the rich.rule.Rule class and is used to define a rule in gradient color and variable thickness.</p>"},{"location":"gradient_rule/#usage","title":"Usage","text":"<pre><code>from rich.console import Console\nfrom rich_gradient.rule import GradientRule\n\nconsole = Console()\nconsole.print(\n    GradientRule(\n        \"Hello, world!\",\n    )\n)\n</code></pre>"},{"location":"gradient_rule/#alignment","title":"Alignment","text":"<p>The <code>GradientRule</code> class supports the same alignment options as the <code>Rule</code> class.</p> <pre><code>console.print(\n    GradientRule(\n        \"Hello, world! on the left\",\n        align=\"left\",\n    )\n)\n</code></pre> <p></p>"},{"location":"gradient_rule/#thickness","title":"Thickness","text":"<p>The <code>GradientRule</code> class add the ability to determine the thickness of the rule. Valid values are <code>thin</code>, <code>medium</code>, and <code>thick</code>. Defaults to <code>medium</code>.</p> <pre><code>console.print(\n    GradientRule(\n        \"Hello, world! thick\",\n        thickness=\"thick\"\n    )\n)\n</code></pre> <p></p>"},{"location":"gradient_rule_ref/","title":"Gradient Rule Reference","text":"<p>               Bases: <code>JupyterMixin</code></p> <p>A console renderable to draw a horizontal rule (line).</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Union[str, Text]</code> <p>Text to render in the rule. Defaults to \"\".</p> <code>''</code> <code>gradient</code> <code>bool</code> <p>Whether to use gradient colors. Defaults to True.</p> <code>True</code> <code>thickness</code> <code>Thickness</code> <p>Thickness of the rule. Defaults to \"medium\".</p> <code>'medium'</code> <code>end</code> <code>str</code> <p>Character at end of Rule. defaults to \"\\n\"</p> <code>'\\n'</code> <code>align</code> <code>str</code> <p>How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".</p> <code>'center'</code> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>class GradientRule(JupyterMixin):\n    \"\"\"A console renderable to draw a horizontal rule (line).\n\n    Args:\n        title (Union[str, Text], optional): Text to render in the rule. Defaults to \"\".\n        gradient (bool, optional): Whether to use gradient colors. Defaults to True.\n        thickness (Thickness, optional): Thickness of the rule. Defaults to \"medium\".\n        end (str, optional): Character at end of Rule. defaults to \"\\\\\\\\n\"\n        align (str, optional): How to align the title, one of \"left\",\n            \"center\", or \"right\". Defaults to \"center\".\n    \"\"\"\n\n    def __init__(\n        self,\n        title: Union[str, Text] = \"\",\n        *,\n        gradient: bool = True,\n        thickness: Thickness = \"medium\",\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n    ) -&gt; None:\n        \"\"\"Initialize the GradientRule Class.\n\n        Args:\n            title (Union[str, Text]): Text to render in the rule. Defaults to \"\".\n            gradient (bool, optional): Whether to use gradient colors. Defaults to True.\n            thickness (Thickness, optional): Thickness of the rule. Valid thicknesses are \\\nthin (`\u2500`), medium (`\u2501`), and thick (`\u2588`). Defaults to \"medium\".\n            end (str, optional): Character at end of Rule. Defaults to \"\\\\n\"\n            align (AlignMethod, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".\n        \"\"\"\n        self.gradient: bool = gradient\n        assert thickness in [\"thin\", \"medium\", \"thick\"], \"Invalid thickness\"\n        assert thickness is not None, \"Invalid thickness\"\n        self.thickness = thickness  # type: ignore\n        if self.thickness == \"thin\":\n            self.characters = \"\u2500\"\n        elif self.thickness == \"medium\":\n            self.characters = \"\u2501\"\n        elif self.thickness == \"thick\":\n            self.characters = \"\u2588\"\n\n        if cell_len(self.characters) &lt; 1:\n            raise ValueError(\n                \"'characters' argument must have a cell width of at least 1\"\n            )\n        assert align in (\"left\", \"center\", \"right\"), \"Invalid align\"\n\n        if isinstance(title, str):\n            self.title: Text = Text(title, style=\"b #ffffff\")\n        elif isinstance(title, Text):\n            self.title = title\n        self.end = end\n        self.align = align\n\n        rule_color_list: Spectrum = Spectrum(10)\n        self.left_colors: List[Color] = [\n            rule_color_list[0],\n            rule_color_list[1],\n            rule_color_list[2],\n            rule_color_list[3],\n            rule_color_list[4],\n        ]\n        self.right_colors: List[Color] = [\n            rule_color_list[4],\n            rule_color_list[5],\n            rule_color_list[6],\n            rule_color_list[7],\n            rule_color_list[8],\n        ]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"The string representation of the GradientRule class.\n\n        Returns:\n            str: The string representation of the GradientRule\"\"\"\n        return f\"Rule&lt;{self.title!r}, {self.characters!r}&gt;\"\n\n    # @spy\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions) -&gt; RenderResult:\n        \"\"\"The rich renderable method for the GradientRule class.\n\n        Args:\n            console (Console): The console instance.\n            options (ConsoleOptions): The console options.\n\n        Returns:\n            RenderResult: The renderable result of the GradientRule class.\n        \"\"\"\n        width = options.max_width\n\n        characters = (\n            \"-\"\n            if (options.ascii_only and not self.characters.isascii())\n            else self.characters\n        )\n\n        chars_len = cell_len(characters)\n        if not self.title:\n            color_list = Spectrum(5)\n            yield Gradient(\n                self._rule_line(chars_len, width),\n                colors=[\n                    color_list[0],\n                    color_list[1],\n                    color_list[2],\n                    color_list[3],\n                    color_list[4],\n                ],\n            )\n            return\n\n        if isinstance(self.title, Text):\n            self.title_text: Text = self.title\n        else:\n            self.title_text = console.render_str(self.title, style=\"rule.text\")\n\n        self.title_text.plain = self.title_text.plain.replace(\"\\n\", \" \")\n        self.title_text.expand_tabs()\n\n        required_space = 4 if self.align == \"center\" else 2\n        truncate_width = max(0, width - required_space)\n\n        # / No Title\n        if not truncate_width:\n            yield self._rule_line(chars_len, width)\n            return\n\n        rule_text = Text(end=self.end)\n        if self.align == \"center\":\n            rule_text = self.center_rule(rule_text, truncate_width, chars_len, width)\n        elif self.align == \"left\":\n            self.title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            rule_text.append(self.title_text)\n            rule_text.append(\" \")\n            if self.gradient:\n                rule_text.append(\n                    Gradient(\n                        characters * (width - self.title_text.cell_len - 1),\n                        colors=self.right_colors,  # type: ignore\n                    )\n                )\n            else:\n                rule_text.append(characters * (width - rule_text.cell_len))\n        elif self.align == \"right\":\n            self.title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            rule_text.append(\n                Gradient(\n                    characters * (width - self.title_text.cell_len - 1),\n                    colors=self.left_colors,  # type: ignore\n                )\n            )\n            rule_text.append(\" \")\n            rule_text.append(self.title_text)\n\n        rule_text.plain = set_cell_size(rule_text.plain, width)\n        yield rule_text\n\n    def _rule_line(self, chars_len: int, width: int) -&gt; Text:\n        \"\"\"Generate a rule line.\n\n        Args:\n            chars_len (int): Width of the rule characters.\n            width (int): Width of the rule.\n\n        Returns:\n            Text: The rule line.\n        \"\"\"\n        rule_text = Gradient(\n            self.characters * ((width // chars_len) + 1),\n            colors=self.left_colors,  # type: ignore\n        )\n        rule_text.truncate(width)\n        rule_text.plain = set_cell_size(rule_text.plain, width)\n        return rule_text\n\n    def center_rule(\n        self,\n        rule_text: Text,\n        truncate_width: int,\n        chars_len: int,\n        width: int) -&gt; Text:\n        \"\"\"Generate a centered rule.\n\n        Args:\n            rule_text (Text): Text of the rule.\n            truncate_width (int): Width of the truncated rule.\n            chars_len (int): Width of the rule characters.\n            width (int): Width of the rule.\n\n        Returns:\n            Text: The centered rule\n        \"\"\"\n        if rule_text is None:\n            rule_text = Text()\n        self.title_text.truncate(truncate_width, overflow=\"ellipsis\")\n        self.side_width: int = (width - cell_len(self.title_text.plain)) // 2\n        if self.gradient:\n            rule_text.append(\n                Gradient(\n                    self.characters * (self.side_width // chars_len + 1),\n                    colors=self.left_colors,  # type: ignore\n                    end=\"\",\n                )\n            )\n        else:\n            rule_text.append(\n                Text(self.characters * (self.side_width // chars_len + 1), end=\"\")\n            )\n        rule_text.append(\" \")\n        rule_text.append(self.title_text)\n        rule_text.append(\" \")\n        if self.gradient:\n            rule_text.append(\n                Gradient(\n                    self.characters * (self.side_width // chars_len + 1),\n                    colors=self.right_colors,  # type: ignore\n                    end=\" \",\n                )\n            )\n        else:\n            rule_text.append(\n                Text(self.characters * (self.side_width // chars_len + 1), end=\" \")\n            )\n        rule_text.truncate(width)\n        return rule_text\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions) -&gt; Measurement:\n        \"\"\"The rich measure method for the GradientRule class.\n\n        Args:\n            console (Console): The console instance.\n            options (ConsoleOptions): The console options.\n\n        Returns:\n            Measurement: The measurement of the GradientRule class.\"\"\"\n        return Measurement(1, 1)\n\n    @property\n    def thickness(self) -&gt; str:\n        \"\"\"Thickness of the rule line.\n\n        Returns:\n            str: The thickness of the rule line.\"\"\"\n        return self._thickness\n\n    # @spy\n    @thickness.setter\n    def thickness(self, thickness: Thickness) -&gt; None:\n        \"\"\"Set the thickness of the rule line.\n\n        Args:\n            thickness (Thickness): The thickness of the rule line.\n\n        Raises:\n            AssertionError: If the thickness is not one of \"thin\", \"medium\", or \"thick\".\n        \"\"\"\n        assert thickness in (\"thin\", \"medium\", \"thick\"), \"Invalid thickness\"\n        self._thickness = thickness\n\n    @property\n    def characters(self) -&gt; str:\n        \"\"\"Characters used to draw the rule.\n\n        Returns:\n            str: The characters used to draw the rule.\"\"\"\n        return self._characters\n\n    @characters.setter\n    def characters(self, characters: Optional[str]) -&gt; None:\n        \"\"\"Set or generate the characters to draw the rule.\n\n        Args:\n            characters (Optional[str]): The characters to draw the rule.\n        \"\"\"\n        # If being set by the user, use the value they provided\n        if characters is not None:\n            self._characters = characters\n            return\n\n        # If no characters are set, generate them based on the thickness\n        else:\n            if self.thickness == \"thin\":\n                self.characters = \"\u2500\"\n            elif self.thickness == \"medium\":\n                self.characters = \"\u2501\"\n            elif self.thickness == \"thick\":\n                self.characters = \"\u2588\"\n\n    @classmethod\n    def rule_example(cls, save: bool = False) -&gt; None:\n        \"\"\"Create a console with examples of Rule.\n\n        Args:\n            save (bool, optional): Save the console output to an SVG file. Defaults to False.\"\"\"\n        import sys\n\n        from rich_gradient.theme import GRADIENT_TERMINAL_THEME\n        from rich.console import Console\n\n        try:\n            title: str = sys.argv[1]\n        except IndexError:\n            title = \"Rule Example\"\n\n        console = Console(width=60, record=True)\n\n        console.line(2)\n        console.print(\"[u b #ffffff]Rule Examples[/]\", justify=\"center\")\n        console.line()\n        # console.print(\"[dim]Gradient Rule without a title \u2b07\ufe0e[/]\", justify=\"center\")\n        console.print(GradientRule(title=f\"{title}\", thickness=\"thin\", align=\"left\"))\n        console.line()\n        console.print(\n            GradientRule(\n                title=\"Thin Gradient Rule\",\n                gradient=True,\n                thickness=\"thin\",\n                align=\"center\",\n            )\n        )\n        console.line()\n        console.print(\n            GradientRule(title=\"Medium Gradient Rule\", gradient=True, align=\"right\")\n        )\n        console.line()\n        console.print(\n            GradientRule(\n                title=\"Medium Left-aligned Non-gradient Rule\",\n                gradient=False,\n                thickness=\"medium\",\n                align=\"left\",\n            )\n        )\n        console.line()\n        console.print(\n            GradientRule(title=\"Medium Right-aligned Gradient Rule\", align=\"right\")\n        )\n        console.line()\n        console.print(GradientRule(\"Thick Gradient Rule\", thickness=\"thick\"))\n        console.line(2)\n        console.save_svg(\n            path=\"docs/img/rule_example.svg\",\n            title=\"rich-gradient\",\n            theme=GRADIENT_TERMINAL_THEME\n        )\n</code></pre>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.characters","title":"<code>characters: str</code>  <code>property</code> <code>writable</code>","text":"<p>Characters used to draw the rule.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The characters used to draw the rule.</p>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.thickness","title":"<code>thickness: str</code>  <code>property</code> <code>writable</code>","text":"<p>Thickness of the rule line.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The thickness of the rule line.</p>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.__init__","title":"<code>__init__(title='', *, gradient=True, thickness='medium', end='\\n', align='center')</code>","text":"<p>Initialize the GradientRule Class.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Union[str, Text]</code> <p>Text to render in the rule. Defaults to \"\".</p> <code>''</code> <code>gradient</code> <code>bool</code> <p>Whether to use gradient colors. Defaults to True.</p> <code>True</code> <code>thickness</code> <code>Thickness</code> <p>Thickness of the rule. Valid thicknesses are thin (<code>\u2500</code>), medium (<code>\u2501</code>), and thick (<code>\u2588</code>). Defaults to \"medium\".</p> <code>'medium'</code> <code>end</code> <code>str</code> <p>Character at end of Rule. Defaults to \"\\n\"</p> <code>'\\n'</code> <code>align</code> <code>AlignMethod</code> <p>How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".</p> <code>'center'</code> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>    def __init__(\n        self,\n        title: Union[str, Text] = \"\",\n        *,\n        gradient: bool = True,\n        thickness: Thickness = \"medium\",\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n    ) -&gt; None:\n        \"\"\"Initialize the GradientRule Class.\n\n        Args:\n            title (Union[str, Text]): Text to render in the rule. Defaults to \"\".\n            gradient (bool, optional): Whether to use gradient colors. Defaults to True.\n            thickness (Thickness, optional): Thickness of the rule. Valid thicknesses are \\\nthin (`\u2500`), medium (`\u2501`), and thick (`\u2588`). Defaults to \"medium\".\n            end (str, optional): Character at end of Rule. Defaults to \"\\\\n\"\n            align (AlignMethod, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".\n        \"\"\"\n        self.gradient: bool = gradient\n        assert thickness in [\"thin\", \"medium\", \"thick\"], \"Invalid thickness\"\n        assert thickness is not None, \"Invalid thickness\"\n        self.thickness = thickness  # type: ignore\n        if self.thickness == \"thin\":\n            self.characters = \"\u2500\"\n        elif self.thickness == \"medium\":\n            self.characters = \"\u2501\"\n        elif self.thickness == \"thick\":\n            self.characters = \"\u2588\"\n\n        if cell_len(self.characters) &lt; 1:\n            raise ValueError(\n                \"'characters' argument must have a cell width of at least 1\"\n            )\n        assert align in (\"left\", \"center\", \"right\"), \"Invalid align\"\n\n        if isinstance(title, str):\n            self.title: Text = Text(title, style=\"b #ffffff\")\n        elif isinstance(title, Text):\n            self.title = title\n        self.end = end\n        self.align = align\n\n        rule_color_list: Spectrum = Spectrum(10)\n        self.left_colors: List[Color] = [\n            rule_color_list[0],\n            rule_color_list[1],\n            rule_color_list[2],\n            rule_color_list[3],\n            rule_color_list[4],\n        ]\n        self.right_colors: List[Color] = [\n            rule_color_list[4],\n            rule_color_list[5],\n            rule_color_list[6],\n            rule_color_list[7],\n            rule_color_list[8],\n        ]\n</code></pre>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.__repr__","title":"<code>__repr__()</code>","text":"<p>The string representation of the GradientRule class.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the GradientRule</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"The string representation of the GradientRule class.\n\n    Returns:\n        str: The string representation of the GradientRule\"\"\"\n    return f\"Rule&lt;{self.title!r}, {self.characters!r}&gt;\"\n</code></pre>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>The rich renderable method for the GradientRule class.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>The console instance.</p> required <code>options</code> <code>ConsoleOptions</code> <p>The console options.</p> required <p>Returns:</p> Name Type Description <code>RenderResult</code> <code>RenderResult</code> <p>The renderable result of the GradientRule class.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def __rich_console__(\n    self, console: Console, options: ConsoleOptions) -&gt; RenderResult:\n    \"\"\"The rich renderable method for the GradientRule class.\n\n    Args:\n        console (Console): The console instance.\n        options (ConsoleOptions): The console options.\n\n    Returns:\n        RenderResult: The renderable result of the GradientRule class.\n    \"\"\"\n    width = options.max_width\n\n    characters = (\n        \"-\"\n        if (options.ascii_only and not self.characters.isascii())\n        else self.characters\n    )\n\n    chars_len = cell_len(characters)\n    if not self.title:\n        color_list = Spectrum(5)\n        yield Gradient(\n            self._rule_line(chars_len, width),\n            colors=[\n                color_list[0],\n                color_list[1],\n                color_list[2],\n                color_list[3],\n                color_list[4],\n            ],\n        )\n        return\n\n    if isinstance(self.title, Text):\n        self.title_text: Text = self.title\n    else:\n        self.title_text = console.render_str(self.title, style=\"rule.text\")\n\n    self.title_text.plain = self.title_text.plain.replace(\"\\n\", \" \")\n    self.title_text.expand_tabs()\n\n    required_space = 4 if self.align == \"center\" else 2\n    truncate_width = max(0, width - required_space)\n\n    # / No Title\n    if not truncate_width:\n        yield self._rule_line(chars_len, width)\n        return\n\n    rule_text = Text(end=self.end)\n    if self.align == \"center\":\n        rule_text = self.center_rule(rule_text, truncate_width, chars_len, width)\n    elif self.align == \"left\":\n        self.title_text.truncate(truncate_width, overflow=\"ellipsis\")\n        rule_text.append(self.title_text)\n        rule_text.append(\" \")\n        if self.gradient:\n            rule_text.append(\n                Gradient(\n                    characters * (width - self.title_text.cell_len - 1),\n                    colors=self.right_colors,  # type: ignore\n                )\n            )\n        else:\n            rule_text.append(characters * (width - rule_text.cell_len))\n    elif self.align == \"right\":\n        self.title_text.truncate(truncate_width, overflow=\"ellipsis\")\n        rule_text.append(\n            Gradient(\n                characters * (width - self.title_text.cell_len - 1),\n                colors=self.left_colors,  # type: ignore\n            )\n        )\n        rule_text.append(\" \")\n        rule_text.append(self.title_text)\n\n    rule_text.plain = set_cell_size(rule_text.plain, width)\n    yield rule_text\n</code></pre>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.__rich_measure__","title":"<code>__rich_measure__(console, options)</code>","text":"<p>The rich measure method for the GradientRule class.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>The console instance.</p> required <code>options</code> <code>ConsoleOptions</code> <p>The console options.</p> required <p>Returns:</p> Name Type Description <code>Measurement</code> <code>Measurement</code> <p>The measurement of the GradientRule class.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def __rich_measure__(\n    self, console: Console, options: ConsoleOptions) -&gt; Measurement:\n    \"\"\"The rich measure method for the GradientRule class.\n\n    Args:\n        console (Console): The console instance.\n        options (ConsoleOptions): The console options.\n\n    Returns:\n        Measurement: The measurement of the GradientRule class.\"\"\"\n    return Measurement(1, 1)\n</code></pre>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.center_rule","title":"<code>center_rule(rule_text, truncate_width, chars_len, width)</code>","text":"<p>Generate a centered rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule_text</code> <code>Text</code> <p>Text of the rule.</p> required <code>truncate_width</code> <code>int</code> <p>Width of the truncated rule.</p> required <code>chars_len</code> <code>int</code> <p>Width of the rule characters.</p> required <code>width</code> <code>int</code> <p>Width of the rule.</p> required <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>The centered rule</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def center_rule(\n    self,\n    rule_text: Text,\n    truncate_width: int,\n    chars_len: int,\n    width: int) -&gt; Text:\n    \"\"\"Generate a centered rule.\n\n    Args:\n        rule_text (Text): Text of the rule.\n        truncate_width (int): Width of the truncated rule.\n        chars_len (int): Width of the rule characters.\n        width (int): Width of the rule.\n\n    Returns:\n        Text: The centered rule\n    \"\"\"\n    if rule_text is None:\n        rule_text = Text()\n    self.title_text.truncate(truncate_width, overflow=\"ellipsis\")\n    self.side_width: int = (width - cell_len(self.title_text.plain)) // 2\n    if self.gradient:\n        rule_text.append(\n            Gradient(\n                self.characters * (self.side_width // chars_len + 1),\n                colors=self.left_colors,  # type: ignore\n                end=\"\",\n            )\n        )\n    else:\n        rule_text.append(\n            Text(self.characters * (self.side_width // chars_len + 1), end=\"\")\n        )\n    rule_text.append(\" \")\n    rule_text.append(self.title_text)\n    rule_text.append(\" \")\n    if self.gradient:\n        rule_text.append(\n            Gradient(\n                self.characters * (self.side_width // chars_len + 1),\n                colors=self.right_colors,  # type: ignore\n                end=\" \",\n            )\n        )\n    else:\n        rule_text.append(\n            Text(self.characters * (self.side_width // chars_len + 1), end=\" \")\n        )\n    rule_text.truncate(width)\n    return rule_text\n</code></pre>"},{"location":"gradient_rule_ref/#rich_gradient.rule.GradientRule.rule_example","title":"<code>rule_example(save=False)</code>  <code>classmethod</code>","text":"<p>Create a console with examples of Rule.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool</code> <p>Save the console output to an SVG file. Defaults to False.</p> <code>False</code> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>@classmethod\ndef rule_example(cls, save: bool = False) -&gt; None:\n    \"\"\"Create a console with examples of Rule.\n\n    Args:\n        save (bool, optional): Save the console output to an SVG file. Defaults to False.\"\"\"\n    import sys\n\n    from rich_gradient.theme import GRADIENT_TERMINAL_THEME\n    from rich.console import Console\n\n    try:\n        title: str = sys.argv[1]\n    except IndexError:\n        title = \"Rule Example\"\n\n    console = Console(width=60, record=True)\n\n    console.line(2)\n    console.print(\"[u b #ffffff]Rule Examples[/]\", justify=\"center\")\n    console.line()\n    # console.print(\"[dim]Gradient Rule without a title \u2b07\ufe0e[/]\", justify=\"center\")\n    console.print(GradientRule(title=f\"{title}\", thickness=\"thin\", align=\"left\"))\n    console.line()\n    console.print(\n        GradientRule(\n            title=\"Thin Gradient Rule\",\n            gradient=True,\n            thickness=\"thin\",\n            align=\"center\",\n        )\n    )\n    console.line()\n    console.print(\n        GradientRule(title=\"Medium Gradient Rule\", gradient=True, align=\"right\")\n    )\n    console.line()\n    console.print(\n        GradientRule(\n            title=\"Medium Left-aligned Non-gradient Rule\",\n            gradient=False,\n            thickness=\"medium\",\n            align=\"left\",\n        )\n    )\n    console.line()\n    console.print(\n        GradientRule(title=\"Medium Right-aligned Gradient Rule\", align=\"right\")\n    )\n    console.line()\n    console.print(GradientRule(\"Thick Gradient Rule\", thickness=\"thick\"))\n    console.line(2)\n    console.save_svg(\n        path=\"docs/img/rule_example.svg\",\n        title=\"rich-gradient\",\n        theme=GRADIENT_TERMINAL_THEME\n    )\n</code></pre>"}]}