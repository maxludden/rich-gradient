{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#purpose","title":"Purpose","text":"<p><code>rich-gradient</code> layers smooth foreground and background gradients on top of rich renderables. It includes a drop-in <code>Text</code> subclass, wrappers for <code>Panel</code> and <code>Rule</code>, utilities for building palettes, and a Click/rich-click CLI for trying gradients from the terminal.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Works anywhere Rich expects a <code>ConsoleRenderable</code>, including panels, tables, and live updates.</li> <li>Generates color stops automatically or from CSS color names, hex codes, RGB tuples, or <code>rich.color.Color</code> objects.</li> <li>Supports foreground and background gradients, rainbow palettes, and deterministic color spectrums.</li> <li>Ships with ready-to-use renderables:<ul> <li><code>Text</code></li> <li><code>Gradient</code></li> <li><code>Panel</code></li> <li><code>Rule</code></li> <li><code>Spectrum</code></li> <li>And their animated counterparts.</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"uv (recommended) <pre><code>uv add rich-gradient\n</code></pre> <p>or via <code>uv pip</code></p> <pre><code>uv pip install rich-gradient\n</code></pre> <p></p> <p>...or with pip:</p> pip <pre><code># via pip\npip install rich-gradient\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>from rich.console import Console\nfrom rich_gradient import Text\n\nconsole = Console()\nconsole.print(\n    Text(\n        \"Rich gradients with almost no setup.\",\n        colors=[\"#38bdf8\", \"#a855f7\", \"#f97316\"],\n        style=\"bold\",\n        justify=\"center\",\n    )\n)\n</code></pre> <p>The example above is bundled in <code>examples/text_quickstart.py</code> and renders:</p> <p> </p>"},{"location":"#explore-the-user-guide","title":"Explore the user guide","text":"<ul> <li>Text \u2013 gradient-aware drop-in replacement for <code>rich.text.Text</code>.</li> <li>Gradient \u2013 wrap any renderable with foreground/background gradients.</li> <li>Panel \u2013 gradient panels with highlighted titles and subtitles.</li> <li>Rule \u2013 gradient horizontal rules with adjustable thickness.</li> <li>Spectrum \u2013 generate and preview deterministic palettes.</li> <li>Animation \u2013 create animated gradients with <code>Live</code>.</li> </ul> <p>Prefer API-level details? See the reference section generated with <code>mkdocstrings</code>.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#v0311-2026-02-10-highlight-configs-cli-refactor-gradientrule-fixes","title":"v0.3.11 - 2026-02-10 | Highlight configs, CLI refactor, Gradient/Rule fixes","text":""},{"location":"CHANGELOG/#added-changed","title":"Added / Changed","text":"<ul> <li>Added explicit highlight configuration helpers (<code>HighlightWords</code>, <code>HighlightRegex</code>) and updated <code>Gradient</code> to accept the new highlight inputs.</li> <li>Refactored CLI command structure and removed deprecated CLI command modules/files.</li> <li>Improved documentation and examples to cover the new highlighting workflow.</li> <li>Added <code>GradientTheme</code> tests and tightened gradient test coverage (including single background color handling).</li> <li>See rich-gradient-cli for the new CLI implementation.</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Improved Gradient color parsing and handling of highlight inputs.</li> <li>Corrected Rule thickness/character mapping behavior.</li> <li>Streamlined Text background color parsing and ensured theme initialization is consistent.</li> </ul>"},{"location":"CHANGELOG/#v0310-2026-01-04-animatedtext-cli-defaults-live-persistence","title":"v0.3.10 - 2026-01-04 | AnimatedText, CLI defaults, Live persistence","text":""},{"location":"CHANGELOG/#added-changed_1","title":"Added / Changed","text":"<ul> <li>Added <code>AnimatedText</code> for live gradient <code>rich.text.Text</code>, plus <code>update_text</code> helpers, package export, reference docs, and an example script.</li> <li>AnimatedGradient family (<code>AnimatedGradient</code>, <code>AnimatedPanel</code>, <code>AnimatedMarkdown</code>, <code>AnimatedRule</code>) no longer clears the console on stop; unless <code>transient=True</code>, the final gradient render persists.</li> <li>CLI defaults to the <code>print</code> command when no subcommand is provided and can read input from stdin.</li> <li> <p>For example:</p> <p><code>echo \"Hello, World!\" | rich-gradient</code></p> </li> <li> <p>Docs refreshed to note the behavior.</p> </li> <li>Animation/text guides and the mkdocs navigation now include AnimatedText coverage.</li> <li>Added tests for AnimatedText behavior and CLI default/stdin handling.</li> </ul>"},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Silenced <code>rich-color-ext</code> <code>get_css_map</code> type checker mismatch for older releases.</li> </ul>"},{"location":"CHANGELOG/#v039-2025-12-15-cli-doc-refresh-importtest-stability-css-fix","title":"v0.3.9 - 2025-12-15 | CLI doc refresh, import/test stability, CSS fix","text":""},{"location":"CHANGELOG/#added-changed_2","title":"Added / Changed","text":"<ul> <li>CLI docs and README now describe the Click + rich-click subcommands (<code>print</code>, <code>panel</code>, <code>rule</code>, <code>markdown</code>) with current options and examples; removed stale Typer references.</li> <li>CLI option help text across commands uses the rich markup formatting introduced in <code>text_command.py</code> for consistent help output.</li> <li>Contributor note documents that <code>pytest</code> runs without an editable install because <code>tests/conftest.py</code> adds <code>src/</code> to <code>sys.path</code>.</li> <li>Documentation CSS now anchors <code>html, body</code> to the theme background to avoid a black flash/transparent top before styles load.</li> </ul>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Test collection no longer fails with <code>ModuleNotFoundError: rich_gradient</code> when the package isn't installed editable, thanks to the path shim in <code>tests/conftest.py</code>.</li> </ul>"},{"location":"CHANGELOG/#v037-2025-10-24-documentation-refresh-reproducible-assets-cli-polish","title":"v0.3.7 - 2025-10-24 |  Documentation refresh, reproducible assets &amp; CLI polish","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Docs<ul> <li>New user-guide pages for panels, the CLI, and animation (<code>docs/panel.md</code>, <code>docs/cli.md</code>, <code>docs/animation.md</code>) linked from the main navigation.</li> <li>API reference stubs for <code>AnimatedPanel</code> and <code>Panel</code> via <code>mkdocstrings</code>.</li> <li>Hero quick-start, palette, background, panel, rule, spectrum, and CLI images generated from checked-in example scripts.</li> </ul> </li> <li>Examples<ul> <li>Added reproducible scripts under <code>examples/</code> to render all user-guide screenshots, including quick-start <code>Text</code>, palette variations, background gradients, gradient/table showcases, panel gallery, rule gallery, spectrum table, CLI help, and updated <code>hello_world.py</code>.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Docs<ul> <li>Rewrote the landing page plus Text, Gradient, Rule, and Spectrum guides for clearer positioning and accurate option coverage.</li> <li>Updated index code snippets to import <code>Text</code> from the package root and refreshed installation guidance.</li> <li>Refined <code>docs/animated_gradient_ref.md</code> to point at the public module path.</li> <li>Regenerated SVG/GIF assets with consistent naming (e.g., <code>hello_world.svg</code>, <code>text-quickstart.svg</code>, <code>gradient-panel.svg</code>, <code>cli-help.svg</code>) and removed legacy images.</li> </ul> </li> <li>Library<ul> <li>Exported <code>Text</code> from <code>rich_gradient/__init__.py</code> so examples, docs, and the CLI can rely on the top-level import.</li> </ul> </li> <li>Tooling<ul> <li>Expanded <code>mkdocs.yml</code> navigation to surface the new pages and verified the build with <code>uv run mkdocs build</code>.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Docs<ul> <li>Dropped the obsolete <code>base_gradient_ref.md</code> page and deprecated image assets that the refreshed guides no longer reference.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#v036-2025-09-10-consolidated-gradient-rng-fix-gamma-correct-text-docstests","title":"v0.3.6 - 2025-09-10 |  Consolidated Gradient, RNG fix, gamma-correct Text, docs/tests","text":""},{"location":"CHANGELOG/#added-changed_3","title":"Added / Changed","text":"<ul> <li>Gradient<ul> <li>Consolidated to a single public factory (<code>rich_gradient.gradient.Gradient</code>) that returns <code>BaseGradient</code> or <code>AnimatedGradient</code> internally.</li> <li>Kept test helper methods by adding equivalents to <code>BaseGradient</code> (<code>_color_at</code>, <code>_styled</code>, <code>_interpolated_color</code>) and <code>_active_stops</code> initialization.</li> <li>Added <code>background=</code> support to <code>BaseGradient</code>/<code>AnimatedGradient</code> for parity with previous API.</li> </ul> </li> <li>Text<ul> <li>Interpolates colors with gamma-correct blending for visual consistency with <code>Gradient</code>.</li> </ul> </li> <li>Spectrum<ul> <li>Uses a dedicated <code>random.Random(seed)</code> instance to avoid mutating global RNG state; behavior is deterministic per seed without side effects.</li> </ul> </li> <li>Rule<ul> <li>Normalized invalid color errors to <code>ValueError</code> for consistency.</li> </ul> </li> <li>Package Init<ul> <li>Centralized <code>rich-color-ext</code> install to package init; removed duplicate installs from other modules.</li> </ul> </li> <li>Repo Hygiene<ul> <li>Removed committed build artifacts (<code>dist/</code>) and static site (<code>site/</code>) from source; they remain in <code>.gitignore</code>.</li> </ul> </li> <li>Docs / Examples / Tests<ul> <li>README basic example fixed (missing parenthesis).</li> <li>Benchmark test now measures actual console printing safely.</li> </ul> </li> <li>CLI<ul> <li>Relaxed <code>--justify</code> and <code>--overflow</code> option annotations from <code>Literal[...]</code> to <code>str</code> with explicit validation for broader Typer/Click compatibility.</li> <li>Pinned dependencies to stabilize CLI behavior: <code>typer&gt;=0.12.5,&lt;0.13</code> and <code>click&gt;=8.1.7,&lt;9.0.0</code>.</li> </ul> </li> <li>Tests<ul> <li>Made CLI tests portable across Click/Typer versions by removing <code>mix_stderr</code> usage and accepting warnings from stdout or stderr.</li> </ul> </li> <li>Cleanup<ul> <li>Removed duplicate internal <code>Gradient</code> factory leftover in <code>_animated_gradient.py</code>; the public factory now lives in <code>rich_gradient/gradient.py</code>.</li> </ul> </li> <li>Docs<ul> <li>Added _base_gradient_ref.md for referencing BaseGradient</li> <li>Added _animated_gradient_ref.md for referencing AnimatedGradient</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Eliminated duplicate Gradient implementations that could drift out of sync.</li> <li>Avoided global RNG seeding in <code>Spectrum</code> that could affect host applications.</li> </ul>"},{"location":"CHANGELOG/#v034-2025-09-03-textas_rich-background-gradients-spectrum-docs","title":"v0.3.4 - 2025-09-03 | Text.as_rich(), background gradients, spectrum + docs","text":""},{"location":"CHANGELOG/#v034-added","title":"v0.3.4 Added","text":"<ul> <li>Text</li> <li><code>.as_rich()</code> method to return a plain <code>rich.text.Text</code> with all spans/styles preserved.</li> <li><code>.rich</code> convenience property wrapping <code>as_rich()</code>.</li> <li>Background gradients via <code>bgcolors=</code>; multiple bg stops interpolate alongside foreground.</li> <li>Robust color normalization supporting <code>Color</code>, <code>ColorTriplet</code>, <code>(r,g,b)</code> tuples, CSS names, 3/6\u2011digit hex, and <code>rgb()</code> strings.</li> <li>Spectrum</li> <li>Deterministic <code>seed</code>, color names, styles, hex accessors, and a rich preview table renderable.</li> <li>Docs/Examples</li> <li>New SVG/PNG assets for gradient text examples under <code>docs/img/v0.3.4/</code> and updated spectrum preview.</li> </ul>"},{"location":"CHANGELOG/#v034-updated","title":"v0.3.4 Updated","text":"<ul> <li>Text</li> <li>Improved error types/messages and comprehensive module documentation.</li> <li>Single\u2011color fast\u2011path applies one composed <code>Style</code> across content for performance.</li> <li>Empty text rendering no longer emits a trailing newline/segment; nested renderables filtered accordingly.</li> <li>Gradient and BaseGradient</li> <li>Gamma\u2011corrected color interpolation, smoother stop wrapping, explicit alignment validation, and safer measurement when no renderables.</li> <li>Support for <code>repeat_scale</code>/<code>phase</code> used by animated variants.</li> <li>Rule</li> <li>Accepts colors as strings, <code>Color</code>, <code>ColorTriplet</code>, or RGB tuples with clearer validation and messages.</li> <li>Title style applied after gradient generation for accurate highlighting.</li> <li>Package Init / Theme</li> <li>Install <code>rich-color-ext</code> on import and monkey\u2011patch <code>Console._collect_renderables</code> to suppress empty <code>Text</code> trailing newline.</li> <li>Theme helpers for consistent docs SVG generation (<code>GRADIENT_TERMINAL_THEME</code>).</li> <li>README/Docs</li> <li>Expanded examples and color\u2011format visuals; refreshed links and images.</li> </ul>"},{"location":"CHANGELOG/#v034-fixed","title":"v0.3.4 Fixed","text":"<ul> <li>Suppressed stray newline output when rendering empty gradient <code>Text</code> (affects console capture/recorded SVGs).</li> </ul>"},{"location":"CHANGELOG/#v033-2025-08-27-added-tests-and-fixed-bugs","title":"v0.3.3 - 2025-08-27 |  Added tests and Fixed Bugs","text":""},{"location":"CHANGELOG/#v033-updated","title":"v0.3.3 Updated","text":"<ul> <li>Enhanced rendering and color handling in gradient components</li> <li>Refactored rich-gradient for improved structure and functionality</li> <li>Reorganized imports in <code>__init__.py</code> for clarity.</li> <li>Updated AnimatedGradient to ensure color extension is installed at package import time.</li> <li>Enhanced BaseGradient to improve gradient wrapping logic and error handling.</li> <li>Improved logger utility with better error handling and configuration options.</li> <li>Adjusted Gradient class to ensure quit panel behavior is consistent and intuitive.</li> <li>Added comprehensive tests for edge cases in Gradient and Text classes, including long text, unicode handling, and color validation.</li> <li>Enhanced Spectrum class to support color generation with optional seed for reproducibility.</li> <li>Improved Text class to ensure proper initialization and color parsing.</li> <li>Updated test suites for Gradient and Spectrum to cover additional scenarios and edge cases.</li> </ul>"},{"location":"CHANGELOG/#v032-added-tests-and-fixed-bugs","title":"v0.3.2  Added tests and Fixed Bugs","text":""},{"location":"CHANGELOG/#v032-removed","title":"v0.3.2 Removed","text":"<ul> <li>Dev Dependencies</li> <li><code>snoop</code></li> <li><code>cheap-repr</code></li> </ul>"},{"location":"CHANGELOG/#v032-updated","title":"v0.3.2 Updated","text":"<ul> <li>Removed instances that were imported from:</li> <li><code>snoop</code><ul> <li><code>@snoop()</code></li> </ul> </li> <li><code>cheap-repr</code><ul> <li><code>register_repr(f\"{class})(normal_repr)</code></li> </ul> </li> <li>Renamed GradientRule -&gt; Rule</li> <li>to match the naming of the other modules in <code>rich-gradient</code></li> </ul>"},{"location":"CHANGELOG/#v032-added","title":"v0.3.2 Added","text":"<ul> <li>Tests</li> <li><code>tests/benchmark_perf.py</code>: To benchmark the performance of generating gradients that span large amounts of characters.</li> <li><code>tests/test_edge_cases.py</code>: To cover edge cases that may otherwise break <code>rich-gradient</code>.</li> </ul>"},{"location":"CHANGELOG/#v030-2025-06-20-working-rewrite","title":"v0.3.0 - 2025-06-20 |  Working Rewrite","text":""},{"location":"CHANGELOG/#v030-added","title":"v0.3.0 Added","text":"<ul> <li>Validated working and added tests for:</li> <li><code>rich_gradient.text.Text</code></li> <li><code>rich_gradient.gradient.Gradient</code></li> <li><code>rich_gradient.rule.GradientRule</code></li> <li><code>rich_gradient.spectrum.Spectrum</code></li> <li><code>rich-color-ext</code> acting as adequate replacement for previous color logic</li> <li>Added examples directory containing:</li> <li><code>animated_gradient_example.py</code></li> <li><code>gradient_example.py</code></li> <li><code>hello_world.py</code></li> <li><code>rainbow_gradient.py</code></li> <li><code>specific_color_gradient.py</code></li> <li><code>text_markup.py</code></li> <li><code>two_color_gradients.py</code></li> <li>Generated updated exports for examples for documentation (still in the works)</li> </ul>"},{"location":"CHANGELOG/#v030-updated","title":"v0.3.0 Updated","text":"<ul> <li><code>docs/index.md</code></li> </ul>"},{"location":"CHANGELOG/#v030-todo","title":"v0.3.0 TODO","text":"<ul> <li>Update Documentation</li> <li>Expand Tests</li> <li>Work on Gradient Panel and Table Renderables</li> </ul>"},{"location":"CHANGELOG/#v030-removed","title":"v0.3.0 Removed","text":"<p>Removed all of the the archived modules from rich_gradient/archive/*</p>"},{"location":"CHANGELOG/#v021-rewrite","title":"v0.2.1 Rewrite","text":"<p>There was a lot of overhead in rich-gradient so I rewrote it from the ground up with an actual goal. I created rich-color-ext to wrap around rich's color parsing removing the need for the<code>_rgb.py</code>, <code>color.py</code>, <code>color_data.py</code>, <code>_colors.py</code>, and all of their tests.</p>"},{"location":"CHANGELOG/#v020-2025-3-13-uv-pure-python-and-3132","title":"v0.2.0 - 2025-3-13 | uv, pure python, and 3.13.2","text":"<p>There are a number of significant changes in v0.2.0:</p>"},{"location":"CHANGELOG/#rye-uv","title":"<code>rye</code> \u2192 <code>uv</code>","text":"<p>Astral has done a hell of a job making python dev tools. ruff blew the existing python linters out of the water and uv pretty much did the same thing to package managers. Rich-gradient was started on rye but as Astral has since depreciated it, it's moved to their current rust powered python package manager, uv.</p>"},{"location":"CHANGELOG/#pure-python","title":"Pure Python","text":"<p>Rich-gradient is now a pure-python package. This allows it to be more easily used regardless of platform. As rich-gradient previously had pydantic as a dependency, it now just borrows the logic from <code>pydantic-extra-types.color</code>.</p>"},{"location":"CHANGELOG/#3132","title":"3.13.2","text":"<p>After switching to uv, the package has been updated to python 3.13.2.</p>"},{"location":"CHANGELOG/#v020-updated","title":"v0.2.0 Updated","text":"<ul> <li>Switched rich-gradient package manager from astral/rye to astral/uv</li> <li>Updated python to <code>3.13.2</code></li> </ul>"},{"location":"CHANGELOG/#v020-changed","title":"v0.2.0 Changed","text":"<ul> <li>Removed <code>pydantic</code> and <code>pydantic-extra-types</code> dependencies.</li> <li>Updated the names of some of the colors. For example greenyellow became lawngreen.</li> <li>Updated <code>README.md</code>, <code>CHANGELOG</code>, and documentation.</li> </ul>"},{"location":"CHANGELOG/#v020-added","title":"v0.2.0 Added","text":"<ul> <li><code>src/rich_gradient/_base_color.py</code>: stores the color logic from pydantic-extra-types.color modules stripped of the pydantic framwork.</li> </ul>"},{"location":"CHANGELOG/#v017-2024-7-16-added-support-for-two-color-gradients","title":"v0.1.7 - 2024-7-16 | Added support for Two-Color Gradients","text":""},{"location":"CHANGELOG/#v017-updated","title":"v0.1.7 Updated","text":"<ul> <li>Updated Gradient.generate_subgradients() to default to returning a list containing a single simple gradient to allow Gradients to work when only supplied with two colors.</li> </ul>"},{"location":"CHANGELOG/#v017-added","title":"v0.1.7 Added","text":"<ul> <li>Added len, int, str, and repr dunder methods to <code>rich-gradient.gradient.Gradient</code> (will simply refer to as <code>Gradient</code> from here on out).</li> <li>Added a tests/test_gradient.py for Gradient to test two color gradiets</li> </ul>"},{"location":"CHANGELOG/#v016-2024-6-28-updated-rev","title":"v0.1.6 - 2024-6-28 | Updated Rev","text":"<ul> <li>Updated rev to 0.1.6.</li> </ul>"},{"location":"CHANGELOG/#v015-2024-6-28-added-tests","title":"v0.1.5 - 2024-6-28 | Added Tests","text":""},{"location":"CHANGELOG/#v015-updated","title":"v0.1.5 Updated","text":"<ul> <li>Updated requirements for minimum versions of python from 3.8 -&gt; 3.10.</li> <li>Added <code>pytest</code> to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v015-added","title":"v0.1.5 Added","text":"<ul> <li>Tests for:</li> <li>Color</li> <li>Specturm</li> <li>SimpleGradient</li> </ul>"},{"location":"CHANGELOG/#v014-2024-6-28-resolved-dependancies","title":"v0.1.4 | 2024-6-28 | Resolved Dependancies","text":""},{"location":"CHANGELOG/#v014-updated","title":"v0.1.4 Updated","text":"<ul> <li>This release is primarily to prune unnecessary dependancies.</li> <li>Removed <code>numpy</code> to avoid issues of <code>numpy</code> version 2.0.0 conflicting with <code>torch</code>.</li> </ul>"},{"location":"CHANGELOG/#v013-2021-10-10","title":"v0.1.3 - 2021-10-10","text":""},{"location":"CHANGELOG/#v013-fixed","title":"v0.1.3 Fixed","text":"<ul> <li>Updated README to use GitHub pages for example gradient image.</li> </ul>"},{"location":"CHANGELOG/#v012-2021-10-10","title":"v0.1.2 - 2021-10-10","text":""},{"location":"CHANGELOG/#v012-updated","title":"v0.1.2 Updated","text":"<ul> <li>Updated PyProject.toml description.</li> <li>Moved MKDocs and related dependancies to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v012-fixed","title":"v0.1.2 Fixed","text":"<ul> <li>Updated README to use GitHub pages for banner image.</li> <li>Updated README to use GitHub pages for docs url.</li> </ul>"},{"location":"CHANGELOG/#v011-2021-10-10","title":"v0.1.1 - 2021-10-10","text":""},{"location":"CHANGELOG/#v011-fixed","title":"v0.1.1 Fixed","text":"<ul> <li>Updated README to use GitHub pages for images.</li> </ul>"},{"location":"CHANGELOG/#v010-2021-10-10","title":"v0.1.0 - 2021-10-10","text":"<p>Initial release. Based off of MaxGradient with a simplified color model based on pydantic-extra-types.color.Color. Re-released as rich-gradient to avoid confusion with MaxGradient.</p>"},{"location":"animated_gradient_ref/","title":"Animated Gradient Reference","text":""},{"location":"animated_gradient_ref/#animatedgradient","title":"AnimatedGradient","text":"<p>               Bases: <code>Gradient</code></p> <p>A gradient that animates over time using <code>rich.live.Live</code>.</p> <p>Parameters:</p> Name Type Description Default <code>renderables</code> <code>Optional[List[ConsoleRenderable]]</code> <p>Renderables to apply the gradient to.</p> <code>None</code> <code>colors</code> <code>Optional[List[ColorType]]</code> <p>Foreground color stops for the gradient.</p> <code>None</code> <code>bg_colors</code> <code>Optional[List[ColorType]]</code> <p>Background color stops for the gradient.</p> <code>None</code> <code>hues</code> <code>int</code> <p>Number of hues when auto-generating colors. Defaults to 5.</p> <code>5</code> <code>rainbow</code> <code>bool</code> <p>Generate a rainbow gradient instead of using <code>colors</code>. Defaults to False.</p> <code>False</code> <code>repeat_scale</code> <code>float</code> <p>Stretch color stops across a wider span. Defaults to 4.0.</p> <code>4.0</code> <code>expand</code> <code>bool</code> <p>Expand to fill console width/height. Defaults to False.</p> <code>True</code> <code>justify</code> <code>AlignMethod</code> <p>Horizontal justification. Defaults to \"left\".</p> <code>'left'</code> <code>vertical_justify</code> <code>VerticalAlignMethod</code> <p>Vertical justification. Defaults to \"top\".</p> <code>'top'</code> <code>console</code> <code>Optional[Console]</code> <p>Console to use for rendering. Defaults to the global console.</p> <code>None</code> <code>highlight_words</code> <code>Mapping[Any, Any] | Sequence[Any] | None</code> <p>Optional configurations for word highlighting.</p> <code>None</code> <code>highlight_regex</code> <code>Mapping[Any, Any] | Sequence[Any] | None</code> <p>Optional configurations for regex highlighting.</p> <code>None</code> <code>redirect_stdout</code> <code>bool</code> <p>Redirect stdout to Live. Defaults to False.</p> <code>False</code> <code>redirect_stderr</code> <code>bool</code> <p>Redirect stderr to Live. Defaults to False.</p> <code>False</code> <code>auto_refresh</code> <code>bool</code> <p>Automatically refresh the Live context. Defaults to True.</p> <code>True</code> <code>refresh_per_second</code> <code>float</code> <p>Refresh rate for the Live context. Defaults to 20.0.</p> <code>30.0</code> <code>animate</code> <code>bool | None</code> <p>Whether to animate. When <code>None</code> (default), the global configuration is used. Set to <code>False</code> to disable live updates explicitly.</p> <code>None</code> <code>duration</code> <code>Optional[float]</code> <p>Optional duration for automatic stop when running animations.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ag = AnimatedGradient(renderables=[\"Hello\"], rainbow=True)\n&gt;&gt;&gt; ag.run()  # blocks until Ctrl+C\n</code></pre> <p>Or as a context manager:</p> <pre><code>&gt;&gt;&gt; with AnimatedGradient(renderables=[\"Hi\"], rainbow=True) as ag:\n...     time.sleep(2)\n</code></pre> Source code in <code>src/rich_gradient/animated_gradient.py</code> <pre><code>class AnimatedGradient(Gradient):\n    \"\"\"A gradient that animates over time using `rich.live.Live`.\n\n    Args:\n        renderables (Optional[List[ConsoleRenderable]]): Renderables to apply the gradient to.\n        colors (Optional[List[ColorType]]): Foreground color stops for the gradient.\n        bg_colors (Optional[List[ColorType]]): Background color stops for the gradient.\n        hues (int): Number of hues when auto-generating colors. Defaults to 5.\n        rainbow (bool): Generate a rainbow gradient instead of using ``colors``. Defaults to False.\n        repeat_scale (float): Stretch color stops across a wider span. Defaults to 4.0.\n        expand (bool): Expand to fill console width/height. Defaults to False.\n        justify (AlignMethod): Horizontal justification. Defaults to \"left\".\n        vertical_justify (VerticalAlignMethod): Vertical justification. Defaults to \"top\".\n        console (Optional[Console]): Console to use for rendering. Defaults to the global console.\n        highlight_words: Optional configurations for word highlighting.\n        highlight_regex: Optional configurations for regex highlighting.\n        redirect_stdout (bool): Redirect stdout to Live. Defaults to False.\n        redirect_stderr (bool): Redirect stderr to Live. Defaults to False.\n        auto_refresh (bool): Automatically refresh the Live context. Defaults to True.\n        refresh_per_second (float): Refresh rate for the Live context. Defaults to 20.0.\n        animate (bool | None): Whether to animate. When ``None`` (default), the global\n            configuration is used. Set to ``False`` to disable live updates explicitly.\n        duration (Optional[float]): Optional duration for automatic stop when running animations.\n\n    Examples:\n        &gt;&gt;&gt; ag = AnimatedGradient(renderables=[\"Hello\"], rainbow=True)\n        &gt;&gt;&gt; ag.run()  # blocks until Ctrl+C\n\n        Or as a context manager:\n        &gt;&gt;&gt; with AnimatedGradient(renderables=[\"Hi\"], rainbow=True) as ag:\n        ...     time.sleep(2)\n    \"\"\"\n\n    def __init__(\n        self,\n        renderables: Optional[List[ConsoleRenderable] | ConsoleRenderable | str] = None,\n        # color args\n        colors: Optional[List[ColorType]] = None,\n        bg_colors: Optional[List[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n        repeat_scale: float = 4.0,\n        # layout args\n        expand: bool = True,\n        justify: AlignMethod = \"left\",\n        vertical_justify: VerticalAlignMethod = \"top\",\n        highlight_words: Mapping[Any, Any] | Sequence[Any] | None = None,\n        highlight_regex: Mapping[Any, Any] | Sequence[Any] | None = None,\n        # live args\n        console: Optional[Console] = None,\n        redirect_stdout: bool = False,\n        redirect_stderr: bool = False,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 30.0,\n        transient: bool = False,\n        animate: Optional[bool] = None,\n        duration: Optional[float] = None,\n    ) -&gt; None:\n        self.animate = self.get_animated(animate)\n        assert refresh_per_second &gt; 0, \"refresh_per_second must be greater than 0\"\n        self._lock = RLock()\n\n        # Live must exist before we set / forward console\n        self.live: Live = Live(\n            console=console or get_console(),\n            auto_refresh=auto_refresh,\n            refresh_per_second=refresh_per_second,\n            transient=transient,\n            redirect_stdout=redirect_stdout,\n            redirect_stderr=redirect_stderr,\n        )\n        self.auto_refresh = auto_refresh\n        self.transient = transient\n        self.refresh_per_second = refresh_per_second\n        self.expand = expand\n        if duration is not None:\n            if duration &lt;= 0:\n                raise ValueError(\"duration must be greater than 0\")\n            self.duration: Optional[float] = float(duration)\n        else:\n            self.duration = None\n\n        # Fixed phase advance per second mirrors the legacy default of \u22480.12 cycles/sec.\n        self._phase_per_second = FPS\n\n        # Thread / control flags\n        self._running: bool = False\n        self._thread: Optional[Thread] = None\n        self._stop_event: Event = Event()\n        self._live_active: bool = False\n        self._deadline: Optional[float] = None\n\n        # Initialise Gradient (this sets _renderables, colors, etc.)\n        super().__init__(\n            renderables=renderables or [],\n            colors=colors,\n            bg_colors=bg_colors,\n            console=self.live.console,\n            hues=hues,\n            rainbow=rainbow,\n            expand=expand,\n            justify=justify,\n            vertical_justify=vertical_justify,\n            repeat_scale=repeat_scale,\n            highlight_words=highlight_words,\n            highlight_regex=highlight_regex,\n            animated=self.animate,\n        )\n        self._cycle = 0.0\n\n        # Convenience bound methods\n        self.print: Callable[..., None] = self.console.print\n        self.log: Callable[..., None] = self.console.log\n\n    # -----------------\n    # Console forwarding\n    # -----------------\n    @property\n    def live_console(self) -&gt; Console:\n        \"\"\"Get the console used by the Live instance.\"\"\"\n        return self.live.console\n\n    @live_console.setter\n    def live_console(self, value: Console) -&gt; None:\n        \"\"\"Set the console used by the Live instance.\"\"\"\n        self.live.console = value\n\n    # -----------------\n    # Animation control\n    # -----------------\n    def start(self) -&gt; None:\n        \"\"\"Start the Live context and the animation loop in a background thread.\"\"\"\n        if self._running or self._live_active:\n            return\n        if not self.animate:\n            # Static render: render one frame via Live so transient behaviour matches Rich.\n            self.live.start()\n            self._live_active = True\n            with self._lock:\n                renderable = self.get_renderable()\n            self.live.update(renderable, refresh=True)\n            self.live.stop()\n            self._live_active = False\n            return\n        self._running = True\n        self.live.start()\n        self._live_active = True\n        if self.duration is not None:\n            self._deadline = time.monotonic() + self.duration\n        else:\n            self._deadline = None\n        self._thread = Thread(target=self._animate, daemon=True)\n        self._thread.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"Signal the animation to stop, wait for the thread, and close Live.\"\"\"\n        if not self._live_active and not self._running:\n            return\n        self._running = False\n        self._stop_event.set()\n        if self._thread is not None:\n            self._thread.join(timeout=2.0)\n            self._thread = None\n        if self._live_active:\n            self.live.stop()\n            self._live_active = False\n        self._deadline = None\n\n    def run(self) -&gt; None:\n        \"\"\"Blocking helper: start, then wait for Ctrl+C, then stop.\"\"\"\n        # Install a temporary SIGINT handler so Ctrl+C will immediately\n        # attempt to stop the animation and close the Live console cleanly.\n        previous_handler = signal.getsignal(signal.SIGINT)\n\n        def _sigint_handler(_signum, _frame):\n            # Stop animation and ensure Live is closed. Keep handler small\n            # and defensive to avoid raising from signal context.\n            try:\n                self.stop()\n            except (RuntimeError, OSError):\n                pass\n\n        signal.signal(signal.SIGINT, _sigint_handler)\n\n        try:\n            self.start()\n            if not self.animate:\n                if self.duration:\n                    time.sleep(self.duration)\n                return\n            while self._running and not self._stop_event.is_set():\n                time.sleep(0.1)\n        except KeyboardInterrupt:\n            # If KeyboardInterrupt is raised, ensure we stop cleanly.\n            self.stop()\n        finally:\n            # Restore the previous SIGINT handler and ensure Live is stopped.\n            try:\n                signal.signal(signal.SIGINT, previous_handler)\n            except (ValueError, OSError):\n                pass\n            self.stop()\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        self.stop()\n        return False\n\n    # -----------------\n    # Live renderable\n    # -----------------\n    def get_renderable(self) -&gt; ConsoleRenderable:\n        \"\"\"Return the renderable the Live instance should display each frame.\"\"\"\n        with self._lock:\n            if not self.renderables:\n                raise AssertionError(\"No renderables set for the gradient\")\n\n            return Align(\n                self,\n                align=self.justify,\n                vertical=cast(VerticalAlignMethod, self.vertical_justify),\n                width=self.console.width if self.expand else None,\n                height=self.console.height if self.expand else None,\n                pad=self.expand,\n            )\n\n    def _animate(self) -&gt; None:\n        \"\"\"Run the animation loop, updating at the requested FPS until stopped.\"\"\"\n        try:\n            with suppress(KeyboardInterrupt):\n                frame_time = 1.0 / self.refresh_per_second\n                while not self._stop_event.is_set():\n                    # Advance the gradient phase (guarded by lock to avoid\n                    # race conditions with the render path).\n                    deadline = self._deadline\n                    with self._lock:\n                        self._cycle += self._phase_per_second * frame_time\n                        self.phase = self._cycle\n                        _renderable = self.get_renderable()\n\n                    # Push an update to Live. If auto_refresh is True, rely on\n                    # Live's own auto refresh; otherwise request an explicit\n                    # refresh via update(refresh=True).\n                    if self.auto_refresh:\n                        self.live.update(_renderable, refresh=False)\n                    else:\n                        self.live.update(_renderable, refresh=True)\n                    if deadline is not None and time.monotonic() &gt;= deadline:\n                        self._stop_event.set()\n                        break\n                    # Sleep but remain responsive to stop_event\n                    self._stop_event.wait(frame_time)\n            self.live.stop()\n        except KeyboardInterrupt:\n            self.live.stop()\n\n    def get_animated(self, animate: Optional[bool] = None) -&gt; bool:\n        \"\"\"Return whether animation is enabled.\"\"\"\n        if animate is None:\n            return config.animation_enabled\n        return bool(animate)\n</code></pre>"},{"location":"animated_gradient_ref/#rich_gradient.animated_gradient.AnimatedGradient.live_console","title":"<code>live_console</code>  <code>property</code> <code>writable</code>","text":"<p>Get the console used by the Live instance.</p>"},{"location":"animated_gradient_ref/#rich_gradient.animated_gradient.AnimatedGradient.get_animated","title":"<code>get_animated(animate=None)</code>","text":"<p>Return whether animation is enabled.</p> Source code in <code>src/rich_gradient/animated_gradient.py</code> <pre><code>def get_animated(self, animate: Optional[bool] = None) -&gt; bool:\n    \"\"\"Return whether animation is enabled.\"\"\"\n    if animate is None:\n        return config.animation_enabled\n    return bool(animate)\n</code></pre>"},{"location":"animated_gradient_ref/#rich_gradient.animated_gradient.AnimatedGradient.get_renderable","title":"<code>get_renderable()</code>","text":"<p>Return the renderable the Live instance should display each frame.</p> Source code in <code>src/rich_gradient/animated_gradient.py</code> <pre><code>def get_renderable(self) -&gt; ConsoleRenderable:\n    \"\"\"Return the renderable the Live instance should display each frame.\"\"\"\n    with self._lock:\n        if not self.renderables:\n            raise AssertionError(\"No renderables set for the gradient\")\n\n        return Align(\n            self,\n            align=self.justify,\n            vertical=cast(VerticalAlignMethod, self.vertical_justify),\n            width=self.console.width if self.expand else None,\n            height=self.console.height if self.expand else None,\n            pad=self.expand,\n        )\n</code></pre>"},{"location":"animated_gradient_ref/#rich_gradient.animated_gradient.AnimatedGradient.run","title":"<code>run()</code>","text":"<p>Blocking helper: start, then wait for Ctrl+C, then stop.</p> Source code in <code>src/rich_gradient/animated_gradient.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Blocking helper: start, then wait for Ctrl+C, then stop.\"\"\"\n    # Install a temporary SIGINT handler so Ctrl+C will immediately\n    # attempt to stop the animation and close the Live console cleanly.\n    previous_handler = signal.getsignal(signal.SIGINT)\n\n    def _sigint_handler(_signum, _frame):\n        # Stop animation and ensure Live is closed. Keep handler small\n        # and defensive to avoid raising from signal context.\n        try:\n            self.stop()\n        except (RuntimeError, OSError):\n            pass\n\n    signal.signal(signal.SIGINT, _sigint_handler)\n\n    try:\n        self.start()\n        if not self.animate:\n            if self.duration:\n                time.sleep(self.duration)\n            return\n        while self._running and not self._stop_event.is_set():\n            time.sleep(0.1)\n    except KeyboardInterrupt:\n        # If KeyboardInterrupt is raised, ensure we stop cleanly.\n        self.stop()\n    finally:\n        # Restore the previous SIGINT handler and ensure Live is stopped.\n        try:\n            signal.signal(signal.SIGINT, previous_handler)\n        except (ValueError, OSError):\n            pass\n        self.stop()\n</code></pre>"},{"location":"animated_gradient_ref/#rich_gradient.animated_gradient.AnimatedGradient.start","title":"<code>start()</code>","text":"<p>Start the Live context and the animation loop in a background thread.</p> Source code in <code>src/rich_gradient/animated_gradient.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the Live context and the animation loop in a background thread.\"\"\"\n    if self._running or self._live_active:\n        return\n    if not self.animate:\n        # Static render: render one frame via Live so transient behaviour matches Rich.\n        self.live.start()\n        self._live_active = True\n        with self._lock:\n            renderable = self.get_renderable()\n        self.live.update(renderable, refresh=True)\n        self.live.stop()\n        self._live_active = False\n        return\n    self._running = True\n    self.live.start()\n    self._live_active = True\n    if self.duration is not None:\n        self._deadline = time.monotonic() + self.duration\n    else:\n        self._deadline = None\n    self._thread = Thread(target=self._animate, daemon=True)\n    self._thread.start()\n</code></pre>"},{"location":"animated_gradient_ref/#rich_gradient.animated_gradient.AnimatedGradient.stop","title":"<code>stop()</code>","text":"<p>Signal the animation to stop, wait for the thread, and close Live.</p> Source code in <code>src/rich_gradient/animated_gradient.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Signal the animation to stop, wait for the thread, and close Live.\"\"\"\n    if not self._live_active and not self._running:\n        return\n    self._running = False\n    self._stop_event.set()\n    if self._thread is not None:\n        self._thread.join(timeout=2.0)\n        self._thread = None\n    if self._live_active:\n        self.live.stop()\n        self._live_active = False\n    self._deadline = None\n</code></pre>"},{"location":"animated_panel_ref/","title":"AnimatedPanel Reference","text":"<p>               Bases: <code>AnimatedGradient</code></p> <p>Animated variant of :class:<code>rich_gradient.panel.Panel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>renderable</code> <code>RenderableType</code> <p>The renderable to display inside the panel.</p> required <code>colors</code> <code>Optional[List[ColorType]]</code> <p>Optional foreground color stops for the gradient. [cli option: <code>-c</code>, <code>--colors</code>]</p> <code>None</code> <code>bg_colors</code> <code>Optional[List[ColorType]]</code> <p>Optional background color stops for the gradient. [cli option: <code>-C</code>, <code>--bg-colors</code>]</p> <code>None</code> <code>hues</code> <code>int</code> <p>Number of hues to generate when auto-selecting colors. [cli option: <code>--hues</code>]</p> <code>5</code> <code>rainbow</code> <code>bool</code> <p>If True, ignore <code>colors</code> and use a rainbow gradient. [cli option: <code>-r</code>, <code>--rainbow</code>]</p> <code>False</code> <code>repeat_scale</code> <code>float</code> <p>Stretch factor for gradient color stops. Higher values produce a more gradual gradient. [cli option: <code>--repeat-scale</code>]</p> <code>4.0</code> <code>title</code> <code>Optional[Text | Text | TextType]</code> <p>Optional panel title renderable. [cli option: <code>-t</code>, <code>--title</code>]</p> <code>None</code> <code>title_align</code> <code>AlignMethod</code> <p>Alignment for the title text. Defaults to <code>\"center\"</code>. [cli option: <code>--title-align</code>]</p> <code>'center'</code> <code>title_style</code> <code>StyleType</code> <p>Style applied to the highlighted title text. [cli option: <code>--title-style</code>]</p> <code>'bold'</code> <code>subtitle</code> <code>Optional[Text | Text | TextType]</code> <p>Optional panel subtitle renderable. [cli option: <code>-s</code>, <code>--subtitle</code>]</p> <code>None</code> <code>subtitle_align</code> <code>AlignMethod</code> <p>Alignment for the subtitle text. Defaults to <code>\"right\"</code>. [cli option: <code>--subtitle-align</code>]</p> <code>'right'</code> <code>subtitle_style</code> <code>StyleType</code> <p>Style applied to the highlighted subtitle text. [cli option: <code>--subtitle-style</code>]</p> <code>''</code> <code>border_style</code> <code>StyleType</code> <p>Border style for the Rich panel. [cli option: <code>--border-style</code>]</p> <code>''</code> <code>justify</code> <code>AlignMethod</code> <p>Horizontal justification applied to the animated gradient. [cli option: <code>--justify</code>]</p> <code>'left'</code> <code>vertical_justify</code> <code>VerticalAlignMethod</code> <p>Vertical justification applied to the animated gradient. [cli option: <code>-V</code>, <code>--vertical-justify</code>]</p> <code>'middle'</code> <code>box</code> <code>Box</code> <p>Rich box style for the panel border. Defaults to :data:<code>ROUNDED</code>. [cli option: <code>-b</code>, <code>--box</code>]</p> <code>ROUNDED</code> <code>padding</code> <code>Union[int, tuple[int, int], tuple[int, int, int, int]]</code> <p>Panel padding. Can be a single integer or a tuple of up to four integers. [cli option: <code>-p</code>,<code>--padding</code>]</p> <code>(0, 1)</code> <code>expand</code> <code>bool</code> <p>Whether the panel expands to available width. [cli option: <code>-e</code>, <code>--expand</code>]</p> <code>True</code> <code>style</code> <code>StyleType</code> <p>Base style for panel content. [cli option: <code>--style</code>]</p> <code>''</code> <code>width</code> <code>Optional[int]</code> <p>Optional explicit panel width. [cli option: <code>--width</code>]</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>Optional explicit panel height. [cli option: <code>--height</code>]</p> <code>None</code> <code>safe_box</code> <code>bool</code> <p>Use \u201csafe\u201d box characters if True. [cli option: <code>--safe-box</code>]</p> <code>False</code> <code>highlight_words</code> <code>Optional[HighlightWordsType]</code> <p>Word highlight configuration forwarded to the gradient. [cli option: <code>-w</code>, <code>--highlight-words</code>]</p> <code>None</code> <code>highlight_regex</code> <code>Optional[HighlightRegexType]</code> <p>Regex highlight configuration forwarded to the gradient. [cli option:  <code>-H</code>, <code>--highlight-regex</code>]</p> <code>None</code> <code>auto_refresh</code> <code>bool</code> <p>Whether <code>Live</code> refreshes automatically. [cli option: <code>--auto-refresh</code>]</p> <code>True</code> <code>refresh_per_second</code> <code>(optional, float)</code> <p>Target frames per second. Defaults to 20.0 [cli option: <code>--rps</code>]</p> <code>20.0</code> <code>console</code> <code>Optional[Console]</code> <p>Explicit console to render to. Defaults to None. [cli option: <code>--console</code>]</p> <code>None</code> <code>transient</code> <code>(optional, bool)</code> <p>Leave the screen clear after stopping if True. [cli option: <code>-T</code>,<code>--transient</code>]</p> <code>False</code> <code>redirect_stdout</code> <code>bool</code> <p>Redirect stdout into the Live console. [cli option: <code>--redirect-stdout</code>]</p> <code>False</code> <code>redirect_stderr</code> <code>bool</code> <p>Redirect stderr into the Live console. [cli option: <code>--redirect-stderr</code>]</p> <code>False</code> <code>animate</code> <code>bool | None</code> <p>Toggle animation on or off. <code>None</code> defers to the global configuration.</p> <code>None</code> <code>duration</code> <code>Optional[float]</code> <p>Optional duration in seconds for automatic stop.</p> <code>None</code> Source code in <code>src/rich_gradient/animated_panel.py</code> <pre><code>class AnimatedPanel(AnimatedGradient):\n    \"\"\"Animated variant of :class:`rich_gradient.panel.Panel`.\n\n    Args:\n        renderable: The renderable to display inside the panel.\n        colors: Optional foreground color stops for the gradient.\n            [cli option: `-c`, `--colors`]\n        bg_colors: Optional background color stops for the gradient.\n            [cli option: `-C`, `--bg-colors`]\n        hues: Number of hues to generate when auto-selecting colors.\n            [cli option: `--hues`]\n        rainbow: If True, ignore `colors` and use a rainbow gradient.\n            [cli option: `-r`, `--rainbow`]\n        repeat_scale: Stretch factor for gradient color stops. Higher values produce\n            a more gradual gradient. [cli option: `--repeat-scale`]\n        title: Optional panel title renderable. [cli option: `-t`, `--title`]\n        title_align: Alignment for the title text. Defaults to ``\"center\"``.\n            [cli option: `--title-align`]\n        title_style: Style applied to the highlighted title text.\n            [cli option: `--title-style`]\n        subtitle: Optional panel subtitle renderable. [cli option: `-s`, `--subtitle`]\n        subtitle_align: Alignment for the subtitle text. Defaults to `\"right\"`.\n            [cli option: `--subtitle-align`]\n        subtitle_style: Style applied to the highlighted subtitle text.\n            [cli option: `--subtitle-style`]\n        border_style: Border style for the Rich panel. [cli option: `--border-style`]\n        justify: Horizontal justification applied to the animated gradient.\n            [cli option: `--justify`]\n        vertical_justify: Vertical justification applied to the animated gradient.\n            [cli option: `-V`, `--vertical-justify`]\n        box: Rich box style for the panel border. Defaults to :data:`ROUNDED`.\n            [cli option: `-b`, `--box`]\n        padding: Panel padding. Can be a single integer or a tuple of up to four integers.\n            [cli option: `-p`,`--padding`]\n        expand: Whether the panel expands to available width. [cli option: `-e`, `--expand`]\n        style: Base style for panel content. [cli option: `--style`]\n        width: Optional explicit panel width. [cli option: `--width`]\n        height: Optional explicit panel height. [cli option: `--height`]\n        safe_box: Use \u201csafe\u201d box characters if True. [cli option: `--safe-box`]\n        highlight_words: Word highlight configuration forwarded to the gradient.\n            [cli option: `-w`, `--highlight-words`]\n        highlight_regex: Regex highlight configuration forwarded to the gradient.\n            [cli option:  `-H`, `--highlight-regex`]\n        auto_refresh: Whether `Live` refreshes automatically.\n            [cli option: `--auto-refresh`]\n        refresh_per_second (optional, float): Target frames per second. Defaults to 20.0\n            [cli option: `--rps`]\n        console (Optional[Console]): Explicit console to render to. Defaults to None.\n            [cli option: `--console`]\n        transient (optional, bool): Leave the screen clear after stopping if True.\n            [cli option: `-T`,`--transient`]\n        redirect_stdout: Redirect stdout into the Live console.\n            [cli option: `--redirect-stdout`]\n        redirect_stderr: Redirect stderr into the Live console.\n            [cli option: `--redirect-stderr`]\n\n        animate (bool | None): Toggle animation on or off. ``None`` defers to the\n            global configuration.\n        duration: Optional duration in seconds for automatic stop.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: RenderableType,\n        colors: Optional[List[ColorType]] = None,\n        bg_colors: Optional[List[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n        repeat_scale: float = 4.0,\n\n        # layout args\n        expand: bool = True,\n        justify: AlignMethod = \"left\",\n        vertical_justify: VerticalAlignMethod = \"middle\",\n        highlight_words: Optional[HighlightWordsType] = None,\n        highlight_regex: Optional[HighlightRegexType] = None,\n        border_style: StyleType = \"\",\n        box: Box = ROUNDED,\n        padding: Union[int, tuple[int, int], tuple[int, int, int, int]] = (0, 1),\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        style: StyleType = \"\",\n        title: Optional[Text | RichText | TextType] = None,\n        title_align: AlignMethod = \"center\",\n        title_style: StyleType = \"bold\",\n        subtitle: Optional[Text | RichText | TextType] = None,\n        subtitle_align: AlignMethod = \"right\",\n        subtitle_style: StyleType = \"\",\n        safe_box: bool = False,\n\n        # live args\n        console: Optional[Console] = None,\n        redirect_stdout: bool = False,\n        redirect_stderr: bool = False,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 20.0,\n        transient: bool = False,\n        animate: Optional[bool] = None,\n        duration: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Initialize AnimatedPanel instance. See class docstring for details.\"\"\"\n        panel = RichPanel(\n            renderable,\n            title=title,\n            title_align=title_align,\n            subtitle=subtitle,\n            subtitle_align=subtitle_align,\n            border_style=border_style,\n            box=box,\n            padding=padding,\n            expand=expand,\n            style=style,\n            width=width,\n            height=height,\n            safe_box=safe_box,\n        )\n\n        # Track underlying panel so expand setter on Gradient can propagate\n        # changes to the Rich Panel instance.\n        self._panel = panel\n\n        highlight_list = self._combine_highlight_regex(\n            highlight_regex, title, title_style, subtitle, subtitle_style, box\n        )\n\n        super().__init__(\n            renderables=panel,\n            colors=colors,\n            bg_colors=bg_colors,\n            auto_refresh=auto_refresh,\n            refresh_per_second=refresh_per_second,\n            console=console,\n            transient=transient,\n            redirect_stdout=redirect_stdout,\n            redirect_stderr=redirect_stderr,\n            expand=expand,\n            justify=justify,\n            vertical_justify=vertical_justify,\n            hues=hues,\n            rainbow=rainbow,\n            repeat_scale=repeat_scale,\n            highlight_words=highlight_words,\n            highlight_regex=highlight_list,\n            animate=animate,\n            duration=duration,\n        )\n        self._panel = panel\n\n    @property\n    def panel(self) -&gt; RichPanel:\n        \"\"\"Access the underlying Rich panel renderable.\"\"\"\n        return self._panel\n\n    @staticmethod\n    def _combine_highlight_regex(\n        highlight_regex: Optional[HighlightRegexType],\n        title: Optional[RenderableType],\n        title_style: StyleType,\n        subtitle: Optional[RenderableType],\n        subtitle_style: StyleType,\n        box: Box,\n    ) -&gt; Sequence[tuple[Any, StyleType, int]]:\n        \"\"\"Merge user-provided regex highlights with title/subtitle highlights.\"\"\"\n        if highlight_regex is None:\n            highlight_list: list[tuple[Any, StyleType, int]] = []\n        elif isinstance(highlight_regex, Mapping):\n            highlight_list = [\n                (pattern, style, 0) for pattern, style in highlight_regex.items()\n            ]\n        else:\n            highlight_list = list(highlight_regex)\n\n        if title:\n            title_regex = AnimatedPanel._get_title_regex(box)\n            logger.debug(\"AnimatedPanel title regex: %s\", title_regex)\n            highlight_list.append((title_regex, title_style or \"bold\", 0))\n        if subtitle:\n            subtitle_regex = AnimatedPanel._get_subtitle_regex(box)\n            logger.debug(\"AnimatedPanel subtitle regex: %s\", subtitle_regex)\n            highlight_list.append((subtitle_regex, subtitle_style, 0))\n\n        return highlight_list\n\n    @staticmethod\n    def _get_title_regex(box: Box) -&gt; str:\n        \"\"\"Generate the regex used to highlight the title row.\"\"\"\n        top_left = escape(box.top_left)\n        top = escape(box.top)\n        top_right = escape(box.top_right)\n        return rf\"{top_left}{top}+ (.*?) {top}+{top_right}\"\n\n    @staticmethod\n    def _get_subtitle_regex(box: Box) -&gt; str:\n        \"\"\"Generate the regex used to highlight the subtitle row.\"\"\"\n        bottom_left = escape(box.bottom_left)\n        bottom = escape(box.bottom)\n        bottom_right = escape(box.bottom_right)\n        return rf\"{bottom_left}{bottom}+ (.*?) {bottom}+{bottom_right}\"\n</code></pre>"},{"location":"animated_panel_ref/#rich_gradient.animated_panel.AnimatedPanel.panel","title":"<code>panel</code>  <code>property</code>","text":"<p>Access the underlying Rich panel renderable.</p>"},{"location":"animated_panel_ref/#rich_gradient.animated_panel.AnimatedPanel.__init__","title":"<code>__init__(renderable, colors=None, bg_colors=None, hues=5, rainbow=False, repeat_scale=4.0, expand=True, justify='left', vertical_justify='middle', highlight_words=None, highlight_regex=None, border_style='', box=ROUNDED, padding=(0, 1), width=None, height=None, style='', title=None, title_align='center', title_style='bold', subtitle=None, subtitle_align='right', subtitle_style='', safe_box=False, console=None, redirect_stdout=False, redirect_stderr=False, auto_refresh=True, refresh_per_second=20.0, transient=False, animate=None, duration=None)</code>","text":"<p>Initialize AnimatedPanel instance. See class docstring for details.</p> Source code in <code>src/rich_gradient/animated_panel.py</code> <pre><code>def __init__(\n    self,\n    renderable: RenderableType,\n    colors: Optional[List[ColorType]] = None,\n    bg_colors: Optional[List[ColorType]] = None,\n    hues: int = 5,\n    rainbow: bool = False,\n    repeat_scale: float = 4.0,\n\n    # layout args\n    expand: bool = True,\n    justify: AlignMethod = \"left\",\n    vertical_justify: VerticalAlignMethod = \"middle\",\n    highlight_words: Optional[HighlightWordsType] = None,\n    highlight_regex: Optional[HighlightRegexType] = None,\n    border_style: StyleType = \"\",\n    box: Box = ROUNDED,\n    padding: Union[int, tuple[int, int], tuple[int, int, int, int]] = (0, 1),\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    style: StyleType = \"\",\n    title: Optional[Text | RichText | TextType] = None,\n    title_align: AlignMethod = \"center\",\n    title_style: StyleType = \"bold\",\n    subtitle: Optional[Text | RichText | TextType] = None,\n    subtitle_align: AlignMethod = \"right\",\n    subtitle_style: StyleType = \"\",\n    safe_box: bool = False,\n\n    # live args\n    console: Optional[Console] = None,\n    redirect_stdout: bool = False,\n    redirect_stderr: bool = False,\n    auto_refresh: bool = True,\n    refresh_per_second: float = 20.0,\n    transient: bool = False,\n    animate: Optional[bool] = None,\n    duration: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Initialize AnimatedPanel instance. See class docstring for details.\"\"\"\n    panel = RichPanel(\n        renderable,\n        title=title,\n        title_align=title_align,\n        subtitle=subtitle,\n        subtitle_align=subtitle_align,\n        border_style=border_style,\n        box=box,\n        padding=padding,\n        expand=expand,\n        style=style,\n        width=width,\n        height=height,\n        safe_box=safe_box,\n    )\n\n    # Track underlying panel so expand setter on Gradient can propagate\n    # changes to the Rich Panel instance.\n    self._panel = panel\n\n    highlight_list = self._combine_highlight_regex(\n        highlight_regex, title, title_style, subtitle, subtitle_style, box\n    )\n\n    super().__init__(\n        renderables=panel,\n        colors=colors,\n        bg_colors=bg_colors,\n        auto_refresh=auto_refresh,\n        refresh_per_second=refresh_per_second,\n        console=console,\n        transient=transient,\n        redirect_stdout=redirect_stdout,\n        redirect_stderr=redirect_stderr,\n        expand=expand,\n        justify=justify,\n        vertical_justify=vertical_justify,\n        hues=hues,\n        rainbow=rainbow,\n        repeat_scale=repeat_scale,\n        highlight_words=highlight_words,\n        highlight_regex=highlight_list,\n        animate=animate,\n        duration=duration,\n    )\n    self._panel = panel\n</code></pre>"},{"location":"animated_text_ref/","title":"AnimatedText Reference","text":"<p>               Bases: <code>AnimatedGradient</code></p> <p>Animated gradient variant for text content.</p> Source code in <code>src/rich_gradient/animated_text.py</code> <pre><code>class AnimatedText(AnimatedGradient):\n    \"\"\"Animated gradient variant for text content.\"\"\"\n\n    def __init__(\n        self,\n        text: TextSource,\n        *,\n        colors: Optional[Sequence[ColorType]] = None,\n        bg_colors: Optional[Sequence[ColorType]] = None,\n        rainbow: bool = False,\n        hues: int = 5,\n        expand: bool = True,\n        justify: AlignMethod = \"left\",\n        vertical_justify: VerticalAlignMethod = \"top\",\n        repeat_scale: float = 4.0,\n        highlight_words: Optional[HighlightWordsType] = None,\n        highlight_regex: Optional[HighlightRegexType] = None,\n        text_kwargs: Optional[Mapping[str, Any]] = None,\n        markup: bool = True,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 30.0,\n        console: Console = _console,\n        transient: bool = False,\n        redirect_stdout: bool = False,\n        redirect_stderr: bool = False,\n        animate: Optional[bool] = None,\n        duration: Optional[float] = None,\n    ) -&gt; None:\n        renderable = create_text_renderable(\n            text,\n            markup=markup,\n            text_kwargs=text_kwargs,\n        )\n        super().__init__(\n            renderables=renderable,\n            colors=list(colors) if colors is not None else None,\n            bg_colors=list(bg_colors) if bg_colors is not None else None,\n            auto_refresh=auto_refresh,\n            refresh_per_second=refresh_per_second,\n            console=console or Console(),\n            transient=transient,\n            redirect_stdout=redirect_stdout,\n            redirect_stderr=redirect_stderr,\n            expand=expand,\n            justify=justify,\n            vertical_justify=vertical_justify,\n            hues=hues,\n            rainbow=rainbow,\n            repeat_scale=repeat_scale,\n            highlight_words=highlight_words,\n            highlight_regex=highlight_regex,\n            animate=animate,\n            duration=duration,\n        )\n        self._text_kwargs: dict[str, Any] = dict(text_kwargs or {})\n        self._markup = bool(markup)\n\n    @property\n    def rich_text(self) -&gt; RichText:\n        \"\"\"Return the underlying Rich Text renderable.\"\"\"\n        if not self.renderables:\n            raise RuntimeError(\"Text renderables have not been initialised.\")\n        renderable = self.renderables[0]\n        if not isinstance(renderable, RichText):\n            raise TypeError(\"Stored renderable is not a Rich Text instance.\")\n        return renderable\n\n    def update_text(\n        self,\n        text: TextSource,\n        *,\n        text_kwargs: Optional[Mapping[str, Any]] = None,\n        markup: Optional[bool] = None,\n    ) -&gt; None:\n        \"\"\"Replace the Text content safely during animation.\"\"\"\n        with self._lock:\n            if isinstance(text, GradientText):\n                self.renderables = [text.as_rich()]\n                return\n            if isinstance(text, RichText):\n                self.renderables = [text]\n                return\n\n            effective_markup = self._markup if markup is None else bool(markup)\n            effective_kwargs = (\n                self._text_kwargs if text_kwargs is None else dict(text_kwargs)\n            )\n            renderable = create_text_renderable(\n                text,\n                markup=effective_markup,\n                text_kwargs=effective_kwargs,\n            )\n            self.renderables = [renderable]\n\n            if text_kwargs is not None:\n                self._text_kwargs = dict(text_kwargs)\n            if markup is not None:\n                self._markup = bool(markup)\n</code></pre>"},{"location":"animated_text_ref/#rich_gradient.animated_text.AnimatedText.rich_text","title":"<code>rich_text</code>  <code>property</code>","text":"<p>Return the underlying Rich Text renderable.</p>"},{"location":"animated_text_ref/#rich_gradient.animated_text.AnimatedText.update_text","title":"<code>update_text(text, *, text_kwargs=None, markup=None)</code>","text":"<p>Replace the Text content safely during animation.</p> Source code in <code>src/rich_gradient/animated_text.py</code> <pre><code>def update_text(\n    self,\n    text: TextSource,\n    *,\n    text_kwargs: Optional[Mapping[str, Any]] = None,\n    markup: Optional[bool] = None,\n) -&gt; None:\n    \"\"\"Replace the Text content safely during animation.\"\"\"\n    with self._lock:\n        if isinstance(text, GradientText):\n            self.renderables = [text.as_rich()]\n            return\n        if isinstance(text, RichText):\n            self.renderables = [text]\n            return\n\n        effective_markup = self._markup if markup is None else bool(markup)\n        effective_kwargs = (\n            self._text_kwargs if text_kwargs is None else dict(text_kwargs)\n        )\n        renderable = create_text_renderable(\n            text,\n            markup=effective_markup,\n            text_kwargs=effective_kwargs,\n        )\n        self.renderables = [renderable]\n\n        if text_kwargs is not None:\n            self._text_kwargs = dict(text_kwargs)\n        if markup is not None:\n            self._markup = bool(markup)\n</code></pre>"},{"location":"animation/","title":"Animation","text":"<p><code>rich-gradient</code> provides animated variants of its core renderables for live terminal demos. They build on <code>rich.live.Live</code> to refresh the console at a steady frame rate while shifting the gradient phase.</p>"},{"location":"animation/#animatedgradient","title":"<code>AnimatedGradient</code>","text":"<pre><code>from rich.console import Console\nfrom rich.markdown import Markdown\nfrom rich_gradient.animated_gradient import AnimatedGradient\n\nconsole = Console()\nmarkdown = Markdown(\n    \"[b]Animated gradients[/b]\\n\\n\"\n    \"- Run as a context manager\\n\"\n    \"- Or control start/stop manually\\n\"\n)\n\nwith AnimatedGradient(\n    markdown,\n    rainbow=True,\n    console=console,\n) as gradient:\n    console.input(\"[dim]Press Enter to stop...[/dim]\")\n</code></pre> <p>Key parameters:</p> <ul> <li><code>refresh_per_second</code>: desired frame rate for the <code>Live</code> render loop.</li> <li><code>repeat_scale</code>: stretch the palette across a wider span before repeating.</li> <li><code>highlight_words</code> / <code>highlight_regex</code>: identical to the static <code>Gradient</code>.</li> <li><code>start()</code>, <code>stop()</code>, <code>run()</code>: manual control when you want to integrate with custom event loops.</li> <li>Defaults honour the global configuration; see Configuration for details.</li> </ul>"},{"location":"animation/#animatedtext","title":"<code>AnimatedText</code>","text":"<p><code>AnimatedText</code> gives you the same gradient animation on top of Rich <code>Text</code>, with a helper to swap content while the animation is running.</p> <pre><code>from time import sleep\nfrom rich_gradient.animated_text import AnimatedText\n\nanimated = AnimatedText(\"Loading...\", rainbow=True)\n\nwith animated:\n    sleep(1)\n    animated.update_text(\"Almost there...\")\n    sleep(1)\n</code></pre> <p>CLI demo:</p> <pre><code>uv run python examples/animated_text_demo.py\n</code></pre>"},{"location":"animation/#animatedpanel","title":"<code>AnimatedPanel</code>","text":"<p><code>AnimatedPanel</code> wraps the static <code>Panel</code> helper, so it inherits title and subtitle highlighting alongside the animation controls above.</p> <pre><code>from rich.panel import Panel as RichPanel\nfrom rich_gradient.animated_panel import AnimatedPanel\n\npanel = RichPanel(\n    \"Rainbow [i]AnimatedPanel[/i] in motion\",\n    title=\"Animated Panel\",\n    padding=(1, 2),\n)\n\nanimated = AnimatedPanel(\n    panel,\n    rainbow=True,\n    refresh_per_second=40,\n)\ntry:\n    animated.run()\nfinally:\n    animated.stop()\n</code></pre> <p>Both animated classes forward <code>console</code>, <code>expand</code>, <code>justify</code>, and color configuration to their static counterparts, making it easy to switch between live demos and static output.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#configuration","title":"Configuration","text":"<p>rich-gradient automatically discovers a small configuration file that lives alongside your shell environment. The loader recognises JSON, TOML, and YAML documents, and searches the following paths in order:</p> <ol> <li><code>$HOME/.config/.rich-gradient</code></li> <li><code>$HOME/local/bin/.rich-gradient</code></li> <li><code>$HOME/.rich-gradient</code></li> </ol> <p>Note The first path that exists wins. A personalised file in <code>$HOME/.config/.rich-gradient.{json,toml,yaml}</code> overrides the default that is bootstrapped in <code>$HOME/.rich-gradient</code>.</p>"},{"location":"configuration/#default-bootstrap","title":"Default bootstrap","text":"<p>On first import, rich-gradient writes a default JSON document to <code>$HOME/.rich-gradient</code> (or to the directory pointed at by <code>RICH_GRADIENT_CONFIG_HOME</code> if the environment variable is set \u2013 handy for tests and ephemeral environments). The file looks like this:</p> <pre><code>{\n  \"executable_path\": \"/path/to/rich-gradient\",\n  \"animation_enabled\": true,\n  \"spectrum_colors\": [\n    \"#FF0000\",\n    \"#FF5500\",\n    \"#FF9900\",\n    \"... trimmed for brevity ...\"\n  ]\n}\n</code></pre> <ul> <li><code>executable_path</code> records the CLI that should be invoked for helper tooling.</li> <li><code>animation_enabled</code> acts as the global kill-switch for animation. Setting the   flag to <code>false</code> forces every animated helper (<code>AnimatedGradient</code>, <code>AnimatedPanel</code>,   etc.) to start in static mode unless you explicitly pass <code>animate=True</code>.</li> <li><code>spectrum_colors</code> seeds the default colour palette and mirrors the manual   values hard-coded inside <code>Spectrum</code>.</li> </ul>"},{"location":"configuration/#environment-export","title":"Environment export","text":"<p>After the configuration is loaded, the following environment variables are exported so that sub-processes and CLI wrappers can reuse the settings:</p> Variable Meaning <code>RICH_GRADIENT_CONFIG_PATH</code> Absolute path to the file that was loaded. <code>RICH_GRADIENT_EXECUTABLE_PATH</code> Path stored in <code>executable_path</code>. <code>RICH_GRADIENT_ANIMATION_ENABLED</code> <code>\"1\"</code> when animation is enabled, else <code>\"0\"</code>. <code>RICH_GRADIENT_SPECTRUM_COLORS</code> Comma separated list of configured colours."},{"location":"configuration/#format-support","title":"Format support","text":"<p>rich-gradient determines which parser to use from the file suffix:</p> Suffix Parser none / <code>.json</code> Python <code>json</code> module <code>.toml</code> <code>tomllib</code> (or <code>tomli</code> when installed) <code>.yaml</code>/<code>.yml</code> PyYAML (install <code>pyyaml</code> to enable this) <p>If you prefer YAML or TOML, create one of the supported files in <code>$HOME/.config/</code> or <code>$HOME/local/bin/</code> and rich-gradient will pick it up on the next import. The bootstrapped JSON in <code>$HOME/.rich-gradient</code> acts as a safe fallback and is never overwritten once created.</p>"},{"location":"gradient/","title":"Gradient","text":"<p><code>rich_gradient.Gradient</code> wraps any Rich renderable\u2014text, panels, tables, Markdown, even nested layouts\u2014and paints a gradient across the composed output. It works with foreground and background colors, respects alignment, and can highlight words or regex matches along the way.</p>"},{"location":"gradient/#quick-example","title":"Quick example","text":"<pre><code>from rich.console import Console\nfrom rich.markdown import Markdown\nfrom rich_gradient import Gradient\n\nconsole = Console()\nmarkdown = Markdown(\n    \"\"\"\n## Gradient panels\n\n- Wrap any renderable: tables, markdown, syntax.\n- Highlight sections with `highlight_words` or regex.\n- Combine with Rich's layout primitives.\n\"\"\".strip()\n)\nconsole.print(\n    Gradient(\n        markdown,\n        colors=[\"#38bdf8\", \"#a855f7\", \"#f97316\"],\n        bg_colors=[\"#0f172a\", \"#2c1067\"],\n        justify=\"center\",\n    )\n)\n</code></pre> <p>The full example lives in <code>examples/gradient_showcase.py</code>.</p>"},{"location":"gradient/#working-with-different-renderables","title":"Working with different renderables","text":"<p><code>Gradient</code> accepts a single renderable or an iterable. Each renderable is measured and interpolated to share the gradient stops, so you can layer panels, tables, and custom objects together.</p> <pre><code>from rich.table import Table\nfrom rich_gradient import Gradient\n\ntable = Table(title=\"Renderables that work with Gradient\", show_header=False)\ntable.add_column(\"Renderable\", style=\"bold\")\ntable.add_column(\"Supported\", justify=\"center\")\nfor item in (\"Text\", \"Panel\", \"Markdown\", \"Columns\", \"Layout\", \"Live updates\"):\n    table.add_row(item, \"[bold green]\u2713[/]\")\n\nGradient(table, rainbow=True, repeat_scale=1.8)\n</code></pre> <p></p> <p>Key options:</p> <ul> <li><code>colors</code> / <code>bg_colors</code>: list of color stops (same rules as <code>Text</code>).</li> <li><code>rainbow</code> and <code>hues</code>: auto-generate palettes.</li> <li><code>justify</code> / <code>vertical_justify</code>: align the renderable inside the gradient frame.</li> <li><code>repeat_scale</code>: stretch or compress the gradient repeats.</li> <li><code>highlight_words</code> / <code>highlight_regex</code>: apply extra styles after the gradient pass.</li> </ul>"},{"location":"gradient/#highlight-configuration-classes","title":"Highlight configuration classes","text":"<p>For larger configurations, you can build highlight rules explicitly with the dataclasses in <code>rich_gradient._highlight</code> and pass them into <code>Gradient</code>.</p> <pre><code>import re\n\nfrom rich.style import Style\nfrom rich_gradient import Gradient\nfrom rich_gradient._highlight import HighlightRegex, HighlightWords\n\nrules_words = [\n    HighlightWords(words=(\"error\", \"warning\"), style=Style.parse(\"bold red\")),\n    HighlightWords(words=(\"hint\",), style=Style.parse(\"italic cyan\"), case_sensitive=False),\n]\n\nrules_regex = [\n    HighlightRegex(pattern=re.compile(r\"\\b\\d+\\b\"), style=Style.parse(\"bold yellow\")),\n]\n\nGradient(\n    \"error 42: warning: retry\",\n    colors=[\"#38bdf8\", \"#a855f7\", \"#f97316\"],\n    highlight_words=rules_words,\n    highlight_regex=rules_regex,\n)\n</code></pre> <p>You can still pass legacy mappings/tuples; <code>HighlightWords.from_config</code> and <code>HighlightRegex.from_config</code> normalize both styles.</p>"},{"location":"gradient/#animation","title":"Animation","text":"<p>Gradients can be animated by advancing the <code>.phase</code> attribute yourself or by using <code>AnimatedGradient</code>. Animated variants manage a <code>rich.live.Live</code> console and update the gradient smoothly without manual bookkeeping.</p>"},{"location":"gradient_ref/","title":"Gradient","text":"<p>               Bases: <code>JupyterMixin</code></p> <p>Initialize a Gradient instance.</p> <p>Parameters:</p> Name Type Description Default <code>renderables</code> <code>str | ConsoleRenderable | List[ConsoleRenderable]</code> <p>A single renderable or list             of renderable objects to which the gradient will be applied.</p> required <code>colors</code> <code>(List[str | ColorTriplet], Optional)</code> <p>list of colors for the gradient foreground.             If omitted and rainbow is False, a spectrum of <code>hues</code> colors is used. Accepts             3-digit hex strings ('#0f0'), 6-digit hex strings ('#00ff00'), and CSS color             names (e.g., 'lime')</p> <code>None</code> <code>bg_colors</code> <code>(str | ColorTriplet | List[str | ColorTriplet], Optional)</code> <p>the background color             or list of colors for the gradient background. Accepts the same formats as             <code>colors</code>. If omitted, no background is applied.</p> <code>None</code> <code>console</code> <code>(Console, Optional)</code> <p>A rich Console to render to. Defaults to <code>rich.get_console()</code>.</p> <code>None</code> <code>hues</code> <code>(int, Optional)</code> <p>the number of hues to generate if no explicit colors are given.             defaults to 5. This parameter is ignored if <code>colors</code> is provided.</p> <code>5</code> <code>rainbow</code> <code>(bool, Optional)</code> <p>If True, ignore <code>colors</code> and use a full spectrum of colors.             defaults to False.</p> <code>False</code> <code>expand</code> <code>(bool, Optional)</code> <p>Whether to expand renderables to the full console width.             defaults to True.</p> <code>True</code> <code>justify</code> <code>str | AlignMethod</code> <p>Horizontal alignment: 'left', 'center', or 'right'.             Defaults to 'left'.</p> <code>'left'</code> <code>vertical_justify</code> <code>str | VerticalAlignMethod</code> <p>Vertical alignment: 'top', 'center', or             'bottom'. Defaults to 'middle'.</p> <code>'middle'</code> <code>repeat_scale</code> <code>(float, Optional)</code> <p>Scale factor controlling gradient repeat span.             defaults to 2.0.</p> <code>2.0</code> <code>highlight_words</code> <code>(HighlightWordsType | HighlightWords | Sequence[HighlightWords], Optional)</code> <p>Optional configurations describing             word highlights to apply. Accepts either a mapping of words to styles, or a             sequence of tuples describing the highlights.</p> <p>Examples: - {'error': 'bold italic red', 'warning': '#FFFF00', 'lime': '#0f0'} - [('error', 'bold red'), (('warning', 'caution'), 'yellow', False)] - [HighlightWords(words=('error',), style=Style(bold=True, color='red'))]</p> <code>None</code> <code>highlight_regex</code> <code>(HighlightRegexType | HighlightRegex | Sequence[HighlightRegex], Optional)</code> <p>Optional configurations describing regex highlights to apply. Accepts either             a mapping of regex patterns to styles, or a sequence of tuples describing             the highlights.</p> <p>Examples: - {r'\berror\b': 'bold italic red', r'warning|caution': '#FFFF00'} - [(r'\berror\b', 'bold red'), (r'warning|caution', 'yellow')] - [HighlightRegex(pattern=r'\berror\b', style=Style(bold=True, color='red'))]</p> <code>None</code> <code>animated</code> <code>(bool, Optional)</code> <p>Whether the gradient is animated. Defaults to False.</p> <code>False</code> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>class Gradient(JupyterMixin):\n    \"\"\"Initialize a Gradient instance.\n\n    Args:\n        renderables (str|ConsoleRenderable|List[ConsoleRenderable]): A single renderable or list \\\n            of renderable objects to which the gradient will be applied.\n        colors (List[str|ColorTriplet], Optional): list of colors for the gradient foreground. \\\n            If omitted and rainbow is False, a spectrum of `hues` colors is used. Accepts \\\n            3-digit hex strings ('#0f0'), 6-digit hex strings ('#00ff00'), and CSS color \\\n            names (e.g., 'lime')\n        bg_colors(str|ColorTriplet|List[str|ColorTriplet], Optional): the background color \\\n            or list of colors for the gradient background. Accepts the same formats as \\\n            `colors`. If omitted, no background is applied.\n        console(rich.console.Console, Optional): A rich Console to render to. Defaults to\n            `rich.get_console()`.\n        hues(int, Optional): the number of hues to generate if no explicit colors are given. \\\n            defaults to 5. This parameter is ignored if `colors` is provided.\n        rainbow(bool, Optional): If True, ignore `colors` and use a full spectrum of colors. \\\n            defaults to False.\n        expand(bool, Optional): Whether to expand renderables to the full console width. \\\n            defaults to True.\n        justify(str|AlignMethod): Horizontal alignment: 'left', 'center', or 'right'. \\\n            Defaults to 'left'.\n        vertical_justify(str|VerticalAlignMethod): Vertical alignment: 'top', 'center', or \\\n            'bottom'. Defaults to 'middle'.\n        repeat_scale(float, Optional): Scale factor controlling gradient repeat span. \\\n            defaults to 2.0.\n        highlight_words(HighlightWordsType|HighlightWords|Sequence[HighlightWords]\\\n            , Optional): Optional configurations describing \\\n            word highlights to apply. Accepts either a mapping of words to styles, or a \\\n            sequence of tuples describing the highlights.\n\n            Examples:\n            - {'error': 'bold italic red', 'warning': '#FFFF00', 'lime': '#0f0'}\n            - [('error', 'bold red'), (('warning', 'caution'), 'yellow', False)]\n            - [HighlightWords(words=('error',), style=Style(bold=True, color='red'))]\n\n        highlight_regex(HighlightRegexType|HighlightRegex|Sequence[HighlightRegex], Optional):\n            Optional configurations describing regex highlights to apply. Accepts either \\\n            a mapping of regex patterns to styles, or a sequence of tuples describing \\\n            the highlights.\n\n            Examples:\n            - {r'\\berror\\b': 'bold italic red', r'warning|caution': '#FFFF00'}\n            - [(r'\\berror\\b', 'bold red'), (r'warning|caution', 'yellow')]\n            - [HighlightRegex(pattern=r'\\berror\\b', style=Style(bold=True, color='red'))]\n\n        animated(bool, Optional): Whether the gradient is animated. Defaults to False.\n    \"\"\"\n\n    # Gamma correction exponent for linear interpolation\n    _GAMMA_CORRECTION: float = 2.2\n\n    def __init__(\n        self,\n        renderables: str | ConsoleRenderable | List[ConsoleRenderable],\n        colors: Optional[List[ColorType]] = None,\n        bg_colors: Optional[List[ColorType]] = None,\n        *,\n        console: Optional[Console] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n        expand: bool = True,\n        justify: AlignMethod = \"left\",\n        vertical_justify: VerticalAlignMethod = \"middle\",\n        repeat_scale: float = 2.0,\n        highlight_words: Optional[\n            HighlightWordsType | HighlightWords | Sequence[HighlightWords]\n        ] = None,\n        highlight_regex: Optional[\n            HighlightRegexType | HighlightRegex | Sequence[HighlightRegex]\n        ] = None,\n        animated: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a Gradient instance.\n\n        Args:\n            renderables: A single renderable or list of renderable objects to\n                which the gradient will be applied.\n            colors: Optional list of colors (strings, Color, or\n                ColorTriplet) for the gradient foreground. If omitted and\n                rainbow is False, a spectrum of `hues` colors is used.\n            bg_colors: Optional list of colors for the gradient\n                background. If omitted, no background gradient is applied.\n            console: Optional Rich Console to render to. Defaults to\n                `rich.get_console()`.\n            hues: Number of hues to generate if no explicit colors are given.\n            rainbow: If True, ignore `colors` and use a full rainbow.\n            expand: Whether to expand renderables to the full console width.\n            justify: Horizontal alignment: 'left', 'center', or 'right'.\n            vertical_justify: Vertical alignment: 'top', 'center', or 'bottom'.\n            repeat_scale: Scale factor controlling gradient repeat span.\n            highlight_words: Optional configurations describing word highlights to apply.\n            highlight_regex: Optional configurations describing regex highlights to apply.\n        \"\"\"\n        self.console: Console = console or get_console()\n        self.hues: int = max(hues, 2)\n        self.rainbow: bool = rainbow\n        self.repeat_scale: float = repeat_scale\n        self.phase: float = 0.0\n        # Keep a flag if the user requested animated behavior; static\n        # Gradient objects ignore animation but tests may construct with\n        # animated=True, so store the attribute for parity.\n        self.animated: bool = bool(animated)\n        # Backing attribute for expand; use property setter to allow\n        # propagation to wrapped renderables (e.g., Rich Panel instances).\n        self._expand: bool = bool(expand)\n        self.justify = justify\n        self.vertical_justify = vertical_justify\n\n        # Validate and normalize renderables\n        if renderables is None:\n            raise ValueError(\"`renderables` cannot be None...\")\n        if isinstance(renderables, str):\n            self.renderables = [RichText.from_markup(renderables)]\n        elif isinstance(renderables, ConsoleRenderable):\n            self.renderables = [renderables]\n        else:\n            self.renderables = renderables\n\n        # Parse and store color stops\n        foreground_colors: List[ColorType] = list(colors or [])\n        background_colors: List[ColorType] = list(bg_colors or [])\n        self.colors = foreground_colors  # type: ignore[assignment]\n        # Help type-checkers understand the setter accepts ColorType values\n        self.bg_colors = cast(\n            Optional[List[ColorType]], background_colors)  # type: ignore[assignment]\n        self._active_stops = self._initialize_color_stops()\n        self._highlight_rules: list[_HighlightRule] = []\n        self._highlight_map_cache: dict[str, list[Optional[Style]]] = {}\n        if highlight_words is not None:\n            for word_rule in HighlightWords.from_config(highlight_words):\n                self._highlight_rules.append(\n                    _HighlightRule(\n                        kind=\"words\",\n                        words=word_rule.words,\n                        style=word_rule.style,\n                        case_sensitive=word_rule.case_sensitive,\n                    )\n                )\n\n        if highlight_regex is not None:\n            for regex_rule in HighlightRegex.from_config(highlight_regex):\n                self._highlight_rules.append(\n                    _HighlightRule(\n                        kind=\"regex\",\n                        pattern=regex_rule.pattern,\n                        style=regex_rule.style,\n                    )\n                )\n\n        self._invalidate_highlight_cache()\n\n    @property\n    def expand(self) -&gt; bool:\n        \"\"\"Whether the gradient expands to the available width/height.\n\n        This property is stored on the instance and when updated will attempt\n        to propagate the value to common wrapped renderables (for example,\n        a stored Rich Panel under ``self._panel``).\n        \"\"\"\n        return bool(getattr(self, \"_expand\", True))\n\n    @expand.setter\n    def expand(self, value: bool) -&gt; None:\n        self._expand = bool(value)\n        # If we have a tracked underlying Panel-like renderable, try to\n        # propagate the expand flag to it so Rich rendering honors the\n        # intended expansion behavior.\n        # Propagate to any well-known stored renderable attributes.\n        for attr in (\"_panel\", \"_table\", \"_rule\"):\n            obj = getattr(self, attr, None)\n            if obj is not None and hasattr(obj, \"expand\"):\n                try:\n                    setattr(obj, \"expand\", self._expand)\n                except (AttributeError, TypeError):\n                    # Don't propagate failures to avoid breaking rendering.\n                    pass\n\n        # Also attempt best-effort propagation to any renderables we've been\n        # given (e.g., Table, Panel objects inside self._renderables).\n        try:\n            for r in getattr(self, \"_renderables\", []) or []:\n                if hasattr(r, \"expand\"):\n                    try:\n                        setattr(r, \"expand\", self._expand)\n                    except (AttributeError, TypeError):\n                        # Ignore failures when an individual renderable disallows setting expand.\n                        pass\n        except (AttributeError, TypeError):\n            # Defensive: if internal structures are not yet set, ignore.\n            pass\n\n    @property\n    def renderables(self) -&gt; List[ConsoleRenderable]:\n        \"\"\"List of renderable objects to which the gradient is applied.\"\"\"\n        return self._renderables\n\n    @renderables.setter\n    def renderables(self, value: ConsoleRenderable | List[ConsoleRenderable]) -&gt; None:\n        \"\"\"Set and normalize the list of renderables.\"\"\"\n        render_list = value if isinstance(value, list) else [value]\n        normalized: List[ConsoleRenderable] = []\n        for item in render_list:\n            if isinstance(item, str):\n                normalized.append(RichText.from_markup(item))\n            else:\n                normalized.append(item)\n        self._renderables = normalized\n\n    @property\n    def colors(self) -&gt; List[ColorTriplet]:\n        \"\"\"List of parsed ColorTriplet objects for gradient foreground.\"\"\"\n        return self._foreground_colors\n\n    @colors.setter\n    def colors(self, colors: List[ColorType]) -&gt; None:\n        \"\"\"\n        Parse and set the foreground color stops.\n\n        Args:\n            colors: List of color strings, Color, or ColorTriplet.\n        \"\"\"\n        if self.rainbow:\n            triplets = Spectrum().triplets\n        elif not colors:\n            triplets = Spectrum(self.hues).triplets\n        else:\n            triplets = self._to_color_triplets(colors)\n\n        # Loop smoothly by appending reversed middle stops\n        if len(triplets) &gt; 2:\n            # Create an extended list for smooth wrapping; avoid mutating any\n            # external reference by building a new list.\n            extended = triplets + list(reversed(triplets[:-1]))\n            self._foreground_colors = extended\n        else:\n            self._foreground_colors = triplets\n        # Recompute active stops only if background colors have already\n        # been initialized. During __init__ the bg setter runs after this\n        # setter, so avoid accessing unset attributes.\n        if getattr(self, \"_background_colors\", None) is not None:\n            self._active_stops = self._initialize_color_stops()\n\n    @property\n    def bg_colors(self) -&gt; List[ColorTriplet]:\n        \"\"\"List of parsed ColorTriplet objects for gradient background.\"\"\"\n        return self._background_colors\n\n    @bg_colors.setter\n    def bg_colors(self, colors: Optional[List[ColorType]]) -&gt; None:\n        \"\"\"\n        Parse and set the background color stops.\n\n        Args:\n            colors: Optional list of color strings, Color, or ColorTriplet.\n        \"\"\"\n        if not colors:\n            self._background_colors = []\n            # Recompute active stops after change\n            self._active_stops = self._initialize_color_stops()\n            return\n\n        if len(colors) == 1:\n            triplet = self._to_color_triplets([colors[0]])[0]\n            # repeat single color across hues\n            self._background_colors = [triplet] * self.hues\n        else:\n            triplets = self._to_color_triplets(colors)\n            self._background_colors = triplets\n        # Recompute active stops after change\n        self._active_stops = self._initialize_color_stops()\n\n    @property\n    def justify(self) -&gt; AlignMethod:\n        \"\"\"Horizontal alignment method.\"\"\"\n        return self._justify  # type: ignore\n\n    @justify.setter\n    def justify(self, method: AlignMethod) -&gt; None:\n        \"\"\"\n        Validate and set horizontal alignment.\n\n        Args:\n            method: 'left', 'center', or 'right'.\n\n        Raises:\n            ValueError: If method is invalid.\n        \"\"\"\n        if isinstance(method, str) and method.lower() in {\"left\", \"center\", \"right\"}:\n            self._justify = method.lower()  # type: ignore\n        else:\n            raise ValueError(f\"Invalid justify method: {method}\")\n\n    @property\n    def vertical_justify(self) -&gt; VerticalAlignMethod:\n        \"\"\"Vertical alignment method.\"\"\"\n        return self._vertical_justify  # type: ignore\n\n    @vertical_justify.setter\n    def vertical_justify(self, method: VerticalAlignMethod) -&gt; None:\n        \"\"\"Validate and set vertical alignment.\n\n        Args:\n            method(VerticalAlignMethod): 'top', 'center', or 'bottom'.\n\n        Raises:\n            ValueError: If method is invalid.\n        \"\"\"\n        if isinstance(method, str) and method.lower() in {\"top\", \"middle\", \"bottom\"}:\n            self._vertical_justify = method.lower()  # type: ignore\n        else:\n            raise ValueError(f\"Invalid vertical justify method: {method}\")\n\n    @staticmethod\n    def _to_color_triplets(colors: List[ColorType]) -&gt; List[ColorTriplet]:\n        \"\"\"\n        Convert a list of color specifications to ColorTriplet instances.\n\n        Args:\n            colors: List of color strings, Color, or ColorTriplet.\n\n        Returns:\n            List of ColorTriplet.\n\n        Raises:\n            TypeError: If unsupported color type encountered.\n            ColorParseError: If a color string fails to parse.\n        \"\"\"\n        triplets: List[ColorTriplet] = []\n        for c in colors:\n            if isinstance(c, ColorTriplet):\n                triplets.append(c)\n            elif isinstance(c, Color):\n                triplets.append(c.get_truecolor())\n            elif isinstance(c, str):\n                color = c.strip()\n                if len(color) == 4 and color.startswith(\"#\"):\n                    h = color[1:]\n                    if all(ch in \"0123456789abcdefABCDEF\" for ch in h):\n                        color = \"#\" + \"\".join(ch * 2 for ch in h)\n                triplets.append(Color.parse(color).get_truecolor())\n            else:\n                raise ColorParseError(\n                    f\"Unsupported color type: {type(c)}\\n\\tCould not parse color: {c}\"\n                )\n        return triplets\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; Measurement:\n        \"\"\"\n        Measure the minimum and maximum width for the gradient content.\n\n        Args:\n            console(rich.console.Console): Console for measurement.\n            options(rich.console.ConsoleOptions): Rendering options.\n\n        Returns:\n            Measurement: Combined width constraints.\n        \"\"\"\n        measurements = [Measurement.get(console, options, r) for r in self.renderables]\n        if not measurements:\n            # No renderables \u2014 return a reasonable default measurement.\n            # Min width is 0; max width is the available maximum from options.\n            return Measurement(0, options.max_width or 0)\n\n        min_width = min(m.minimum for m in measurements)\n        max_width = max(m.maximum for m in measurements)\n        return Measurement(min_width, max_width)\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n        \"\"\"\n        Render the gradient by applying interpolated colors to each segment.\n\n        Args:\n            console: Console to render to.\n            options: Rendering options.\n\n        Yields:\n            Segment: Colored text segments for gradient effect.\n        \"\"\"\n        width = options.max_width\n        content = Align(\n            Group(*self.renderables),\n            align=self.justify,\n            vertical=self.vertical_justify,\n            width=width,\n            pad=self.expand,\n        )\n\n        lines = console.render_lines(content, options, pad=True, new_lines=False)\n        for line_index, segments in enumerate(lines):\n            highlight_map = None\n            if self._highlight_rules:\n                line_text = \"\".join(segment.text for segment in segments)\n                if self.animated:\n                    highlight_map = self._build_highlight_map(line_text)\n                else:\n                    cached = self._highlight_map_cache.get(line_text)\n                    if cached is None:\n                        cached = self._build_highlight_map(line_text)\n                        self._highlight_map_cache[line_text] = cached\n                    highlight_map = cached\n            column = 0\n            char_index = 0\n            for seg in segments:\n                text = seg.text\n                base_style = seg.style or Style()\n                cluster = \"\"\n                cluster_width = 0\n                cluster_indices: list[int] = []\n                for character in text:\n                    current_index = char_index\n                    char_index += 1\n                    character_width = get_character_cell_size(character)\n                    if character_width &lt;= 0:\n                        cluster += character\n                        cluster_indices.append(current_index)\n                        continue\n                    if cluster:\n                        style = self._get_style_at_position(\n                            column - cluster_width, cluster_width, width\n                        )\n                        merged_style = self._merge_styles(base_style, style)\n                        merged_style = self._apply_highlight_style(\n                            merged_style, highlight_map, cluster_indices\n                        )\n                        yield Segment(cluster, merged_style)\n                        cluster = \"\"\n                        cluster_width = 0\n                        cluster_indices = []\n                    cluster = character\n                    cluster_width = character_width\n                    cluster_indices = [current_index]\n                    column += character_width\n                if cluster:\n                    style = self._get_style_at_position(\n                        column - cluster_width, cluster_width, width\n                    )\n                    merged_style = self._merge_styles(base_style, style)\n                    merged_style = self._apply_highlight_style(\n                        merged_style, highlight_map, cluster_indices\n                    )\n                    yield Segment(cluster, merged_style)\n            if line_index &lt; len(lines) - 1:\n                yield Segment.line()\n\n    def _get_style_at_position(self, position: int, width: int, span: int) -&gt; Style:\n        \"\"\"Compute the Rich Style for a character cluster at a given position.\n\n        Args:\n            position(int): Starting cell index of the cluster.\n            width(int): Cell width of the cluster.\n            span(int): Total available width for gradient calculation.\n\n        Returns:\n            Style: rich.style.Style with appropriate foreground and/or background colors.\n        \"\"\"\n        frac = self._compute_fraction(position, width, span)\n\n        # Default: apply gradient to foreground; background uses bg_colors if provided.\n        fg_style = \"\"\n        bg_style = \"\"\n        if self.colors:\n            r, g, b = self._interpolate_color(frac, self.colors)\n            fg_style = f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n        if self.bg_colors:\n            r, g, b = self._interpolate_color(frac, self.bg_colors)\n            bg_style = f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n\n        return Style(color=fg_style or None, bgcolor=bg_style or None)\n\n    def _compute_fraction(self, position: int, width: int, span: float) -&gt; float:\n        \"\"\"Compute fractional position for gradient interpolation, including phase.\n\n        Args:\n            position(int): Starting cell index.\n            width(int): Cell width.\n            span(float): Total span for gradient.\n\n        Returns:\n            float: Fraction between 0.0 and 1.0.\n        \"\"\"\n        total_width = (span or 0) * (self.repeat_scale or 1.0)\n        if total_width &lt;= 0:\n            # Avoid division by zero; return phase-only fraction.\n            return self.phase % 1.0\n\n        base = (position + width / 2) / total_width\n        return (base + self.phase) % 1.0\n\n    def _interpolate_color(\n        self, frac: float, color_stops: list[ColorTriplet]\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Interpolate color in linear light space with gamma correction.\n\n        Args:\n            frac(float): Fractional position between 0.0 and 1.0.\n            color_stops(List[ColorTriplet]): List of ColorTriplet stops.\n\n        Returns:\n            Tuple of (r, g, b) in sRGB space.\n        \"\"\"\n        if frac &lt;= 0:\n            return color_stops[0]\n        if frac &gt;= 1:\n            return color_stops[-1]\n\n        # Determine segment and local position\n        segment_count = len(color_stops) - 1\n        pos = frac * segment_count\n        idx = int(pos)\n        t = pos - idx\n\n        r0, g0, b0 = color_stops[idx]\n        r1, g1, b1 = color_stops[min(idx + 1, segment_count)]\n\n        def to_linear(c: float) -&gt; float:\n            return (c / 255.0) ** self._GAMMA_CORRECTION\n\n        def to_srgb(x: float) -&gt; float:\n            return (x ** (1.0 / self._GAMMA_CORRECTION)) * 255.0\n\n        lr0, lg0, lb0 = to_linear(r0), to_linear(g0), to_linear(b0)\n        lr1, lg1, lb1 = to_linear(r1), to_linear(g1), to_linear(b1)\n\n        lr = lr0 + (lr1 - lr0) * t\n        lg = lg0 + (lg1 - lg0) * t\n        lb = lb0 + (lb1 - lb0) * t\n\n        return to_srgb(lr), to_srgb(lg), to_srgb(lb)\n\n    @staticmethod\n    def _merge_styles(original: Style, gradient_style: Style) -&gt; Style:\n        \"\"\"\n        Merge original Style with gradient Style, preserving original attributes.\n\n        Args:\n            original: The existing Rich Style.\n            gradient_style: Style with gradient colors.\n\n        Returns:\n            Combined Style.\n        \"\"\"\n        return original + gradient_style if original else gradient_style\n\n    @staticmethod\n    def _coerce_highlight_style(style: StyleType) -&gt; Style:\n        if isinstance(style, Style):\n            return style\n        return Style.parse(str(style))\n\n    def highlight_words(\n        self,\n        words: Sequence[str],\n        style: StyleType,\n        *,\n        case_sensitive: bool = True,\n    ) -&gt; \"Gradient\":\n        \"\"\"\n        Highlight occurrences of the provided words with an additional style \\\n            after gradients are applied.\n\n        Args:\n            words(Sequence[str]): Iterable of words to highlight.\n            style(StyleType): Style to overlay on matched words.\n            case_sensitive(bool): Whether matching is case-sensitive. Defaults to True.\n\n        Returns:\n            The gradient instance (for chaining).\n        \"\"\"\n        self._invalidate_highlight_cache()\n        filtered = tuple(word for word in words if word)\n        if not filtered:\n            return self\n        highlight_style = self._coerce_highlight_style(style)\n        self._highlight_rules.append(\n            _HighlightRule(\n                kind=\"words\",\n                style=highlight_style,\n                words=filtered,\n                case_sensitive=case_sensitive,\n            )\n        )\n        return self\n\n    def highlight_regex(\n        self, pattern: str | re.Pattern[str], style: StyleType, flags: int = 0\n    ) -&gt; \"Gradient\":\n        \"\"\"\n        Highlight matches of a regex pattern with an additional style after gradients are applied.\n\n        Args:\n            pattern(str|re.Pattern[str]): Regex pattern (string or compiled).\n            style(StyleType): Style to overlay on matches.\n            flags(int): Optional regex flags when pattern is a string. Defaults to 0.\n\n        Returns:\n            The gradient instance (for chaining).\n        \"\"\"\n        self._invalidate_highlight_cache()\n        highlight_style = self._coerce_highlight_style(style)\n        compiled = (\n            pattern\n            if isinstance(pattern, re.Pattern)\n            else re.compile(pattern, flags=flags)\n        )\n        self._highlight_rules.append(\n            _HighlightRule(\n                kind=\"regex\",\n                style=highlight_style,\n                pattern=compiled,\n            )\n        )\n        return self\n\n    def _invalidate_highlight_cache(self) -&gt; None:\n        \"\"\"Clear cached highlight maps when highlight rules change.\"\"\"\n        if self._highlight_map_cache:\n            self._highlight_map_cache.clear()\n\n    def _build_highlight_map(self, text: str) -&gt; list[Optional[Style]]:\n        \"\"\"Compute per-character highlight styles for a line of text.\"\"\"\n        if not text or not self._highlight_rules:\n            return []\n        highlight_map: list[Optional[Style]] = [None] * len(text)\n        apply_range = self._apply_highlight_range\n\n        def apply_word_rule() -&gt; None:\n            haystack = text if rule.case_sensitive else text.lower()\n            for word in rule.words:\n                target = word if rule.case_sensitive else word.lower()\n                if not target:\n                    continue\n                start = 0\n                while True:\n                    index = haystack.find(target, start)\n                    if index == -1:\n                        break\n                    end = index + len(target)\n                    apply_range(highlight_map, index, end, rule.style)\n                    start = end\n\n        def apply_regex_rule() -&gt; None:\n            pattern = rule.pattern\n            if pattern is None:\n                return\n            for match in pattern.finditer(text):\n                # If the regex contains capture groups, apply highlighting only\n                # to those group spans. Otherwise, fall back to the whole match.\n                try:\n                    groups = match.groups()\n                except (AttributeError, TypeError):\n                    groups = ()\n                if groups:\n                    last_index = match.lastindex or 0\n                    for gi in range(1, last_index + 1):\n                        gstart, gend = match.span(gi)\n                        if gstart == -1 or gstart == gend:\n                            continue\n                        apply_range(highlight_map, gstart, gend, rule.style)\n                    continue\n                start, end = match.span()\n                if start == end:\n                    continue\n                apply_range(highlight_map, start, end, rule.style)\n\n        for rule in self._highlight_rules:\n            if rule.kind == \"words\":\n                apply_word_rule()\n            elif rule.kind == \"regex\":\n                apply_regex_rule()\n        return highlight_map\n\n    @staticmethod\n    def _apply_highlight_range(\n        highlight_map: list[Optional[Style]], start: int, end: int, style: Style\n    ) -&gt; None:\n        \"\"\"Apply style to a character range in the highlight map.\n        Args:\n            highlight_map(List[Optional[Style]]): List of per-character highlight styles.\n            start(int): Starting index (inclusive).\n            end(int): Ending index (exclusive).\n            style(Style): Style to apply.\n        \"\"\"\n        end = min(end, len(highlight_map))\n        if start &lt; 0 or start &gt;= end:\n            return\n        for index in range(start, end):\n            existing = highlight_map[index]\n            highlight_map[index] = existing + style if existing else style\n\n    @staticmethod\n    def _apply_highlight_style(\n        base_style: Style,\n        highlight_map: Optional[list[Optional[Style]]],\n        indices: Sequence[int],\n    ) -&gt; Style:\n        \"\"\"Merge highlight styles for character indices into the base style.\"\"\"\n        if not highlight_map or not indices:\n            return base_style\n        highlight_style: Optional[Style] = None\n        for index in indices:\n            if 0 &lt;= index &lt; len(highlight_map):\n                style = highlight_map[index]\n                if style is None:\n                    continue\n                highlight_style = highlight_style + style if highlight_style else style\n        if highlight_style:\n            return base_style + highlight_style\n        return base_style\n\n    # -----------------\n    # Test helper parity\n    # -----------------\n    def _initialize_color_stops(self) -&gt; List[ColorTriplet]:\n        \"\"\"Initialize the active color stops based on mode and provided stops.\n\n        If only one stop is provided, duplicate it to create a smooth segment pair.\n        \"\"\"\n        # Prefer foreground color stops; fall back to background stops if set\n        source: List[ColorTriplet] = self.colors if self.colors else self.bg_colors\n        if not source:\n            return []\n        return [source[0], source[0]] if len(source) == 1 else source\n\n    def _color_at(self, pos: int, width: int, span: int) -&gt; str:\n        \"\"\"Return the hex color at a given position (for tests).\"\"\"\n        stops = self._active_stops\n        if not stops:\n            return \"#000000\"\n        frac = self._compute_fraction(pos, width, span)\n        r, g, b = self._interpolate_color(frac, stops)\n        return f\"#{int(r):02x}{int(g):02x}{int(b):02x}\"\n\n    def _styled(self, original: Style, color: str) -&gt; Style:\n        \"\"\"Return a Style with the given color or bgcolor, preserving original (for tests).\"\"\"\n        return (\n            original + Style(bgcolor=color)\n            if self.bg_colors\n            else original + Style(color=color)\n        )\n\n    def _interpolated_color(\n        self, frac: float, stops: list, _count: Optional[int] = None\n    ):\n        \"\"\"Return the interpolated color at a fraction (for tests).\"\"\"\n        return self._interpolate_color(frac, stops)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.bg_colors","title":"<code>bg_colors</code>  <code>property</code> <code>writable</code>","text":"<p>List of parsed ColorTriplet objects for gradient background.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>List of parsed ColorTriplet objects for gradient foreground.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.expand","title":"<code>expand</code>  <code>property</code> <code>writable</code>","text":"<p>Whether the gradient expands to the available width/height.</p> <p>This property is stored on the instance and when updated will attempt to propagate the value to common wrapped renderables (for example, a stored Rich Panel under <code>self._panel</code>).</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.justify","title":"<code>justify</code>  <code>property</code> <code>writable</code>","text":"<p>Horizontal alignment method.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.renderables","title":"<code>renderables</code>  <code>property</code> <code>writable</code>","text":"<p>List of renderable objects to which the gradient is applied.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.vertical_justify","title":"<code>vertical_justify</code>  <code>property</code> <code>writable</code>","text":"<p>Vertical alignment method.</p>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__init__","title":"<code>__init__(renderables, colors=None, bg_colors=None, *, console=None, hues=5, rainbow=False, expand=True, justify='left', vertical_justify='middle', repeat_scale=2.0, highlight_words=None, highlight_regex=None, animated=False)</code>","text":"<p>Initialize a Gradient instance.</p> <p>Parameters:</p> Name Type Description Default <code>renderables</code> <code>str | ConsoleRenderable | List[ConsoleRenderable]</code> <p>A single renderable or list of renderable objects to which the gradient will be applied.</p> required <code>colors</code> <code>Optional[List[ColorType]]</code> <p>Optional list of colors (strings, Color, or ColorTriplet) for the gradient foreground. If omitted and rainbow is False, a spectrum of <code>hues</code> colors is used.</p> <code>None</code> <code>bg_colors</code> <code>Optional[List[ColorType]]</code> <p>Optional list of colors for the gradient background. If omitted, no background gradient is applied.</p> <code>None</code> <code>console</code> <code>Optional[Console]</code> <p>Optional Rich Console to render to. Defaults to <code>rich.get_console()</code>.</p> <code>None</code> <code>hues</code> <code>int</code> <p>Number of hues to generate if no explicit colors are given.</p> <code>5</code> <code>rainbow</code> <code>bool</code> <p>If True, ignore <code>colors</code> and use a full rainbow.</p> <code>False</code> <code>expand</code> <code>bool</code> <p>Whether to expand renderables to the full console width.</p> <code>True</code> <code>justify</code> <code>AlignMethod</code> <p>Horizontal alignment: 'left', 'center', or 'right'.</p> <code>'left'</code> <code>vertical_justify</code> <code>VerticalAlignMethod</code> <p>Vertical alignment: 'top', 'center', or 'bottom'.</p> <code>'middle'</code> <code>repeat_scale</code> <code>float</code> <p>Scale factor controlling gradient repeat span.</p> <code>2.0</code> <code>highlight_words</code> <code>Optional[HighlightWordsType | HighlightWords | Sequence[HighlightWords]]</code> <p>Optional configurations describing word highlights to apply.</p> <code>None</code> <code>highlight_regex</code> <code>Optional[HighlightRegexType | HighlightRegex | Sequence[HighlightRegex]]</code> <p>Optional configurations describing regex highlights to apply.</p> <code>None</code> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __init__(\n    self,\n    renderables: str | ConsoleRenderable | List[ConsoleRenderable],\n    colors: Optional[List[ColorType]] = None,\n    bg_colors: Optional[List[ColorType]] = None,\n    *,\n    console: Optional[Console] = None,\n    hues: int = 5,\n    rainbow: bool = False,\n    expand: bool = True,\n    justify: AlignMethod = \"left\",\n    vertical_justify: VerticalAlignMethod = \"middle\",\n    repeat_scale: float = 2.0,\n    highlight_words: Optional[\n        HighlightWordsType | HighlightWords | Sequence[HighlightWords]\n    ] = None,\n    highlight_regex: Optional[\n        HighlightRegexType | HighlightRegex | Sequence[HighlightRegex]\n    ] = None,\n    animated: bool = False,\n) -&gt; None:\n    \"\"\"\n    Initialize a Gradient instance.\n\n    Args:\n        renderables: A single renderable or list of renderable objects to\n            which the gradient will be applied.\n        colors: Optional list of colors (strings, Color, or\n            ColorTriplet) for the gradient foreground. If omitted and\n            rainbow is False, a spectrum of `hues` colors is used.\n        bg_colors: Optional list of colors for the gradient\n            background. If omitted, no background gradient is applied.\n        console: Optional Rich Console to render to. Defaults to\n            `rich.get_console()`.\n        hues: Number of hues to generate if no explicit colors are given.\n        rainbow: If True, ignore `colors` and use a full rainbow.\n        expand: Whether to expand renderables to the full console width.\n        justify: Horizontal alignment: 'left', 'center', or 'right'.\n        vertical_justify: Vertical alignment: 'top', 'center', or 'bottom'.\n        repeat_scale: Scale factor controlling gradient repeat span.\n        highlight_words: Optional configurations describing word highlights to apply.\n        highlight_regex: Optional configurations describing regex highlights to apply.\n    \"\"\"\n    self.console: Console = console or get_console()\n    self.hues: int = max(hues, 2)\n    self.rainbow: bool = rainbow\n    self.repeat_scale: float = repeat_scale\n    self.phase: float = 0.0\n    # Keep a flag if the user requested animated behavior; static\n    # Gradient objects ignore animation but tests may construct with\n    # animated=True, so store the attribute for parity.\n    self.animated: bool = bool(animated)\n    # Backing attribute for expand; use property setter to allow\n    # propagation to wrapped renderables (e.g., Rich Panel instances).\n    self._expand: bool = bool(expand)\n    self.justify = justify\n    self.vertical_justify = vertical_justify\n\n    # Validate and normalize renderables\n    if renderables is None:\n        raise ValueError(\"`renderables` cannot be None...\")\n    if isinstance(renderables, str):\n        self.renderables = [RichText.from_markup(renderables)]\n    elif isinstance(renderables, ConsoleRenderable):\n        self.renderables = [renderables]\n    else:\n        self.renderables = renderables\n\n    # Parse and store color stops\n    foreground_colors: List[ColorType] = list(colors or [])\n    background_colors: List[ColorType] = list(bg_colors or [])\n    self.colors = foreground_colors  # type: ignore[assignment]\n    # Help type-checkers understand the setter accepts ColorType values\n    self.bg_colors = cast(\n        Optional[List[ColorType]], background_colors)  # type: ignore[assignment]\n    self._active_stops = self._initialize_color_stops()\n    self._highlight_rules: list[_HighlightRule] = []\n    self._highlight_map_cache: dict[str, list[Optional[Style]]] = {}\n    if highlight_words is not None:\n        for word_rule in HighlightWords.from_config(highlight_words):\n            self._highlight_rules.append(\n                _HighlightRule(\n                    kind=\"words\",\n                    words=word_rule.words,\n                    style=word_rule.style,\n                    case_sensitive=word_rule.case_sensitive,\n                )\n            )\n\n    if highlight_regex is not None:\n        for regex_rule in HighlightRegex.from_config(highlight_regex):\n            self._highlight_rules.append(\n                _HighlightRule(\n                    kind=\"regex\",\n                    pattern=regex_rule.pattern,\n                    style=regex_rule.style,\n                )\n            )\n\n    self._invalidate_highlight_cache()\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render the gradient by applying interpolated colors to each segment.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>Console to render to.</p> required <code>options</code> <code>ConsoleOptions</code> <p>Rendering options.</p> required <p>Yields:</p> Name Type Description <code>Segment</code> <code>RenderResult</code> <p>Colored text segments for gradient effect.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __rich_console__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; RenderResult:\n    \"\"\"\n    Render the gradient by applying interpolated colors to each segment.\n\n    Args:\n        console: Console to render to.\n        options: Rendering options.\n\n    Yields:\n        Segment: Colored text segments for gradient effect.\n    \"\"\"\n    width = options.max_width\n    content = Align(\n        Group(*self.renderables),\n        align=self.justify,\n        vertical=self.vertical_justify,\n        width=width,\n        pad=self.expand,\n    )\n\n    lines = console.render_lines(content, options, pad=True, new_lines=False)\n    for line_index, segments in enumerate(lines):\n        highlight_map = None\n        if self._highlight_rules:\n            line_text = \"\".join(segment.text for segment in segments)\n            if self.animated:\n                highlight_map = self._build_highlight_map(line_text)\n            else:\n                cached = self._highlight_map_cache.get(line_text)\n                if cached is None:\n                    cached = self._build_highlight_map(line_text)\n                    self._highlight_map_cache[line_text] = cached\n                highlight_map = cached\n        column = 0\n        char_index = 0\n        for seg in segments:\n            text = seg.text\n            base_style = seg.style or Style()\n            cluster = \"\"\n            cluster_width = 0\n            cluster_indices: list[int] = []\n            for character in text:\n                current_index = char_index\n                char_index += 1\n                character_width = get_character_cell_size(character)\n                if character_width &lt;= 0:\n                    cluster += character\n                    cluster_indices.append(current_index)\n                    continue\n                if cluster:\n                    style = self._get_style_at_position(\n                        column - cluster_width, cluster_width, width\n                    )\n                    merged_style = self._merge_styles(base_style, style)\n                    merged_style = self._apply_highlight_style(\n                        merged_style, highlight_map, cluster_indices\n                    )\n                    yield Segment(cluster, merged_style)\n                    cluster = \"\"\n                    cluster_width = 0\n                    cluster_indices = []\n                cluster = character\n                cluster_width = character_width\n                cluster_indices = [current_index]\n                column += character_width\n            if cluster:\n                style = self._get_style_at_position(\n                    column - cluster_width, cluster_width, width\n                )\n                merged_style = self._merge_styles(base_style, style)\n                merged_style = self._apply_highlight_style(\n                    merged_style, highlight_map, cluster_indices\n                )\n                yield Segment(cluster, merged_style)\n        if line_index &lt; len(lines) - 1:\n            yield Segment.line()\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.__rich_measure__","title":"<code>__rich_measure__(console, options)</code>","text":"<p>Measure the minimum and maximum width for the gradient content.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>Console for measurement.</p> required <code>options</code> <code>ConsoleOptions</code> <p>Rendering options.</p> required <p>Returns:</p> Name Type Description <code>Measurement</code> <code>Measurement</code> <p>Combined width constraints.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def __rich_measure__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; Measurement:\n    \"\"\"\n    Measure the minimum and maximum width for the gradient content.\n\n    Args:\n        console(rich.console.Console): Console for measurement.\n        options(rich.console.ConsoleOptions): Rendering options.\n\n    Returns:\n        Measurement: Combined width constraints.\n    \"\"\"\n    measurements = [Measurement.get(console, options, r) for r in self.renderables]\n    if not measurements:\n        # No renderables \u2014 return a reasonable default measurement.\n        # Min width is 0; max width is the available maximum from options.\n        return Measurement(0, options.max_width or 0)\n\n    min_width = min(m.minimum for m in measurements)\n    max_width = max(m.maximum for m in measurements)\n    return Measurement(min_width, max_width)\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.highlight_regex","title":"<code>highlight_regex(pattern, style, flags=0)</code>","text":"<p>Highlight matches of a regex pattern with an additional style after gradients are applied.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str | Pattern[str]</code> <p>Regex pattern (string or compiled).</p> required <code>style</code> <code>StyleType</code> <p>Style to overlay on matches.</p> required <code>flags</code> <code>int</code> <p>Optional regex flags when pattern is a string. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>'Gradient'</code> <p>The gradient instance (for chaining).</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def highlight_regex(\n    self, pattern: str | re.Pattern[str], style: StyleType, flags: int = 0\n) -&gt; \"Gradient\":\n    \"\"\"\n    Highlight matches of a regex pattern with an additional style after gradients are applied.\n\n    Args:\n        pattern(str|re.Pattern[str]): Regex pattern (string or compiled).\n        style(StyleType): Style to overlay on matches.\n        flags(int): Optional regex flags when pattern is a string. Defaults to 0.\n\n    Returns:\n        The gradient instance (for chaining).\n    \"\"\"\n    self._invalidate_highlight_cache()\n    highlight_style = self._coerce_highlight_style(style)\n    compiled = (\n        pattern\n        if isinstance(pattern, re.Pattern)\n        else re.compile(pattern, flags=flags)\n    )\n    self._highlight_rules.append(\n        _HighlightRule(\n            kind=\"regex\",\n            style=highlight_style,\n            pattern=compiled,\n        )\n    )\n    return self\n</code></pre>"},{"location":"gradient_ref/#rich_gradient.gradient.Gradient.highlight_words","title":"<code>highlight_words(words, style, *, case_sensitive=True)</code>","text":"<p>Highlight occurrences of the provided words with an additional style             after gradients are applied.</p> <p>Parameters:</p> Name Type Description Default <code>words</code> <code>Sequence[str]</code> <p>Iterable of words to highlight.</p> required <code>style</code> <code>StyleType</code> <p>Style to overlay on matched words.</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether matching is case-sensitive. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>'Gradient'</code> <p>The gradient instance (for chaining).</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>def highlight_words(\n    self,\n    words: Sequence[str],\n    style: StyleType,\n    *,\n    case_sensitive: bool = True,\n) -&gt; \"Gradient\":\n    \"\"\"\n    Highlight occurrences of the provided words with an additional style \\\n        after gradients are applied.\n\n    Args:\n        words(Sequence[str]): Iterable of words to highlight.\n        style(StyleType): Style to overlay on matched words.\n        case_sensitive(bool): Whether matching is case-sensitive. Defaults to True.\n\n    Returns:\n        The gradient instance (for chaining).\n    \"\"\"\n    self._invalidate_highlight_cache()\n    filtered = tuple(word for word in words if word)\n    if not filtered:\n        return self\n    highlight_style = self._coerce_highlight_style(style)\n    self._highlight_rules.append(\n        _HighlightRule(\n            kind=\"words\",\n            style=highlight_style,\n            words=filtered,\n            case_sensitive=case_sensitive,\n        )\n    )\n    return self\n</code></pre>"},{"location":"panel/","title":"Panel","text":"<p><code>rich_gradient.Panel</code> wraps a <code>rich.panel.Panel</code>, applies gradient foreground and background colors, and automatically highlights the title and subtitle so they blend with the gradient. Because it inherits from <code>Gradient</code>, every alignment and highlighting option is available.</p> <p></p> <pre><code>from rich.console import Console\nfrom rich.panel import Panel as RichPanel\nfrom rich_gradient import Panel\n\ninner = RichPanel.fit(\n    \"[b]Gradient titles, custom borders, highlighted keywords.[/b]\",\n    title=\"[b]Features[/b]\",\n    border_style=\"white\",\n    padding=(1, 2),\n)\n\nconsole = Console()\nconsole.print(\n    Panel(\n        inner,\n        colors=[\"#38bdf8\", \"#a855f7\", \"#f97316\"],\n        bg_colors=[\"#0f172a\", \"#2c1067\"],\n        title=\"rich_gradient.Panel\",\n        subtitle=\"powered by Rich\",\n        border_style=\"bold #22d3ee\",\n        highlight_words=[([\"Gradient\", \"keywords\"], \"bold white on black\", False)],\n    )\n)\n</code></pre>"},{"location":"panel/#title-and-subtitle-highlighting","title":"Title and subtitle highlighting","text":"<p>When a title or subtitle is provided, the panel generates regex patterns that match the corresponding row in the rendered border and applies the supplied styles (<code>title_style</code> / <code>subtitle_style</code>). You can still pass your own <code>highlight_regex</code> or <code>highlight_words</code>; they\u2019ll be merged with the title highlights.</p>"},{"location":"panel/#other-options","title":"Other options","text":"<ul> <li><code>padding</code>, <code>box</code>, <code>safe_box</code>, <code>width</code>, <code>height</code>: forwarded to the underlying Rich panel.</li> <li><code>colors</code>, <code>bg_colors</code>, <code>rainbow</code>, <code>hues</code>: the same controls exposed by <code>Gradient</code>.</li> <li><code>justify</code>, <code>vertical_justify</code>: control how the inner panel is positioned within the gradient.</li> <li><code>expand</code>: whether the panel fills the available width.</li> </ul> <p>For animation support, see <code>AnimatedPanel</code>.</p>"},{"location":"panel_ref/","title":"Panel Reference","text":"<p>               Bases: <code>Gradient</code></p> <p>A Rich Panel that supports (animated) gradients as background.</p> <p>Parameters:</p> Name Type Description Default <code>renderable</code> <code>RenderableType</code> <p>The renderable to display inside the panel.</p> required <code>colors</code> <code>Optional[List[ColorType]]</code> <p>Foreground color stops for the gradient.</p> <code>None</code> <code>bg_colors</code> <code>Optional[List[ColorType]]</code> <p>Background color stops for the gradient.</p> <code>None</code> <code>title</code> <code>Optional[RenderableType]</code> <p>The title of the panel.</p> <code>None</code> <code>title_align</code> <code>AlignMethod</code> <p>The alignment of the title. Defaults to \"left\".</p> <code>'center'</code> <code>title_style</code> <code>StyleType</code> <p>The style of the title. If none, the title will use             the bolded gradient colors.</p> <code>'bold'</code> <code>subtitle</code> <code>Optional[RenderableType]</code> <p>The subtitle of the panel.</p> <code>None</code> <code>subtitle_align</code> <code>AlignMethod</code> <p>The alignment of the subtitle. Defaults to \"right\".</p> <code>'right'</code> <code>subtitle_style</code> <code>StyleType</code> <p>The style of the subtitle. If none, the subtitle will use             the dimmed gradient colors.</p> <code>''</code> <code>border_style</code> <code>Union[str, Color]</code> <p>The style of the panel border.</p> <code>''</code> <code>box</code> <code>Optional[Box]</code> <p>The box style to use for the panel border.</p> <code>ROUNDED</code> <code>padding</code> <code>int | tuple[int, int] | tuple[int, int, int, int]</code> <p>Padding inside the             panel. Defaults to (0, 0, 0, 0).</p> <code>(0, 1, 0, 1)</code> <code>expand</code> <code>bool</code> <p>Whether to expand the panel to fill available width. Defaults to True.</p> <code>True</code> <code>text_justify</code> <code>AlignMethod</code> <p>The justification of the panel content text.             Defaults to \"left\".</p> <code>'left'</code> <code>style</code> <code>Union[str, Color]</code> <p>The style of the panel content. If a color is provided,             it will override the gradient style.</p> <code>''</code> <code>width</code> <code>Optional[int]</code> <p>The width of the panel.</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the panel.</p> <code>None</code> <code>safe_box</code> <code>bool</code> <p>Whether to use safe box drawing characters. Defaults to False.</p> <code>False</code> <code>highlight_words</code> <code>Optional[HighlightWordsType]</code> <p>Words to highlight with styles.</p> <code>None</code> <code>highlight_regex</code> <code>Optional[HighlightRegexType]</code> <p>Regex patterns to highlight with styles.</p> <code>None</code> Source code in <code>src/rich_gradient/panel.py</code> <pre><code>class Panel(Gradient):\n    \"\"\"A Rich Panel that supports (animated) gradients as background.\n\n    Args:\n        renderable (RenderableType): The renderable to display inside the panel.\n        colors (Optional[List[ColorType]]): Foreground color stops for the gradient.\n        bg_colors (Optional[List[ColorType]]): Background color stops for the gradient.\n        title (Optional[RenderableType]): The title of the panel.\n        title_align (AlignMethod): The alignment of the title. Defaults to \"left\".\n        title_style (StyleType): The style of the title. If none, the title will use \\\n            the bolded gradient colors.\n        subtitle (Optional[RenderableType]): The subtitle of the panel.\n        subtitle_align (AlignMethod): The alignment of the subtitle. Defaults to \"right\".\n        subtitle_style (StyleType): The style of the subtitle. If none, the subtitle will use \\\n            the dimmed gradient colors.\n        border_style (Union[str, Color]): The style of the panel border.\n        box (Optional[Box]): The box style to use for the panel border.\n        padding (int | tuple[int, int] | tuple[int, int, int, int]): Padding inside the \\\n            panel. Defaults to (0, 0, 0, 0).\n        expand (bool): Whether to expand the panel to fill available width. Defaults to True.\n        text_justify (AlignMethod): The justification of the panel content text. \\\n            Defaults to \"left\".\n        style (Union[str, Color]): The style of the panel content. If a color is provided, \\\n            it will override the gradient style.\n        width (Optional[int]): The width of the panel.\n        height (Optional[int]): The height of the panel.\n        safe_box (bool): Whether to use safe box drawing characters. Defaults to False.\n        highlight_words (Optional[HighlightWordsType]): Words to highlight with styles.\n        highlight_regex (Optional[HighlightRegexType]): Regex patterns to highlight with styles.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: RenderableType,\n        colors: Optional[List[ColorType]] = None,\n        bg_colors: Optional[List[ColorType]] = None,\n        rainbow: bool = False,\n        hues: int = 5,\n        title: Optional[Text | RichText | TextType] = None,\n        title_align: AlignMethod = \"center\",\n        title_style: StyleType = \"bold\",\n        subtitle: Optional[Text | RichText | TextType] = None,\n        subtitle_align: AlignMethod = \"right\",\n        subtitle_style: StyleType = \"\",\n        border_style: StyleType = \"\",\n        justify: AlignMethod = \"left\",\n        vertical_justify: VerticalAlignMethod = \"middle\",\n        box: Box = ROUNDED,\n        padding: Union[int, tuple[int, int], tuple[int, int, int, int]] = (0, 1, 0, 1),\n        expand: bool = True,\n        text_justify: AlignMethod = \"left\",\n        style: StyleType = \"\",\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        safe_box: bool = False,\n        highlight_words: Optional[HighlightWordsType] = None,\n        highlight_regex: Optional[HighlightRegexType] = None,\n    ) -&gt; None:\n        \"\"\"Initialize the Panel with gradient support.\"\"\"\n\n        # Ensure the inner content supports Rich markup when provided as a string.\n        # - Strings are parsed with Rich markup into RichText\n        # - RichText or our gradient Text pass through unchanged\n        # - RichCast objects (with __rich__) are resolved once\n        def _normalize_renderable(obj: RenderableType) -&gt; RenderableType:\n            # Resolve simple RichCast once (avoid deep recursion)\n            rich_obj = getattr(obj, \"__rich__\", None)\n            if callable(rich_obj):\n                try:\n                    obj = cast(RenderableType, rich_obj())\n                except (\n                    AttributeError,\n                    TypeError,\n                    ValueError,\n                    RuntimeError,\n                ) as err:  # pragma: no cover - defensive\n                    logger.debug(\"Error calling __rich__: %s\", err)\n            # Parse markup strings into RichText\n            if isinstance(obj, str):\n                return RichText.from_markup(\n                    obj,\n                    style=style,\n                    justify=text_justify,\n                )\n            return obj\n\n        normalized_renderable = _normalize_renderable(renderable)\n        _style = Style.parse(style) if style else Style.null()\n\n        panel = RichPanel(\n            normalized_renderable,\n            title=title,\n            title_align=title_align,\n            subtitle=subtitle,\n            subtitle_align=subtitle_align,\n            border_style=border_style,\n            box=box,\n            padding=padding,\n            expand=expand,\n            style=_style,\n            width=width,\n            height=height,\n            safe_box=safe_box,\n        )\n\n        # Track the underlying Rich Panel so expand setter can propagate to it\n        # (Gradient.expand property will attempt to update ``self._panel``).\n        self._panel = panel\n\n        # Highlight title and subtitle if they are provided\n        ## Normalize highlight_regex into a mutable sequence of tuples (pattern, style, priority)\n        if highlight_regex is None:\n            highlight_list = []\n        elif isinstance(highlight_regex, Mapping):\n            # Convert mapping to a list of (pattern, style, priority) tuples\n            highlight_list = [\n                (pattern, style, 0) for pattern, style in highlight_regex.items()\n            ]\n        else:\n            # Assume it's already a sequence of tuples\n            highlight_list = list(highlight_regex)\n\n        if title:\n            title_regex = self._get_title_regex(box)\n            highlight_list.append((title_regex, title_style or \"bold\", 0))\n        if subtitle:\n            subtitle_regex = self._get_subtitle_regex(box)\n            highlight_list.append((subtitle_regex, subtitle_style, 0))\n\n        super().__init__(\n            panel,\n            colors=colors,\n            bg_colors=bg_colors,\n            hues=hues,\n            rainbow=rainbow,\n            expand=expand,\n            justify=justify,\n            vertical_justify=vertical_justify,\n            highlight_words=highlight_words,\n            highlight_regex=highlight_list,\n        )\n\n    @staticmethod\n    def _get_title_regex(box: Box) -&gt; str:\n        \"\"\"Generate regex patterns for title highlighting.\"\"\"\n        top_left: str = escape(box.top_left)\n        top: str = escape(box.top)\n        top_right: str = escape(box.top_right)\n        title_regex: str = rf\"{top_left}{top}+ (.*?) {top}+{top_right}\"\n        logger.debug(\"Generated title regex: %s\", title_regex)\n        return title_regex\n\n    @staticmethod\n    def _get_subtitle_regex(box: Box) -&gt; str:\n        \"\"\"Generate regex patterns for subtitle highlighting.\"\"\"\n        bottom_left: str = escape(box.bottom_left)\n        bottom: str = escape(box.bottom)\n        bottom_right: str = escape(box.bottom_right)\n        subtitle_regex: str = rf\"{bottom_left}{bottom}+ (.*?) {bottom}+{bottom_right}\"\n        logger.debug(\"Generated subtitle regex: %s\", subtitle_regex)\n        return subtitle_regex\n\n    @property\n    def panel(self) -&gt; RichPanel:\n        \"\"\"Access the underlying Rich Panel renderable.\"\"\"\n        return self._panel\n</code></pre>"},{"location":"panel_ref/#rich_gradient.panel.Panel.panel","title":"<code>panel</code>  <code>property</code>","text":"<p>Access the underlying Rich Panel renderable.</p>"},{"location":"panel_ref/#rich_gradient.panel.Panel.__init__","title":"<code>__init__(renderable, colors=None, bg_colors=None, rainbow=False, hues=5, title=None, title_align='center', title_style='bold', subtitle=None, subtitle_align='right', subtitle_style='', border_style='', justify='left', vertical_justify='middle', box=ROUNDED, padding=(0, 1, 0, 1), expand=True, text_justify='left', style='', width=None, height=None, safe_box=False, highlight_words=None, highlight_regex=None)</code>","text":"<p>Initialize the Panel with gradient support.</p> Source code in <code>src/rich_gradient/panel.py</code> <pre><code>def __init__(\n    self,\n    renderable: RenderableType,\n    colors: Optional[List[ColorType]] = None,\n    bg_colors: Optional[List[ColorType]] = None,\n    rainbow: bool = False,\n    hues: int = 5,\n    title: Optional[Text | RichText | TextType] = None,\n    title_align: AlignMethod = \"center\",\n    title_style: StyleType = \"bold\",\n    subtitle: Optional[Text | RichText | TextType] = None,\n    subtitle_align: AlignMethod = \"right\",\n    subtitle_style: StyleType = \"\",\n    border_style: StyleType = \"\",\n    justify: AlignMethod = \"left\",\n    vertical_justify: VerticalAlignMethod = \"middle\",\n    box: Box = ROUNDED,\n    padding: Union[int, tuple[int, int], tuple[int, int, int, int]] = (0, 1, 0, 1),\n    expand: bool = True,\n    text_justify: AlignMethod = \"left\",\n    style: StyleType = \"\",\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    safe_box: bool = False,\n    highlight_words: Optional[HighlightWordsType] = None,\n    highlight_regex: Optional[HighlightRegexType] = None,\n) -&gt; None:\n    \"\"\"Initialize the Panel with gradient support.\"\"\"\n\n    # Ensure the inner content supports Rich markup when provided as a string.\n    # - Strings are parsed with Rich markup into RichText\n    # - RichText or our gradient Text pass through unchanged\n    # - RichCast objects (with __rich__) are resolved once\n    def _normalize_renderable(obj: RenderableType) -&gt; RenderableType:\n        # Resolve simple RichCast once (avoid deep recursion)\n        rich_obj = getattr(obj, \"__rich__\", None)\n        if callable(rich_obj):\n            try:\n                obj = cast(RenderableType, rich_obj())\n            except (\n                AttributeError,\n                TypeError,\n                ValueError,\n                RuntimeError,\n            ) as err:  # pragma: no cover - defensive\n                logger.debug(\"Error calling __rich__: %s\", err)\n        # Parse markup strings into RichText\n        if isinstance(obj, str):\n            return RichText.from_markup(\n                obj,\n                style=style,\n                justify=text_justify,\n            )\n        return obj\n\n    normalized_renderable = _normalize_renderable(renderable)\n    _style = Style.parse(style) if style else Style.null()\n\n    panel = RichPanel(\n        normalized_renderable,\n        title=title,\n        title_align=title_align,\n        subtitle=subtitle,\n        subtitle_align=subtitle_align,\n        border_style=border_style,\n        box=box,\n        padding=padding,\n        expand=expand,\n        style=_style,\n        width=width,\n        height=height,\n        safe_box=safe_box,\n    )\n\n    # Track the underlying Rich Panel so expand setter can propagate to it\n    # (Gradient.expand property will attempt to update ``self._panel``).\n    self._panel = panel\n\n    # Highlight title and subtitle if they are provided\n    ## Normalize highlight_regex into a mutable sequence of tuples (pattern, style, priority)\n    if highlight_regex is None:\n        highlight_list = []\n    elif isinstance(highlight_regex, Mapping):\n        # Convert mapping to a list of (pattern, style, priority) tuples\n        highlight_list = [\n            (pattern, style, 0) for pattern, style in highlight_regex.items()\n        ]\n    else:\n        # Assume it's already a sequence of tuples\n        highlight_list = list(highlight_regex)\n\n    if title:\n        title_regex = self._get_title_regex(box)\n        highlight_list.append((title_regex, title_style or \"bold\", 0))\n    if subtitle:\n        subtitle_regex = self._get_subtitle_regex(box)\n        highlight_list.append((subtitle_regex, subtitle_style, 0))\n\n    super().__init__(\n        panel,\n        colors=colors,\n        bg_colors=bg_colors,\n        hues=hues,\n        rainbow=rainbow,\n        expand=expand,\n        justify=justify,\n        vertical_justify=vertical_justify,\n        highlight_words=highlight_words,\n        highlight_regex=highlight_list,\n    )\n</code></pre>"},{"location":"rule/","title":"Rule","text":"<p><code>rich_gradient.Rule</code> subclasses <code>rich.rule.Rule</code> and applies gradient color stops (foreground and optional background) across the rule glyphs. All alignment, justify, and text options from the Rich base class are preserved.</p> <p></p> <pre><code>from rich.console import Console\nfrom rich_gradient import Rule\n\nconsole = Console()\nconsole.print(Rule(\"Default gradient rule\", colors=[\"#38bdf8\", \"#a855f7\", \"#f97316\"]))\nconsole.print(Rule(\"Left aligned\", align=\"left\", colors=[\"#14b8a6\", \"#6366f1\"]))\nconsole.print(Rule(\"Right aligned\", align=\"right\", colors=[\"#f97316\", \"#facc15\"]))\nconsole.print(Rule(\"Thin border\", thickness=0, colors=[\"#22d3ee\", \"#6366f1\"]))\nconsole.print(Rule(\"Double border\", thickness=1, colors=[\"#f472b6\", \"#facc15\"]))\nconsole.print(Rule(\"Thick block rule\", thickness=3, colors=[\"#ef4444\", \"#facc15\"]))\n</code></pre>"},{"location":"rule/#thickness-and-alignment","title":"Thickness and alignment","text":"<ul> <li><code>align</code>: <code>\"left\"</code>, <code>\"center\"</code> (default), or <code>\"right\"</code>.</li> <li><code>thickness</code>: integer 0\u20133 controlling the glyph (<code>\u2500</code>, <code>\u2550</code>, <code>\u2501</code>, <code>\u2588</code> respectively).</li> <li><code>characters</code>: provide your own glyph when you need full control.</li> </ul> <p>The gradient is distributed across the rendered width after padding and indentation are applied.</p>"},{"location":"rule/#titles-and-colors","title":"Titles and colors","text":"<p>Rules support <code>title</code>, <code>title_align</code>, and <code>title_style</code> exactly like Rich. Styles can reference any color supported by <code>rich.color.Color</code>, including CSS names and hex codes provided by <code>rich-color-ext</code>. Pass <code>bg_colors</code> to paint the rule background.</p> <p>The example script that generates the gallery is saved as <code>examples/rule_gallery.py</code>.</p>"},{"location":"rule_ref/","title":"Rule Reference","text":"<p>               Bases: <code>Gradient</code></p> <p>A Rich Rule that supports gradients via the Gradient base class.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Optional[str]</code> <p>Optional title text placed within the rule.</p> required <code>title_style</code> <code>StyleType</code> <p>Style applied to the title text after gradients.</p> <code>'bold'</code> <code>colors</code> <code>Optional[Sequence[ColorType]]</code> <p>Foreground gradient color stops.</p> <code>None</code> <code>bg_colors</code> <code>Optional[Sequence[ColorType]]</code> <p>Background gradient color stops.</p> <code>None</code> <code>rainbow</code> <code>bool</code> <p>If True, generate a rainbow regardless of colors.</p> <code>False</code> <code>hues</code> <code>int</code> <p>Number of hues when generating default spectrum.</p> <code>17</code> <code>thickness</code> <code>int</code> <p>0..3 selects line character style.</p> <code>1</code> <code>style</code> <code>StyleType</code> <p>Base style for the rule line (merged with gradients).</p> <code>''</code> <code>end</code> <code>str</code> <p>Trailing characters after the rule (default newline).</p> <code>'\\n'</code> <code>align</code> <code>AlignMethod</code> <p>Alignment for the rule within the available width.</p> <code>'center'</code> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>class Rule(Gradient):\n    \"\"\"A Rich Rule that supports gradients via the Gradient base class.\n\n    Args:\n        title: Optional title text placed within the rule.\n        title_style: Style applied to the title text after gradients.\n        colors: Foreground gradient color stops.\n        bg_colors: Background gradient color stops.\n        rainbow: If True, generate a rainbow regardless of colors.\n        hues: Number of hues when generating default spectrum.\n        thickness: 0..3 selects line character style.\n        style: Base style for the rule line (merged with gradients).\n        end: Trailing characters after the rule (default newline).\n        align: Alignment for the rule within the available width.\n    \"\"\"\n\n    def __init__(\n        self,\n        title: Optional[str],\n        title_style: StyleType = \"bold\",\n        colors: Optional[Sequence[ColorType]] = None,\n        bg_colors: Optional[Sequence[ColorType]] = None,\n        *,\n        rainbow: bool = False,\n        hues: int = 17,\n        thickness: int = 1,\n        characters: Optional[str] = None,\n        style: StyleType = \"\",\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n        console: Optional[Console] = None,\n    ) -&gt; None:\n        self.title = title or \"\"\n        self.title_style = title_style\n        self.thickness = thickness\n        self.characters = characters or CHARACTER_MAP.get(thickness, CHARACTER_MAP[2])\n\n        # Build the underlying Rich Rule renderable\n        base_rule = RichRule(\n            title=self.title,\n            characters=self.characters,\n            style=style,\n            end=end,\n            align=align,\n        )\n\n        try:\n            if self.title:\n                highlight_words = {self.title: self.title_style}\n            else:\n                highlight_words = None\n\n            # Validate provided color names against runtime config to ensure\n            # clearly invalid names (e.g., 'bad') are rejected. We accept\n            # hex values and rgb(...) forms, and for plain names consult the\n            # runtime config color keys (case-insensitive) as accepted names.\n            if colors is not None:\n                known_names = {\n                    k.lower() for k in dict(getattr(config, \"colors\", {}) or {}).keys()\n                }\n                for c in colors:\n                    if isinstance(c, str):\n                        s = c.strip()\n                        if s.startswith(\"#\") or s.lower().startswith((\"rgb(\", \"rgba(\")):\n                            # hex or rgb forms are allowed; parsing will validate further\n                            continue\n                        # Plain name: must exist in runtime config (case-insensitive)\n                        if s.lower() not in known_names:\n                            raise ValueError(f\"Invalid color name: {s}\")\n\n            super().__init__(\n                base_rule,\n                colors=list(colors) if colors is not None else None,\n                bg_colors=list(bg_colors) if bg_colors is not None else None,\n                console=console,\n                hues=hues,\n                rainbow=rainbow,\n                vertical_justify=\"middle\",\n                highlight_words=highlight_words,\n            )\n        except Exception as err:\n            # Normalize any parsing/validation error into ValueError for the\n            # public Rule API so callers receive a consistent exception type\n            # for invalid color inputs.\n            raise ValueError(f\"Invalid color provided: {err}\") from err\n\n    @property\n    def thickness(self) -&gt; int:\n        \"\"\"Get the thickness of the Rule.\"\"\"\n        if hasattr(self, \"_thickness\"):\n            return self._thickness\n        for thickness, char in CHARACTER_MAP.items():\n            if char == getattr(self, \"_characters\", CHARACTER_MAP[2]):\n                return thickness\n        return 2  # Default\n\n    @thickness.setter\n    def thickness(self, value: int) -&gt; None:\n        \"\"\"Set the thickness of the Rule.\n        Args:\n            value: Thickness as an integer (0-3) or the corresponding character.\n        Raises:\n            ValueError: If the value is not a valid thickness or character.\"\"\"\n        if isinstance(value, int) and 0 &lt;= value &lt;= 3:\n            self._thickness = value\n            self._characters = CHARACTER_MAP[value]\n            return\n        raise ValueError(\n            \"thickness string must be one of the following characters: \"\n            + \", \".join(CHARACTER_MAP.values())\n        )\n\n    @property\n    def characters(self) -&gt; str:\n        \"\"\"Get the character used for the rule line.\"\"\"\n        if self._characters:\n            return self._characters\n\n        # Validate thickness\n        if not isinstance(self.thickness, int):\n            raise TypeError(\n                f\"thickness must be an integer, recieved {type(self.thickness).__name__}\"\n            )\n        if not 0 &lt;= self.thickness &lt;= 3:\n            raise ValueError(\"thickness must be an integer between 0 and 3 (inclusive)\")\n\n        return CHARACTER_MAP.get(self.thickness, CHARACTER_MAP[2])\n\n    @characters.setter\n    def characters(self, value: str) -&gt; None:\n        \"\"\"Set the character used for the rule line.\"\"\"\n        if not isinstance(value, str) or len(value) != 1:\n            raise ValueError(\"characters must be a single character string\")\n        self._characters = value\n\n    @property\n    def title(self) -&gt; Optional[TextType]:\n        \"\"\"Get the title of the Rule.\"\"\"\n        return self._title or None\n\n    @title.setter\n    def title(self, value: Optional[TextType]) -&gt; None:\n        \"\"\"Set the title of the Rule.\"\"\"\n        if value is not None and not isinstance(value, (str, RichText, Text)):\n            raise TypeError(\n                f\"title must be str, RichText, or Text, got {type(value).__name__}\"\n            )\n        self._title = value\n\n    @property\n    def title_style(self) -&gt; Optional[StyleType]:\n        \"\"\"Get the title style of the Rule's title.\"\"\"\n        return self._title_style or None\n\n    @title_style.setter\n    def title_style(self, value: Optional[StyleType]) -&gt; None:\n        \"\"\"Set the title style of the Rule's title.\"\"\"\n        if value is not None and not isinstance(value, (str, Style)):\n            raise TypeError(\n                f\"title_style must be str or Style, got {type(value).__name__}\"\n            )\n        self._title_style = Style.parse(str(value)) if value is not None else None\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n        \"\"\"Render the rule using the underlying RichRule at full width and\n        apply gradient coloring using Gradient utilities.\n\n        This overrides the base Gradient alignment wrapper to ensure the\n        RichRule expands to the console width (so the line isn't collapsed\n        to a single character when aligned/padded externally).\n        \"\"\"\n        # Render underlying content directly (no Align wrapper)\n        content = self.renderables[0] if self.renderables else \"\"\n        width = options.max_width\n\n        lines = console.render_lines(content, options, pad=True, new_lines=False)\n        for line_index, segments in enumerate(lines):\n            highlight_map = None\n            if self._highlight_rules:\n                line_text = \"\".join(segment.text for segment in segments)\n                highlight_map = self._build_highlight_map(line_text)\n            column = 0\n            char_index = 0\n            for seg in segments:\n                text = seg.text\n                base_style = seg.style or Style()\n                cluster = \"\"\n                cluster_width = 0\n                cluster_indices: list[int] = []\n                for character in text:\n                    current_index = char_index\n                    char_index += 1\n                    character_width = get_character_cell_size(character)\n                    if character_width &lt;= 0:\n                        cluster += character\n                        cluster_indices.append(current_index)\n                        continue\n                    if cluster:\n                        style = self._get_style_at_position(\n                            column - cluster_width, cluster_width, width\n                        )\n                        merged_style = self._merge_styles(base_style, style)\n                        merged_style = self._apply_highlight_style(\n                            merged_style, highlight_map, cluster_indices\n                        )\n                        yield Segment(cluster, merged_style)\n                        cluster = \"\"\n                        cluster_width = 0\n                        cluster_indices = []\n                    cluster = character\n                    cluster_width = character_width\n                    cluster_indices = [current_index]\n                    column += character_width\n                if cluster:\n                    style = self._get_style_at_position(\n                        column - cluster_width, cluster_width, width\n                    )\n                    merged_style = self._merge_styles(base_style, style)\n                    merged_style = self._apply_highlight_style(\n                        merged_style, highlight_map, cluster_indices\n                    )\n                    yield Segment(cluster, merged_style)\n            if line_index &lt; len(lines) - 1:\n                yield Segment.line()\n        # Ensure a trailing newline after the rule so following content appears below\n        yield Segment.line()\n</code></pre>"},{"location":"rule_ref/#rich_gradient.rule.Rule.characters","title":"<code>characters</code>  <code>property</code> <code>writable</code>","text":"<p>Get the character used for the rule line.</p>"},{"location":"rule_ref/#rich_gradient.rule.Rule.thickness","title":"<code>thickness</code>  <code>property</code> <code>writable</code>","text":"<p>Get the thickness of the Rule.</p>"},{"location":"rule_ref/#rich_gradient.rule.Rule.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Get the title of the Rule.</p>"},{"location":"rule_ref/#rich_gradient.rule.Rule.title_style","title":"<code>title_style</code>  <code>property</code> <code>writable</code>","text":"<p>Get the title style of the Rule's title.</p>"},{"location":"rule_ref/#rich_gradient.rule.Rule.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render the rule using the underlying RichRule at full width and apply gradient coloring using Gradient utilities.</p> <p>This overrides the base Gradient alignment wrapper to ensure the RichRule expands to the console width (so the line isn't collapsed to a single character when aligned/padded externally).</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def __rich_console__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; RenderResult:\n    \"\"\"Render the rule using the underlying RichRule at full width and\n    apply gradient coloring using Gradient utilities.\n\n    This overrides the base Gradient alignment wrapper to ensure the\n    RichRule expands to the console width (so the line isn't collapsed\n    to a single character when aligned/padded externally).\n    \"\"\"\n    # Render underlying content directly (no Align wrapper)\n    content = self.renderables[0] if self.renderables else \"\"\n    width = options.max_width\n\n    lines = console.render_lines(content, options, pad=True, new_lines=False)\n    for line_index, segments in enumerate(lines):\n        highlight_map = None\n        if self._highlight_rules:\n            line_text = \"\".join(segment.text for segment in segments)\n            highlight_map = self._build_highlight_map(line_text)\n        column = 0\n        char_index = 0\n        for seg in segments:\n            text = seg.text\n            base_style = seg.style or Style()\n            cluster = \"\"\n            cluster_width = 0\n            cluster_indices: list[int] = []\n            for character in text:\n                current_index = char_index\n                char_index += 1\n                character_width = get_character_cell_size(character)\n                if character_width &lt;= 0:\n                    cluster += character\n                    cluster_indices.append(current_index)\n                    continue\n                if cluster:\n                    style = self._get_style_at_position(\n                        column - cluster_width, cluster_width, width\n                    )\n                    merged_style = self._merge_styles(base_style, style)\n                    merged_style = self._apply_highlight_style(\n                        merged_style, highlight_map, cluster_indices\n                    )\n                    yield Segment(cluster, merged_style)\n                    cluster = \"\"\n                    cluster_width = 0\n                    cluster_indices = []\n                cluster = character\n                cluster_width = character_width\n                cluster_indices = [current_index]\n                column += character_width\n            if cluster:\n                style = self._get_style_at_position(\n                    column - cluster_width, cluster_width, width\n                )\n                merged_style = self._merge_styles(base_style, style)\n                merged_style = self._apply_highlight_style(\n                    merged_style, highlight_map, cluster_indices\n                )\n                yield Segment(cluster, merged_style)\n        if line_index &lt; len(lines) - 1:\n            yield Segment.line()\n    # Ensure a trailing newline after the rule so following content appears below\n    yield Segment.line()\n</code></pre>"},{"location":"spectrum/","title":"Spectrum","text":"<p><code>rich_gradient.spectrum.Spectrum</code> builds reusable color palettes for the rest of the package. It produces Rich <code>Color</code>, <code>Style</code>, and <code>ColorTriplet</code> objects and renders itself as a handy preview table.</p> <p></p> <pre><code>from rich.console import Console\nfrom rich_gradient.spectrum import Spectrum\n\nconsole = Console()\nspectrum = Spectrum(hues=8, seed=42)\nconsole.print(spectrum, justify=\"center\")\n\n# Use the palette elsewhere\npalette = spectrum.triplets  # feed into Text/Gradient colors\nhex_codes = spectrum.hex\n</code></pre> <p>Key options:</p> <ul> <li><code>hues</code>: number of colors to produce (minimum 2).</li> <li><code>invert</code>: reverse the resulting palette.</li> <li><code>seed</code>: control reproducibility without disturbing the global random state.</li> </ul> <p>Internally <code>rich-gradient</code> relies on <code>Spectrum</code> whenever it needs to auto-generate color stops (for example, <code>Text(hues=5)</code> or <code>Gradient(rainbow=True)</code>).</p>"},{"location":"spectrum_ref/","title":"Spectrum Reference","text":"<p>Create a list of concurrent Color and/or Style instances. Args:     hues (int): Number of colors to generate. Defaults to 17.     invert (bool, optional): If True, reverse the generated list.         Defaults to False.     seed (Optional[int], optional): If provided, sets the random seed for deterministic color order. Raises:     ValueError: If hues &lt; 2.     ValueError: If seed is not None and not an integer. Properties:     colors (List[Color]): List of Color instances.     names (List[str]): List of color names.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>class Spectrum:\n    \"\"\"Create a list of concurrent Color and/or Style instances.\n    Args:\n        hues (int): Number of colors to generate. Defaults to 17.\n        invert (bool, optional): If True, reverse the generated list.\n            Defaults to False.\n        seed (Optional[int], optional): If provided, sets the random \\\nseed for deterministic color order.\n    Raises:\n        ValueError: If hues &lt; 2.\n        ValueError: If seed is not None and not an integer.\n    Properties:\n        colors (List[Color]): List of Color instances.\n        names (List[str]): List of color names.\n\n    \"\"\"\n\n    def __init__(\n        self, hues: int = 17, invert: bool = False, seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Initialize the Spectrum with a specified number of hues and optional \\\ninversion and seed.\n        Args:\n            hues (int): Number of colors to generate. Defaults to 17.\n            invert (bool, optional): If True, reverse the generated list.\n                Defaults to False.\n            seed (Optional[int], optional): If provided, sets the random seed for \\\ndeterministic color order.\n        Raises:\n            ValueError: If hues &lt; 2.\n            ValueError: If seed is not None and not an integer.\n        \"\"\"\n        if hues &lt; 2:\n            raise ValueError(\"hues must be at least 2\")\n        if hues &gt; len(COLOR_STOPS):\n            raise ValueError(f\"hues must be at most {len(COLOR_STOPS)}\")\n        if seed is not None and not isinstance(seed, int):\n            raise ValueError(\"seed must be an integer or None\")\n\n        # Use a dedicated RNG to avoid mutating global random state\n        rng = Random(seed)\n\n        # Generate a random cycle of colors from the spectrum\n        colors: List[Color] = [Color.parse(color) for color in COLOR_STOPS.values()]\n        color_cycle = cycle(colors)\n\n        # Skip a pseudo-random number of colors to add variability, deterministically per seed\n        for _ in range(rng.randint(1, 18)):\n            next(color_cycle)\n\n        # Create a list of colors based on the specified number of hues\n        colors = [next(color_cycle) for _ in range(hues)]\n        self.colors = colors\n        if invert:\n            self.colors.reverse()\n\n        # Set names based on COLOR_STOPS mapping\n        # Build a reverse map from normalized hex -&gt; name and assign names for the selected colors\n\n        hex_to_name = {\n            Color.parse(value).get_truecolor().hex.upper(): name\n            for name, value in COLOR_STOPS.items()\n        }\n        self.names = [\n            hex_to_name.get(color.get_truecolor().hex.upper(), color.get_truecolor().hex.upper())\n            for color in self.colors\n        ]\n\n\n        self.styles = [\n            Style(color=color, bold=False, italic=False, underline=False)\n            for color in self.colors\n        ]\n        self.hex = [color.get_truecolor().hex.upper() for color in self.colors]\n\n    @property\n    def colors(self) -&gt; List[Color]:\n        \"\"\"Return the list of Color instances.\"\"\"\n        return self._colors\n\n    @colors.setter\n    def colors(self, value: List[Color]) -&gt; None:\n        \"\"\"Set the list of Color instances.\"\"\"\n        if not isinstance(value, list) or not all(isinstance(c, Color) for c in value):\n            raise ValueError(\"colors must be a list of Color instances\")\n        if len(value) &lt; 2:\n            raise ValueError(\"colors must contain at least two Color instances\")\n        self._colors = value\n\n    @property\n    def triplets(self) -&gt; List[ColorTriplet]:\n        \"\"\"Return the list of ColorTriplet instances.\"\"\"\n        return [color.get_truecolor() for color in self._colors]\n\n    @property\n    def styles(self) -&gt; List[Style]:\n        \"\"\"Return the list of Style instances.\"\"\"\n        return self._styles\n\n    @styles.setter\n    def styles(self, styles: List[StyleType]) -&gt; None:\n        \"\"\"Set the list of Style instances.\"\"\"\n        if not isinstance(styles, list) or not all(\n            isinstance(s, Style) for s in styles\n        ):\n            raise ValueError(\"styles must be a list of Style instances\")\n        if len(styles) != len(self.colors):\n            raise ValueError(\"styles length must match colors length\")\n        parsed_styles: List[Style] = []\n        for style in styles:\n            if isinstance(style, (str)):\n                parsed_styles.append(Style.parse(style))\n            if isinstance(style, Style):\n                parsed_styles.append(style)\n        self._styles = parsed_styles\n\n    @property\n    def names(self) -&gt; List[str]:\n        \"\"\"Return the list of color names.\"\"\"\n        return self._names\n\n    @names.setter\n    def names(self, value: List[str]) -&gt; None:\n        \"\"\"Set the list of color names.\"\"\"\n        if not isinstance(value, list) or not all(isinstance(n, str) for n in value):\n            raise ValueError(\"names must be a list of strings\")\n        if len(value) != len(self._colors):\n            raise ValueError(\"names length must match colors length\")\n        self._names = value\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Spectrum.\"\"\"\n        colors = [f\"{name}\" for name in self.names]\n        colors_str = \", \".join(colors)\n        return f\"Spectrum({colors_str})\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of colors in the Spectrum.\"\"\"\n        return len(self.colors)\n\n    def __getitem__(self, index: int) -&gt; Color:\n        \"\"\"Return the Color at the specified index.\"\"\"\n        if not isinstance(index, int):\n            raise TypeError(\"Index must be an integer\")\n        if index &lt; 0 or index &gt;= len(self.colors):\n            raise IndexError(\"Index out of range\")\n        return self.colors[index]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the colors in the Spectrum.\"\"\"\n        return iter(self.colors)\n\n    def __rich__(self) -&gt; Table:\n        \"\"\"Return a rich Table representation of the Spectrum.\"\"\"\n\n        def rainbow_title(text: str) -&gt; Text:\n            chunks = [text[i : i + 2] for i in range(0, len(text), 2)]\n            pieces: List[Text] = []\n            for idx, chunk in enumerate(chunks):\n                color = self.colors[idx % len(self.colors)]\n                hex_code = color.get_truecolor().hex\n                pieces.append(Text(chunk, style=f\"b u {hex_code}\"))\n            return Text.assemble(*pieces)\n\n        table = Table(title=rainbow_title(\"Spectrum Colors\"))\n        table.add_column(\n            rainbow_title(\"Sample\"), justify=\"center\")\n        table.add_column(rainbow_title(\"Color\"), style=\"bold\")\n        table.add_column(rainbow_title(\"Hex\"), style=\"bold\")\n        table.add_column(rainbow_title(\"Name\"), style=\"bold\")\n\n        for color, name in zip(self.colors, self.names):\n            hex_code = color.get_truecolor().hex\n            red = color.get_truecolor().red\n            green = color.get_truecolor().green\n            blue = color.get_truecolor().blue\n\n            name_text = Text(\n                name.capitalize(),\n                Style(color=hex_code, bold=True),\n                no_wrap=True,\n                justify=\"left\",\n            )\n            hex_text = Text(\n                f\" {hex_code.upper()} \",\n                Style(bgcolor=hex_code, color=\"#000000\", bold=True),\n                no_wrap=True,\n                justify=\"center\",\n            )\n            rgb_text = Text.assemble(*[\n                Text(\"rgb\", style=f\"bold {hex_code}\"),\n                Text(\"(\", style=\"i white\"),\n                Text(f\"{red:&gt;3}\", style=\"#FF0000\"),\n                Text(\",\", style=\"i #555\"),\n                Text(f\"{green:&gt;3}\", style=\"#00FF00\"),\n                Text(\",\", style=\"i #555\"),\n                Text(f\"{blue:&gt;3}\", style=\"#00AAFF\"),\n                Text(\")\", style=\"i white\"),\n            ])\n            sample = Text(\"\u2588\" * 10, style=Style(color=hex_code, bold=True))\n            table.add_row(sample, name_text, hex_text, rgb_text)\n        return table\n\n    @property\n    def rich(self) -&gt; Table:\n        \"\"\"Return the rich Table representation of the Spectrum.\"\"\"\n        return self.__rich__()\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of Color instances.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.names","title":"<code>names</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of color names.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.rich","title":"<code>rich</code>  <code>property</code>","text":"<p>Return the rich Table representation of the Spectrum.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.styles","title":"<code>styles</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of Style instances.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.triplets","title":"<code>triplets</code>  <code>property</code>","text":"<p>Return the list of ColorTriplet instances.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Return the Color at the specified index.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Color:\n    \"\"\"Return the Color at the specified index.\"\"\"\n    if not isinstance(index, int):\n        raise TypeError(\"Index must be an integer\")\n    if index &lt; 0 or index &gt;= len(self.colors):\n        raise IndexError(\"Index out of range\")\n    return self.colors[index]\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__init__","title":"<code>__init__(hues=17, invert=False, seed=None)</code>","text":"<p>Initialize the Spectrum with a specified number of hues and optional inversion and seed. Args:     hues (int): Number of colors to generate. Defaults to 17.     invert (bool, optional): If True, reverse the generated list.         Defaults to False.     seed (Optional[int], optional): If provided, sets the random seed for deterministic color order. Raises:     ValueError: If hues &lt; 2.     ValueError: If seed is not None and not an integer.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>    def __init__(\n        self, hues: int = 17, invert: bool = False, seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Initialize the Spectrum with a specified number of hues and optional \\\ninversion and seed.\n        Args:\n            hues (int): Number of colors to generate. Defaults to 17.\n            invert (bool, optional): If True, reverse the generated list.\n                Defaults to False.\n            seed (Optional[int], optional): If provided, sets the random seed for \\\ndeterministic color order.\n        Raises:\n            ValueError: If hues &lt; 2.\n            ValueError: If seed is not None and not an integer.\n        \"\"\"\n        if hues &lt; 2:\n            raise ValueError(\"hues must be at least 2\")\n        if hues &gt; len(COLOR_STOPS):\n            raise ValueError(f\"hues must be at most {len(COLOR_STOPS)}\")\n        if seed is not None and not isinstance(seed, int):\n            raise ValueError(\"seed must be an integer or None\")\n\n        # Use a dedicated RNG to avoid mutating global random state\n        rng = Random(seed)\n\n        # Generate a random cycle of colors from the spectrum\n        colors: List[Color] = [Color.parse(color) for color in COLOR_STOPS.values()]\n        color_cycle = cycle(colors)\n\n        # Skip a pseudo-random number of colors to add variability, deterministically per seed\n        for _ in range(rng.randint(1, 18)):\n            next(color_cycle)\n\n        # Create a list of colors based on the specified number of hues\n        colors = [next(color_cycle) for _ in range(hues)]\n        self.colors = colors\n        if invert:\n            self.colors.reverse()\n\n        # Set names based on COLOR_STOPS mapping\n        # Build a reverse map from normalized hex -&gt; name and assign names for the selected colors\n\n        hex_to_name = {\n            Color.parse(value).get_truecolor().hex.upper(): name\n            for name, value in COLOR_STOPS.items()\n        }\n        self.names = [\n            hex_to_name.get(color.get_truecolor().hex.upper(), color.get_truecolor().hex.upper())\n            for color in self.colors\n        ]\n\n\n        self.styles = [\n            Style(color=color, bold=False, italic=False, underline=False)\n            for color in self.colors\n        ]\n        self.hex = [color.get_truecolor().hex.upper() for color in self.colors]\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the colors in the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterator over the colors in the Spectrum.\"\"\"\n    return iter(self.colors)\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of colors in the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of colors in the Spectrum.\"\"\"\n    return len(self.colors)\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Spectrum.\"\"\"\n    colors = [f\"{name}\" for name in self.names]\n    colors_str = \", \".join(colors)\n    return f\"Spectrum({colors_str})\"\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__rich__","title":"<code>__rich__()</code>","text":"<p>Return a rich Table representation of the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __rich__(self) -&gt; Table:\n    \"\"\"Return a rich Table representation of the Spectrum.\"\"\"\n\n    def rainbow_title(text: str) -&gt; Text:\n        chunks = [text[i : i + 2] for i in range(0, len(text), 2)]\n        pieces: List[Text] = []\n        for idx, chunk in enumerate(chunks):\n            color = self.colors[idx % len(self.colors)]\n            hex_code = color.get_truecolor().hex\n            pieces.append(Text(chunk, style=f\"b u {hex_code}\"))\n        return Text.assemble(*pieces)\n\n    table = Table(title=rainbow_title(\"Spectrum Colors\"))\n    table.add_column(\n        rainbow_title(\"Sample\"), justify=\"center\")\n    table.add_column(rainbow_title(\"Color\"), style=\"bold\")\n    table.add_column(rainbow_title(\"Hex\"), style=\"bold\")\n    table.add_column(rainbow_title(\"Name\"), style=\"bold\")\n\n    for color, name in zip(self.colors, self.names):\n        hex_code = color.get_truecolor().hex\n        red = color.get_truecolor().red\n        green = color.get_truecolor().green\n        blue = color.get_truecolor().blue\n\n        name_text = Text(\n            name.capitalize(),\n            Style(color=hex_code, bold=True),\n            no_wrap=True,\n            justify=\"left\",\n        )\n        hex_text = Text(\n            f\" {hex_code.upper()} \",\n            Style(bgcolor=hex_code, color=\"#000000\", bold=True),\n            no_wrap=True,\n            justify=\"center\",\n        )\n        rgb_text = Text.assemble(*[\n            Text(\"rgb\", style=f\"bold {hex_code}\"),\n            Text(\"(\", style=\"i white\"),\n            Text(f\"{red:&gt;3}\", style=\"#FF0000\"),\n            Text(\",\", style=\"i #555\"),\n            Text(f\"{green:&gt;3}\", style=\"#00FF00\"),\n            Text(\",\", style=\"i #555\"),\n            Text(f\"{blue:&gt;3}\", style=\"#00AAFF\"),\n            Text(\")\", style=\"i white\"),\n        ])\n        sample = Text(\"\u2588\" * 10, style=Style(color=hex_code, bold=True))\n        table.add_row(sample, name_text, hex_text, rgb_text)\n    return table\n</code></pre>"},{"location":"text/","title":"Text","text":"<p><code>rich_gradient.Text</code> (available as <code>rich_gradient.text.Text</code>) extends <code>rich.text.Text</code> with foreground and background gradients while preserving every feature from the base class (markup, spans, justification, overflow handling, highlighting, etc.). Anywhere you would normally construct a <code>rich.text.Text</code>, you can drop in this subclass to gain gradient support.</p>"},{"location":"text/#basic-usage","title":"Basic usage","text":"<pre><code>from rich.console import Console\nfrom rich_gradient import Text\n\nconsole = Console()\nconsole.print(\n    Text(\n        \"Gradient text with zero fuss.\",\n        colors=[\"#38bdf8\", \"#a855f7\", \"#f97316\"],\n        style=\"bold\",\n    )\n)\n</code></pre> <p>The output above is generated by <code>examples/text_quickstart.py</code> and captured as <code>docs/img/text-quickstart.svg</code>.</p>"},{"location":"text/#picking-color-stops","title":"Picking color stops","text":"<p>Pass <code>colors</code> to control foreground stops. Every item can be a CSS color name, a hex string, an RGB tuple, a <code>rich.color.Color</code>, or a <code>ColorTriplet</code>. When <code>colors</code> is empty the class falls back to <code>Spectrum</code> with the requested <code>hues</code>. Set <code>rainbow=True</code> to use the full rainbow palette.</p> <p></p> <pre><code>from rich_gradient.spectrum import Spectrum\nfrom rich_gradient import Text\n\nText(\"Explicit stops\", colors=[\"#0ea5e9\", \"#a855f7\", \"#f97316\"])\nText(\"Auto hues\", hues=6)  # draws from Spectrum(hues=6)\nText(\"Spectrum seed\", colors=Spectrum(hues=5, seed=7).triplets)\n</code></pre> <p>Behind the scenes <code>rich-gradient</code> relies on rich-color-ext so three-digit hex codes and CSS color names resolve without extra work.</p>"},{"location":"text/#background-gradients","title":"Background gradients","text":"<p>Use <code>bgcolors</code> to gradient-fill the background independently. Single background colors are treated as a solid fill, while multiple stops interpolate smoothly.</p> <p></p> <pre><code>Text(\n    \"Foreground &amp; background gradient\",\n    colors=[\"#2563eb\", \"#ec4899\"],\n    bgcolors=[\"#0f172a\", \"#1f2937\"],\n)\nText(\"Rainbow with solid background\", rainbow=True, bgcolors=[\"#111827\"])\nText(\"Background-only gradient\", colors=[\"#f1f5f9\"], bgcolors=[\"#22d3ee\", \"#f97316\"])\n</code></pre> <p>Set <code>Text(..., markup=False)</code> when you want to treat the input literally rather than parsing Rich markup. You can still call <code>.stylize()</code> or provide <code>spans</code> explicitly if you need fine-grained styling.</p>"},{"location":"text/#round-tripping-to-richtexttext","title":"Round-tripping to <code>rich.text.Text</code>","text":"<p>Need to hand control back to Rich? Call <code>.as_rich()</code> to return a standard <code>rich.text.Text</code> instance with the gradient-applied content and spans:</p> <pre><code>text = Text(\"Gradient once, regular Text later.\", hues=5)\nrich_text = text.as_rich()\n</code></pre> <p>This is useful when you want to serialize the output or reuse it in renderables that expect a plain <code>Text</code>.</p>"},{"location":"text/#animated-text","title":"Animated text","text":"<p>For live gradients, use <code>AnimatedText</code> which wraps <code>rich.text.Text</code> and animates the gradient phase over time.</p> <pre><code>from rich_gradient.animated_text import AnimatedText\n\nAnimatedText(\"Live text\", rainbow=True, duration=3).run()\n</code></pre>"},{"location":"text_ref/","title":"Text","text":"<p>               Bases: <code>Text</code></p> <p>A rich text class that supports gradient colors and styles.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>class Text(RichText):\n    \"\"\"A rich text class that supports gradient colors and styles.\"\"\"\n\n    def __init__(\n        self,\n        text: TextType = \"\",\n        colors: Optional[Sequence[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n        style: StyleType = \"\",\n        justify: JustifyMethod = \"default\",\n        overflow: OverflowMethod = \"fold\",\n        no_wrap: bool = False,\n        end: str = \"\\n\",\n        tab_size: int = 4,\n        bg_colors: Optional[Sequence[ColorType]] = None,\n        markup: bool = True,\n        spans: Optional[Sequence[Span]] = None,\n    ):\n        \"\"\"Initialize the Text with gradient colors and styles.\n        Args:\n            text (TextType): The text content.\n            colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n            rainbow (bool): If True, generate a rainbow spectrum.\n            hues (int): The number of hues to generate if colors are not provided.\n            style (StyleType): The style of the text.\n            justify (JustifyMethod): Justification method for the text. Defaults to `default`.\n            overflow (OverflowMethod): Overflow method for the text. Defaults to `fold`.\n            no_wrap (bool): If True, disable wrapping of the text. Defaults to False.\n            end (str): The string to append at the end of the text. Default is a newline (`\\\\n`).\n            tab_size (int): The number of spaces for a tab character. Defaults to 4.\n            bg_colors (Optional[List[ColorType]]): A list of background colors as Color \\\ninstances. Defaults to None.\n            markup (bool): If True, parse Rich markup tags in the input text. Defaults to True.\n            spans (Optional[Sequence[Span]]): A list of spans to apply to the text. \\\n            Defaults to None.\n        \"\"\"\n\n        # Parse the input text with or without markup\n        if markup:\n            parsed_text = RichText.from_markup(\n                text=str(text), style=style, justify=justify, overflow=overflow\n            )\n        else:\n            parsed_text = RichText(\n                strip_control_codes(str(text)),\n                style=style,\n                justify=justify,\n                overflow=overflow,\n            )\n\n        # Extract parsed attributes\n        plain = parsed_text.plain\n        parsed_justify = parsed_text.justify\n        parsed_overflow = parsed_text.overflow\n        parsed_spans = parsed_text._spans\n\n        # Initialize the parent class\n        super().__init__(\n            plain,\n            style=style,\n            justify=parsed_justify,\n            overflow=parsed_overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            spans=parsed_spans,\n        )\n        self._interpolate_bg_colors = False  # Ensure flag is always initialized\n        # Normalize color inputs into rich.color.Color instances\n        self.colors = self.parse_colors(colors, hues, rainbow)\n        self.bg_colors = self.parse_bg_colors(bg_colors)\n\n        # Handle the single-color and single-background case: apply style directly and return early\n        if len(self.colors) == 1 and len(self.bg_colors) == 1:\n            # Apply the single color style directly, honoring a missing style definition.\n            if isinstance(style, Style):\n                base_style = style\n            elif isinstance(style, str) and style:\n                base_style = Style.parse(style)\n            else:\n                base_style = Style.null()\n            color_layer = Style(color=self.colors[0], bgcolor=self.bg_colors[0])\n            style_with_color = color_layer + base_style\n            for index in range(len(self.plain)):\n                self.stylize(style_with_color, index, index + 1)\n            return\n\n        # Apply the gradient coloring\n        self.apply_gradient()\n\n    @property\n    def colors(self) -&gt; list[Color]:\n        \"\"\"Return the list of colors in the gradient.\"\"\"\n        return list(self._colors) if self._colors else []\n\n    @colors.setter\n    def colors(self, value: Optional[Sequence[Color]]) -&gt; None:\n        \"\"\"Set the list of colors in the gradient.\"\"\"\n        self._colors = list(value) if value else []\n\n    @property\n    def bg_colors(self) -&gt; list[Color]:\n        \"\"\"Return the list of background colors in the gradient.\"\"\"\n        return list(self._bg_colors) if self._bg_colors else []\n\n    @bg_colors.setter\n    def bg_colors(self, value: Optional[Sequence[Color]]) -&gt; None:\n        \"\"\"Set the list of background colors in the gradient.\"\"\"\n        self._bg_colors = list(value) if value else []\n\n    @staticmethod\n    def _normalize_color(value: ColorType) -&gt; Color:\n        \"\"\"Normalize a single color-like value to a rich.color.Color.\n        Accepts: Color, ColorTriplet, 3-tuple of ints, or string parsable\n        by Color.parse. Note that rich-color-ext expands what is considered\n        a valid color input.\n\n        Args:\n            value (ColorType): The color-like value to normalize.\n        Returns:\n            Color: The normalized Color instance.\n        Raises:\n            ColorParseError: If the color value cannot be parsed.\n        \"\"\"\n        try:\n            if isinstance(value, Color):\n                return value\n            elif isinstance(value, ColorTriplet):\n                return Color.from_rgb(value.red, value.green, value.blue)\n            elif isinstance(value, tuple) and len(value) == 3:\n                r, g, b = value\n                return Color.from_rgb(int(r), int(g), int(b))\n            elif isinstance(value, str):\n                return Color.parse(value)\n            else:\n                # Reject unsupported types explicitly (e.g., int, None)\n                raise TypeError(f\"Unsupported color type: {type(value)!r}\")\n        except ColorParseError as cpe:\n            raise ColorParseError(\n                f\"Failed to parse and normalize color: {value}\"\n            ) from cpe\n\n    @staticmethod\n    def parse_colors(\n        colors: Optional[Sequence[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of colors for the gradient.\n        Supports:\n        - rgb colors (e.g. `'rgb(255, 0, 0)'`)\n        - rgb tuples (e.g., `(255, 0, 0)`)\n        - 3-digit hex colors (e.g., `'#f00'`, `'#F90'`)\n        - 6-digit hex colors (e.g., `'#ff0000'`, `'#00FF00'`)\n        - CSS names (e.g., `'red'`, `'aliceblue'`)\n        - rich.color.Color objects (e.g., `Color.parse('#FF0000')`)\n        Args:\n            colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color\n                instances, tuples of integers, or strings.\n            hues (int): The number of hues to generate if colors are not provided. Defaults to 5.\n            rainbow (bool): Whether to generate a rainbow spectrum. Note that rainbow overrides\n                any colors or hues provided. Defaults to False\n        Raises:\n            ColorParseError: If any color value cannot be parsed.\n            ValueError: If no colors are provided, rainbow is False, and hues &lt; 2.\n        Returns:\n            List[rich.color.Color]: A list of Color objects.\n        \"\"\"\n        # When rainbow is True, we use a full 17-color spectrum\n        if rainbow:\n            return Spectrum(hues=17).colors\n\n        # If no colors are provided, fall back to Spectrum with the specified hues\n        if colors is None or len(colors) == 0:\n            if hues &lt; 2:\n                raise ValueError(\n                    f\"If `rainbow=False` and no colors are provided, hues must be \\\nat least 2. Invalid hues value: {hues}\"\n                )\n            return Spectrum(hues).colors\n\n        # If we have colors, parse and normalize them\n        parsed: List[Color] = []\n        for c in colors:\n            try:\n                parsed.append(Text._normalize_color(c))\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported color value: {c}\") from exc\n        return parsed\n\n    def parse_bg_colors(\n        self, bg_colors: Optional[Sequence[ColorType]] = None\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of background colors for the gradient.\n        Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, \\\n        and Color objects.\n        Args:\n            bg_colors (Optional[Sequence[ColorType | Color]]): A list of background colors as \\\n            Color instances or strings.\n            hues (int): The number of hues to generate if bgcolors are not provided.\n        Returns:\n            List[Color]: A list of Color objects for background colors.\n        \"\"\"\n        if not bg_colors:\n            self._interpolate_bg_colors = False\n            # Default to transparent/default background per character count\n            fallback = Color.parse(\"default\")\n            color_count = max(1, len(self.colors))\n            return [fallback] * color_count\n\n        if len(bg_colors) == 1:\n            # If only one background color is provided, do not interpolate\n            self._interpolate_bg_colors = False\n            c = bg_colors[0]\n            try:\n                normalized = Text._normalize_color(c)\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n            return [normalized] * max(1, len(self.colors))\n\n        # Multiple bg_colors: interpolate across provided stops\n        self._interpolate_bg_colors = True\n        parsed_bg: List[Color] = []\n        for c in bg_colors:\n            try:\n                parsed_bg.append(Text._normalize_color(c))\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n        return parsed_bg\n\n    def interpolate_colors(\n        self, colors: Optional[Sequence[Color]] = None\n    ) -&gt; list[Color]:\n        \"\"\"Interpolate colors across the text using gamma-correct blending.\"\"\"\n        colors = list(colors) if colors is not None else self.colors\n        if not colors:\n            raise ValueError(\"No colors to interpolate\")\n\n        text = self.plain\n        length = len(text)\n        if length == 0:\n            return []\n        num_colors = len(colors)\n        if num_colors == 1:\n            return [colors[0]] * length\n\n        segments = num_colors - 1\n        result: List[Color] = []\n\n        GAMMA = 2.2\n\n        def to_linear(v: int) -&gt; float:\n            return (v / 255.0) ** GAMMA\n\n        def to_srgb(x: float) -&gt; int:\n            return int(((x ** (1.0 / GAMMA)) * 255.0))\n\n        for i in range(length):\n            pos = i / (length - 1) if length &gt; 1 else 0.0\n            fidx = pos * segments\n            idx = int(fidx)\n            if idx &gt;= segments:\n                idx = segments - 1\n                t = 1.0\n            else:\n                t = fidx - idx\n\n            c0 = colors[idx].get_truecolor()\n            c1 = colors[idx + 1].get_truecolor()\n\n            lr = to_linear(c0.red) + (to_linear(c1.red) - to_linear(c0.red)) * t\n            lg = to_linear(c0.green) + (to_linear(c1.green) - to_linear(c0.green)) * t\n            lb = to_linear(c0.blue) + (to_linear(c1.blue) - to_linear(c0.blue)) * t\n\n            r, g, b = to_srgb(lr), to_srgb(lg), to_srgb(lb)\n            result.append(Color.from_rgb(r, g, b))\n\n        return result\n\n    def apply_gradient(self) -&gt; None:\n        \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n        # Generate a color for each character\n        colors = self.interpolate_colors(self.colors)\n        if self._interpolate_bg_colors:\n            # Generate a background color for each character if bg_colors are interpolated\n            bg_colors = self.interpolate_colors(self.bg_colors)\n        else:\n            # If not interpolating background colors, use the first bg_color for all characters\n            bg_colors = [self.bg_colors[0]] * len(colors)\n        # Apply a style span for each character with its corresponding color\n        for index, (color, bg_color) in enumerate(zip(colors, bg_colors)):\n            # Build a style with the interpolated color\n            span_style = Style(color=color, bgcolor=bg_color)\n            # Stylize the single character range\n            self.stylize(span_style, index, index + 1)\n\n    def as_rich(self) -&gt; RichText:\n        \"\"\"Return a plain ``rich.text.Text`` with styles and spans applied.\n\n        This converts the current gradient-aware ``Text`` into a base\n        ``rich.text.Text`` carrying the same plain content and span/style\n        information. Useful when a consumer specifically needs the base type.\n        \"\"\"\n        # Create a plain RichText that mirrors the source content and layout\n        rich_text = RichText(\n            self.plain,\n            style=self.style,\n            justify=self.justify,\n            overflow=self.overflow,\n            no_wrap=self.no_wrap,\n            end=self.end,\n            tab_size=self.tab_size,\n        )\n\n        # Copy internal spans from the source into the returned RichText.\n        # Using the internal _spans attribute is acceptable here since both\n        # classes share the same underlying implementation in rich.\n        for span in getattr(self, \"_spans\", []):\n            rich_text._spans.append(span)\n\n        return rich_text\n\n    @property\n    def rich(self) -&gt; RichText:\n        \"\"\"Return the underlying RichText instance.\"\"\"\n        return self.as_rich()\n\n    def __rich_console__(self, console: Console, options) -&gt; Iterable[Segment]:\n        \"\"\"Render Text while suppressing any output for empty content.\n\n        For empty plain text, yield no segments at all (no stray newlines).\n        Otherwise, delegate to the parent implementation and filter a final\n        trailing `end` segment as required.\n        \"\"\"\n        if self.plain == \"\":\n            return\n        for render_output in super().__rich_console__(console, options):\n            if isinstance(render_output, Segment):\n                # For empty Text,\n                # filter out both the empty text Segment and the trailing end Segment.\n                if self.plain == \"\" and render_output.text in (\"\", self.end):\n                    continue\n                yield render_output\n            else:\n                # Render nested renderable to segments, filter as needed\n                for seg in console.render(render_output, options):\n                    if self.plain == \"\" and seg.text in (\"\", self.end):\n                        continue\n                    yield seg\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.bg_colors","title":"<code>bg_colors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of background colors in the gradient.</p>"},{"location":"text_ref/#rich_gradient.text.Text.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of colors in the gradient.</p>"},{"location":"text_ref/#rich_gradient.text.Text.rich","title":"<code>rich</code>  <code>property</code>","text":"<p>Return the underlying RichText instance.</p>"},{"location":"text_ref/#rich_gradient.text.Text.__init__","title":"<code>__init__(text='', colors=None, hues=5, rainbow=False, style='', justify='default', overflow='fold', no_wrap=False, end='\\n', tab_size=4, bg_colors=None, markup=True, spans=None)</code>","text":"<p>Initialize the Text with gradient colors and styles. Args:     text (TextType): The text content.     colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.     rainbow (bool): If True, generate a rainbow spectrum.     hues (int): The number of hues to generate if colors are not provided.     style (StyleType): The style of the text.     justify (JustifyMethod): Justification method for the text. Defaults to <code>default</code>.     overflow (OverflowMethod): Overflow method for the text. Defaults to <code>fold</code>.     no_wrap (bool): If True, disable wrapping of the text. Defaults to False.     end (str): The string to append at the end of the text. Default is a newline (<code>\\n</code>).     tab_size (int): The number of spaces for a tab character. Defaults to 4.     bg_colors (Optional[List[ColorType]]): A list of background colors as Color instances. Defaults to None.     markup (bool): If True, parse Rich markup tags in the input text. Defaults to True.     spans (Optional[Sequence[Span]]): A list of spans to apply to the text.             Defaults to None.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>    def __init__(\n        self,\n        text: TextType = \"\",\n        colors: Optional[Sequence[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n        style: StyleType = \"\",\n        justify: JustifyMethod = \"default\",\n        overflow: OverflowMethod = \"fold\",\n        no_wrap: bool = False,\n        end: str = \"\\n\",\n        tab_size: int = 4,\n        bg_colors: Optional[Sequence[ColorType]] = None,\n        markup: bool = True,\n        spans: Optional[Sequence[Span]] = None,\n    ):\n        \"\"\"Initialize the Text with gradient colors and styles.\n        Args:\n            text (TextType): The text content.\n            colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n            rainbow (bool): If True, generate a rainbow spectrum.\n            hues (int): The number of hues to generate if colors are not provided.\n            style (StyleType): The style of the text.\n            justify (JustifyMethod): Justification method for the text. Defaults to `default`.\n            overflow (OverflowMethod): Overflow method for the text. Defaults to `fold`.\n            no_wrap (bool): If True, disable wrapping of the text. Defaults to False.\n            end (str): The string to append at the end of the text. Default is a newline (`\\\\n`).\n            tab_size (int): The number of spaces for a tab character. Defaults to 4.\n            bg_colors (Optional[List[ColorType]]): A list of background colors as Color \\\ninstances. Defaults to None.\n            markup (bool): If True, parse Rich markup tags in the input text. Defaults to True.\n            spans (Optional[Sequence[Span]]): A list of spans to apply to the text. \\\n            Defaults to None.\n        \"\"\"\n\n        # Parse the input text with or without markup\n        if markup:\n            parsed_text = RichText.from_markup(\n                text=str(text), style=style, justify=justify, overflow=overflow\n            )\n        else:\n            parsed_text = RichText(\n                strip_control_codes(str(text)),\n                style=style,\n                justify=justify,\n                overflow=overflow,\n            )\n\n        # Extract parsed attributes\n        plain = parsed_text.plain\n        parsed_justify = parsed_text.justify\n        parsed_overflow = parsed_text.overflow\n        parsed_spans = parsed_text._spans\n\n        # Initialize the parent class\n        super().__init__(\n            plain,\n            style=style,\n            justify=parsed_justify,\n            overflow=parsed_overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            spans=parsed_spans,\n        )\n        self._interpolate_bg_colors = False  # Ensure flag is always initialized\n        # Normalize color inputs into rich.color.Color instances\n        self.colors = self.parse_colors(colors, hues, rainbow)\n        self.bg_colors = self.parse_bg_colors(bg_colors)\n\n        # Handle the single-color and single-background case: apply style directly and return early\n        if len(self.colors) == 1 and len(self.bg_colors) == 1:\n            # Apply the single color style directly, honoring a missing style definition.\n            if isinstance(style, Style):\n                base_style = style\n            elif isinstance(style, str) and style:\n                base_style = Style.parse(style)\n            else:\n                base_style = Style.null()\n            color_layer = Style(color=self.colors[0], bgcolor=self.bg_colors[0])\n            style_with_color = color_layer + base_style\n            for index in range(len(self.plain)):\n                self.stylize(style_with_color, index, index + 1)\n            return\n\n        # Apply the gradient coloring\n        self.apply_gradient()\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render Text while suppressing any output for empty content.</p> <p>For empty plain text, yield no segments at all (no stray newlines). Otherwise, delegate to the parent implementation and filter a final trailing <code>end</code> segment as required.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def __rich_console__(self, console: Console, options) -&gt; Iterable[Segment]:\n    \"\"\"Render Text while suppressing any output for empty content.\n\n    For empty plain text, yield no segments at all (no stray newlines).\n    Otherwise, delegate to the parent implementation and filter a final\n    trailing `end` segment as required.\n    \"\"\"\n    if self.plain == \"\":\n        return\n    for render_output in super().__rich_console__(console, options):\n        if isinstance(render_output, Segment):\n            # For empty Text,\n            # filter out both the empty text Segment and the trailing end Segment.\n            if self.plain == \"\" and render_output.text in (\"\", self.end):\n                continue\n            yield render_output\n        else:\n            # Render nested renderable to segments, filter as needed\n            for seg in console.render(render_output, options):\n                if self.plain == \"\" and seg.text in (\"\", self.end):\n                    continue\n                yield seg\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.apply_gradient","title":"<code>apply_gradient()</code>","text":"<p>Apply interpolated colors as spans to each character in the text.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def apply_gradient(self) -&gt; None:\n    \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n    # Generate a color for each character\n    colors = self.interpolate_colors(self.colors)\n    if self._interpolate_bg_colors:\n        # Generate a background color for each character if bg_colors are interpolated\n        bg_colors = self.interpolate_colors(self.bg_colors)\n    else:\n        # If not interpolating background colors, use the first bg_color for all characters\n        bg_colors = [self.bg_colors[0]] * len(colors)\n    # Apply a style span for each character with its corresponding color\n    for index, (color, bg_color) in enumerate(zip(colors, bg_colors)):\n        # Build a style with the interpolated color\n        span_style = Style(color=color, bgcolor=bg_color)\n        # Stylize the single character range\n        self.stylize(span_style, index, index + 1)\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.as_rich","title":"<code>as_rich()</code>","text":"<p>Return a plain <code>rich.text.Text</code> with styles and spans applied.</p> <p>This converts the current gradient-aware <code>Text</code> into a base <code>rich.text.Text</code> carrying the same plain content and span/style information. Useful when a consumer specifically needs the base type.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def as_rich(self) -&gt; RichText:\n    \"\"\"Return a plain ``rich.text.Text`` with styles and spans applied.\n\n    This converts the current gradient-aware ``Text`` into a base\n    ``rich.text.Text`` carrying the same plain content and span/style\n    information. Useful when a consumer specifically needs the base type.\n    \"\"\"\n    # Create a plain RichText that mirrors the source content and layout\n    rich_text = RichText(\n        self.plain,\n        style=self.style,\n        justify=self.justify,\n        overflow=self.overflow,\n        no_wrap=self.no_wrap,\n        end=self.end,\n        tab_size=self.tab_size,\n    )\n\n    # Copy internal spans from the source into the returned RichText.\n    # Using the internal _spans attribute is acceptable here since both\n    # classes share the same underlying implementation in rich.\n    for span in getattr(self, \"_spans\", []):\n        rich_text._spans.append(span)\n\n    return rich_text\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.interpolate_colors","title":"<code>interpolate_colors(colors=None)</code>","text":"<p>Interpolate colors across the text using gamma-correct blending.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def interpolate_colors(\n    self, colors: Optional[Sequence[Color]] = None\n) -&gt; list[Color]:\n    \"\"\"Interpolate colors across the text using gamma-correct blending.\"\"\"\n    colors = list(colors) if colors is not None else self.colors\n    if not colors:\n        raise ValueError(\"No colors to interpolate\")\n\n    text = self.plain\n    length = len(text)\n    if length == 0:\n        return []\n    num_colors = len(colors)\n    if num_colors == 1:\n        return [colors[0]] * length\n\n    segments = num_colors - 1\n    result: List[Color] = []\n\n    GAMMA = 2.2\n\n    def to_linear(v: int) -&gt; float:\n        return (v / 255.0) ** GAMMA\n\n    def to_srgb(x: float) -&gt; int:\n        return int(((x ** (1.0 / GAMMA)) * 255.0))\n\n    for i in range(length):\n        pos = i / (length - 1) if length &gt; 1 else 0.0\n        fidx = pos * segments\n        idx = int(fidx)\n        if idx &gt;= segments:\n            idx = segments - 1\n            t = 1.0\n        else:\n            t = fidx - idx\n\n        c0 = colors[idx].get_truecolor()\n        c1 = colors[idx + 1].get_truecolor()\n\n        lr = to_linear(c0.red) + (to_linear(c1.red) - to_linear(c0.red)) * t\n        lg = to_linear(c0.green) + (to_linear(c1.green) - to_linear(c0.green)) * t\n        lb = to_linear(c0.blue) + (to_linear(c1.blue) - to_linear(c0.blue)) * t\n\n        r, g, b = to_srgb(lr), to_srgb(lg), to_srgb(lb)\n        result.append(Color.from_rgb(r, g, b))\n\n    return result\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.parse_bg_colors","title":"<code>parse_bg_colors(bg_colors=None)</code>","text":"<p>Parse and return a list of background colors for the gradient. Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names,         and Color objects. Args:     bg_colors (Optional[Sequence[ColorType | Color]]): A list of background colors as             Color instances or strings.     hues (int): The number of hues to generate if bgcolors are not provided. Returns:     List[Color]: A list of Color objects for background colors.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def parse_bg_colors(\n    self, bg_colors: Optional[Sequence[ColorType]] = None\n) -&gt; List[Color]:\n    \"\"\"Parse and return a list of background colors for the gradient.\n    Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, \\\n    and Color objects.\n    Args:\n        bg_colors (Optional[Sequence[ColorType | Color]]): A list of background colors as \\\n        Color instances or strings.\n        hues (int): The number of hues to generate if bgcolors are not provided.\n    Returns:\n        List[Color]: A list of Color objects for background colors.\n    \"\"\"\n    if not bg_colors:\n        self._interpolate_bg_colors = False\n        # Default to transparent/default background per character count\n        fallback = Color.parse(\"default\")\n        color_count = max(1, len(self.colors))\n        return [fallback] * color_count\n\n    if len(bg_colors) == 1:\n        # If only one background color is provided, do not interpolate\n        self._interpolate_bg_colors = False\n        c = bg_colors[0]\n        try:\n            normalized = Text._normalize_color(c)\n        except Exception as exc:  # pragma: no cover - defensive\n            raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n        return [normalized] * max(1, len(self.colors))\n\n    # Multiple bg_colors: interpolate across provided stops\n    self._interpolate_bg_colors = True\n    parsed_bg: List[Color] = []\n    for c in bg_colors:\n        try:\n            parsed_bg.append(Text._normalize_color(c))\n        except Exception as exc:  # pragma: no cover - defensive\n            raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n    return parsed_bg\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.parse_colors","title":"<code>parse_colors(colors=None, hues=5, rainbow=False)</code>  <code>staticmethod</code>","text":"<p>Parse and return a list of colors for the gradient. Supports: - rgb colors (e.g. <code>'rgb(255, 0, 0)'</code>) - rgb tuples (e.g., <code>(255, 0, 0)</code>) - 3-digit hex colors (e.g., <code>'#f00'</code>, <code>'#F90'</code>) - 6-digit hex colors (e.g., <code>'#ff0000'</code>, <code>'#00FF00'</code>) - CSS names (e.g., <code>'red'</code>, <code>'aliceblue'</code>) - rich.color.Color objects (e.g., <code>Color.parse('#FF0000')</code>) Args:     colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color         instances, tuples of integers, or strings.     hues (int): The number of hues to generate if colors are not provided. Defaults to 5.     rainbow (bool): Whether to generate a rainbow spectrum. Note that rainbow overrides         any colors or hues provided. Defaults to False Raises:     ColorParseError: If any color value cannot be parsed.     ValueError: If no colors are provided, rainbow is False, and hues &lt; 2. Returns:     List[rich.color.Color]: A list of Color objects.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>    @staticmethod\n    def parse_colors(\n        colors: Optional[Sequence[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of colors for the gradient.\n        Supports:\n        - rgb colors (e.g. `'rgb(255, 0, 0)'`)\n        - rgb tuples (e.g., `(255, 0, 0)`)\n        - 3-digit hex colors (e.g., `'#f00'`, `'#F90'`)\n        - 6-digit hex colors (e.g., `'#ff0000'`, `'#00FF00'`)\n        - CSS names (e.g., `'red'`, `'aliceblue'`)\n        - rich.color.Color objects (e.g., `Color.parse('#FF0000')`)\n        Args:\n            colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color\n                instances, tuples of integers, or strings.\n            hues (int): The number of hues to generate if colors are not provided. Defaults to 5.\n            rainbow (bool): Whether to generate a rainbow spectrum. Note that rainbow overrides\n                any colors or hues provided. Defaults to False\n        Raises:\n            ColorParseError: If any color value cannot be parsed.\n            ValueError: If no colors are provided, rainbow is False, and hues &lt; 2.\n        Returns:\n            List[rich.color.Color]: A list of Color objects.\n        \"\"\"\n        # When rainbow is True, we use a full 17-color spectrum\n        if rainbow:\n            return Spectrum(hues=17).colors\n\n        # If no colors are provided, fall back to Spectrum with the specified hues\n        if colors is None or len(colors) == 0:\n            if hues &lt; 2:\n                raise ValueError(\n                    f\"If `rainbow=False` and no colors are provided, hues must be \\\nat least 2. Invalid hues value: {hues}\"\n                )\n            return Spectrum(hues).colors\n\n        # If we have colors, parse and normalize them\n        parsed: List[Color] = []\n        for c in colors:\n            try:\n                parsed.append(Text._normalize_color(c))\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported color value: {c}\") from exc\n        return parsed\n</code></pre>"},{"location":"theme_ref/","title":"Theme Reference","text":"<p>               Bases: <code>Theme</code></p> <p>A container for style information used by <code>rich.console.Console</code>.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>Dict[str, StyleType]</code> <p>Mapping of style names to style definitions. Defaults to <code>DEFAULT_STYLES</code>.</p> <code>None</code> Notes <p>The theme always inherits Rich's default styles (<code>inherit=True</code>).</p> Source code in <code>src/rich_gradient/theme.py</code> <pre><code>class GradientTheme(Theme):\n    \"\"\"A container for style information used by ``rich.console.Console``.\n\n    Args:\n        styles (Dict[str, StyleType], optional): Mapping of style names to\n            style definitions. Defaults to ``DEFAULT_STYLES``.\n\n    Notes:\n        The theme always inherits Rich's default styles (``inherit=True``).\n    \"\"\"\n\n    # styles: Dict[str, Style] = {}\n\n    def __init__(self, styles: Optional[Dict[str, StyleType]] = None) -&gt; None:\n        \"\"\"Initialize the theme with the given styles.\"\"\"\n        if styles is None:\n            styles = dict(DEFAULT_STYLES)\n        super().__init__(styles=styles, inherit=True)\n        self._theme: Theme = Theme(styles, inherit=True)\n        self._styles: Dict[str, StyleType] = styles\n\n    @property\n    def theme(self) -&gt; Theme:\n        \"\"\"Return the current theme instance used for styling.\"\"\"\n        return self._theme\n\n    @theme.setter\n    def theme(self, theme: Theme = Theme(DEFAULT_STYLES)) -&gt; None:\n        self._theme = theme\n\n    def __call__(self) -&gt; Theme:\n        return self.theme\n\n    def __repr__(self) -&gt; str:\n        return f\"GradientTheme({self._styles!r})\"\n\n    def __rich__(self) -&gt; Table:\n        return styles_table()\n\n    def __getitem__(self, name: str) -&gt; Style:\n        return Style.parse(str(self._styles[name]))\n\n    @classmethod\n    def get_theme_table(cls) -&gt; Table:\n        \"\"\"Get a table of all styles in the theme.\"\"\"\n        return styles_table()\n</code></pre> <p>Note: <code>GRADIENT_TERMINAL_THEME</code> is a terminal theme constant exported from</p> <p><code>rich_gradient.theme</code> for use with <code>Console.save_svg</code>. It is not included in</p> <p>the auto-generated API table above but is part of the public API.</p>"},{"location":"theme_ref/#rich_gradient.theme.GradientTheme.theme","title":"<code>theme</code>  <code>property</code> <code>writable</code>","text":"<p>Return the current theme instance used for styling.</p>"},{"location":"theme_ref/#rich_gradient.theme.GradientTheme.__init__","title":"<code>__init__(styles=None)</code>","text":"<p>Initialize the theme with the given styles.</p> Source code in <code>src/rich_gradient/theme.py</code> <pre><code>def __init__(self, styles: Optional[Dict[str, StyleType]] = None) -&gt; None:\n    \"\"\"Initialize the theme with the given styles.\"\"\"\n    if styles is None:\n        styles = dict(DEFAULT_STYLES)\n    super().__init__(styles=styles, inherit=True)\n    self._theme: Theme = Theme(styles, inherit=True)\n    self._styles: Dict[str, StyleType] = styles\n</code></pre>"},{"location":"theme_ref/#rich_gradient.theme.GradientTheme.get_theme_table","title":"<code>get_theme_table()</code>  <code>classmethod</code>","text":"<p>Get a table of all styles in the theme.</p> Source code in <code>src/rich_gradient/theme.py</code> <pre><code>@classmethod\ndef get_theme_table(cls) -&gt; Table:\n    \"\"\"Get a table of all styles in the theme.\"\"\"\n    return styles_table()\n</code></pre>"}]}