{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>This library is a wrapper of the great rich library that extends rich.text.Text to allow for the easy generation gradient text from either user entered colors or randomly if no colors are entered.</p> <p>Borrowing from rich-color-ext rich_gradient extends the rich standard colors to include:</p> <ul> <li>3 or 6 digit hex code (e.g. <code>#f00</code> or <code>#FF0000</code>)</li> <li>RGB color codes (e.g. <code>rgb(255, 0, 0)</code>)</li> <li>RGB tuples   (e.g. <code>(255, 0, 0)</code>)</li> <li>CSS3 Color Names (e.g. <code>rebeccapurple</code>)</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#uv-recommended","title":"uv (Recommended)","text":"<pre><code>uv add rich-gradient\n</code></pre>"},{"location":"#pip","title":"Pip","text":"<pre><code>pip install rich-gradient\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#text-example","title":"Text Example","text":"<p>To print a simple gradient import the <code>Text</code> class from in the <code>rich_gradient</code> library:</p> <p></p>"},{"location":"#gradient","title":"Gradient","text":"<p>If just text is boring, <code>rich_gradient.gradient.Gradient</code> allows you to apply a gradient to any <code>rich.console.ConsoleRenderable</code>. Such as a <code>rich.panel.Panel</code> or <code>rich.table.Table</code>;</p> <pre><code>table = Table(\n    title=\"Gradient Table Example\",\n    border_style=\"bold\",\n)\ntable.add_column(\n    \"Renderable\",\n    style=\"bold\",\n    vertical=\"middle\",\n    justify=\"right\"\n)\ntable.add_column(\"Works w/Gradient\", justify=\"left\", style=\"bold\")\nrenderables = [\n    \"Text\",\n    \"Panel\",\n    \"Syntax\",\n    \"Table\",\n    \"Live\",\n    \"Group\",\n    \"Markdown\"\n]\nfor renderable in renderables:\n    table.add_row(\n        renderable,\n        \"[b]:heavy_check_mark:[/b]\"\n    )\n\nconsole.print(Gradient(table, rainbow=True), justify=\"center\")\n</code></pre> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#v036-2025-09-10-consolidated-gradient-rng-fix-gamma-correct-text-docstests","title":"v0.3.6 - 2025-09-10 | Consolidated Gradient, RNG fix, gamma-correct Text, docs/tests","text":""},{"location":"CHANGELOG/#added-changed","title":"Added / Changed","text":"<ul> <li>Gradient</li> <li>Consolidated to a single public factory (<code>rich_gradient.gradient.Gradient</code>) that returns <code>BaseGradient</code> or <code>AnimatedGradient</code> internally.</li> <li>Kept test helper methods by adding equivalents to <code>BaseGradient</code> (<code>_color_at</code>, <code>_styled</code>, <code>_interpolated_color</code>) and <code>_active_stops</code> initialization.</li> <li>Added <code>background=</code> support to <code>BaseGradient</code>/<code>AnimatedGradient</code> for parity with previous API.</li> <li>Text</li> <li>Interpolates colors with gamma-correct blending for visual consistency with <code>Gradient</code>.</li> <li>Spectrum</li> <li>Uses a dedicated <code>random.Random(seed)</code> instance to avoid mutating global RNG state; behavior is deterministic per seed without side effects.</li> <li>Rule</li> <li>Normalized invalid color errors to <code>ValueError</code> for consistency.</li> <li>Package Init</li> <li>Centralized <code>rich-color-ext</code> install to package init; removed duplicate installs from other modules.</li> <li>Repo Hygiene</li> <li>Removed committed build artifacts (<code>dist/</code>) and static site (<code>site/</code>) from source; they remain in <code>.gitignore</code>.</li> <li>Docs / Examples / Tests</li> <li>README basic example fixed (missing parenthesis).</li> <li>Benchmark test now measures actual console printing safely.</li> <li>CLI</li> <li>Relaxed <code>--justify</code> and <code>--overflow</code> option annotations from <code>Literal[...]</code> to <code>str</code> with explicit validation for broader Typer/Click compatibility.</li> <li>Pinned dependencies to stabilize CLI behavior: <code>typer&gt;=0.12.5,&lt;0.13</code> and <code>click&gt;=8.1.7,&lt;9.0.0</code>.</li> <li>Tests</li> <li>Made CLI tests portable across Click/Typer versions by removing <code>mix_stderr</code> usage and accepting warnings from stdout or stderr.</li> <li>Cleanup</li> <li>Removed duplicate internal <code>Gradient</code> factory leftover in <code>_animated_gradient.py</code>; the public factory now lives in <code>rich_gradient/gradient.py</code>.</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Eliminated duplicate Gradient implementations that could drift out of sync.</li> <li>Avoided global RNG seeding in <code>Spectrum</code> that could affect host applications.</li> </ul>"},{"location":"CHANGELOG/#v034-2025-09-03-textas_rich-background-gradients-spectrum-docs","title":"v0.3.4 - 2025-09-03 | Text.as_rich(), background gradients, spectrum + docs","text":""},{"location":"CHANGELOG/#v034-added","title":"v0.3.4 Added","text":"<ul> <li>Text</li> <li><code>.as_rich()</code> method to return a plain <code>rich.text.Text</code> with all spans/styles preserved.</li> <li><code>.rich</code> convenience property wrapping <code>as_rich()</code>.</li> <li>Background gradients via <code>bgcolors=</code>; multiple bg stops interpolate alongside foreground.</li> <li>Robust color normalization supporting <code>Color</code>, <code>ColorTriplet</code>, <code>(r,g,b)</code> tuples, CSS names, 3/6\u2011digit hex, and <code>rgb()</code> strings.</li> <li>Spectrum</li> <li>Deterministic <code>seed</code>, color names, styles, hex accessors, and a rich preview table renderable.</li> <li>Docs/Examples</li> <li>New SVG/PNG assets for gradient text examples under <code>docs/img/v0.3.4/</code> and updated spectrum preview.</li> </ul>"},{"location":"CHANGELOG/#v034-updated","title":"v0.3.4 Updated","text":"<ul> <li>Text</li> <li>Improved error types/messages and comprehensive module documentation.</li> <li>Single\u2011color fast\u2011path applies one composed <code>Style</code> across content for performance.</li> <li>Empty text rendering no longer emits a trailing newline/segment; nested renderables filtered accordingly.</li> <li>Gradient and BaseGradient</li> <li>Gamma\u2011corrected color interpolation, smoother stop wrapping, explicit alignment validation, and safer measurement when no renderables.</li> <li>Support for <code>repeat_scale</code>/<code>phase</code> used by animated variants.</li> <li>Rule</li> <li>Accepts colors as strings, <code>Color</code>, <code>ColorTriplet</code>, or RGB tuples with clearer validation and messages.</li> <li>Title style applied after gradient generation for accurate highlighting.</li> <li>Package Init / Theme</li> <li>Install <code>rich-color-ext</code> on import and monkey\u2011patch <code>Console._collect_renderables</code> to suppress empty <code>Text</code> trailing newline.</li> <li>Theme helpers for consistent docs SVG generation (<code>GRADIENT_TERMINAL_THEME</code>).</li> <li>README/Docs</li> <li>Expanded examples and color\u2011format visuals; refreshed links and images.</li> </ul>"},{"location":"CHANGELOG/#v034-fixed","title":"v0.3.4 Fixed","text":"<ul> <li>Suppressed stray newline output when rendering empty gradient <code>Text</code> (affects console capture/recorded SVGs).</li> </ul>"},{"location":"CHANGELOG/#v033-2025-08-27-added-tests-and-fixed-bugs","title":"v0.3.3 - 2025-08-27 |  Added tests and Fixed Bugs","text":""},{"location":"CHANGELOG/#v033-updated","title":"v0.3.3 Updated","text":"<ul> <li>Enhanced rendering and color handling in gradient components</li> <li>Refactored rich-gradient for improved structure and functionality</li> <li>Reorganized imports in <code>__init__.py</code> for clarity.</li> <li>Updated AnimatedGradient to ensure color extension is installed at package import time.</li> <li>Enhanced BaseGradient to improve gradient wrapping logic and error handling.</li> <li>Improved logger utility with better error handling and configuration options.</li> <li>Adjusted Gradient class to ensure quit panel behavior is consistent and intuitive.</li> <li>Added comprehensive tests for edge cases in Gradient and Text classes, including long text, unicode handling, and color validation.</li> <li>Enhanced Spectrum class to support color generation with optional seed for reproducibility.</li> <li>Improved Text class to ensure proper initialization and color parsing.</li> <li>Updated test suites for Gradient and Spectrum to cover additional scenarios and edge cases.</li> </ul>"},{"location":"CHANGELOG/#v032-added-tests-and-fixed-bugs","title":"v0.3.2  Added tests and Fixed Bugs","text":""},{"location":"CHANGELOG/#v032-removed","title":"v0.3.2 Removed","text":"<ul> <li>Dev Dependencies</li> <li><code>snoop</code></li> <li><code>cheap-repr</code></li> </ul>"},{"location":"CHANGELOG/#v032-updated","title":"v0.3.2 Updated","text":"<ul> <li>Removed instances that were imported from:</li> <li><code>snoop</code><ul> <li><code>@snoop()</code></li> </ul> </li> <li><code>cheap-repr</code><ul> <li><code>register_repr(f\"{class})(normal_repr)</code></li> </ul> </li> <li>Renamed GradientRule -&gt; Rule</li> <li>to match the naming of the other modules in <code>rich-gradient</code></li> </ul>"},{"location":"CHANGELOG/#v032-added","title":"v0.3.2 Added","text":"<ul> <li>Tests</li> <li><code>tests/benchmark_perf.py</code>: To benchmark the performance of generating gradients that span large amounts of characters.</li> <li><code>tests/test_edge_cases.py</code>: To cover edge cases that may otherwise break <code>rich-gradient</code>.</li> </ul>"},{"location":"CHANGELOG/#v030-2025-06-20-working-rewrite","title":"v0.3.0 - 2025-06-20 |  Working Rewrite","text":""},{"location":"CHANGELOG/#v030-added","title":"v0.3.0 Added","text":"<ul> <li>Validated working and added tests for:</li> <li><code>rich_gradient.text.Text</code></li> <li><code>rich_gradient.gradient.Gradient</code></li> <li><code>rich_gradient.rule.GradientRule</code></li> <li><code>rich_gradient.spectrum.Spectrum</code></li> <li><code>rich-color-ext</code> acting as adequate replacement for previous color logic</li> <li>Added examples directory containing:</li> <li><code>animated_gradient_example.py</code></li> <li><code>gradient_example.py</code></li> <li><code>hello_world.py</code></li> <li><code>rainbow_gradient.py</code></li> <li><code>specific_color_gradient.py</code></li> <li><code>text_markup.py</code></li> <li><code>two_color_gradients.py</code></li> <li>Generated updated exports for examples for documentation (still in the works)</li> </ul>"},{"location":"CHANGELOG/#v030-updated","title":"v0.3.0 Updated","text":"<ul> <li><code>docs/index.md</code></li> </ul>"},{"location":"CHANGELOG/#v030-todo","title":"v0.3.0 TODO","text":"<ul> <li>Update Documentation</li> <li>Expand Tests</li> <li>Work on Gradient Panel and Table Renderables</li> </ul>"},{"location":"CHANGELOG/#v030-removed","title":"v0.3.0 Removed","text":"<p>Removed all of the the archived modules from rich_gradient/archive/*</p>"},{"location":"CHANGELOG/#v021-rewrite","title":"v0.2.1 Rewrite","text":"<p>There was a lot of overhead in rich-gradient so I rewrote it from the ground up with an actual goal. I created rich-color-ext to wrap around rich's color parsing removing the need for the<code>_rgb.py</code>, <code>color.py</code>, <code>color_data.py</code>, <code>_colors.py</code>, and all of their tests.</p>"},{"location":"CHANGELOG/#v020-2025-3-13-uv-pure-python-and-3132","title":"v0.2.0 - 2025-3-13 | uv, pure python, and 3.13.2","text":"<p>There are a number of significant changes in v0.2.0:</p>"},{"location":"CHANGELOG/#rye-uv","title":"<code>rye</code> \u2192 <code>uv</code>","text":"<p>Astral has done a hell of a job making python dev tools. ruff blew the existing python linters out of the water and uv pretty much did the same thing to package managers. Rich-gradient was started on rye but as Astral has since depreciated it, it's moved to their current rust powered python package manager, uv.</p>"},{"location":"CHANGELOG/#pure-python","title":"Pure Python","text":"<p>Rich-gradient is now a pure-python package. This allows it to be more easily used regardless of platform. As rich-gradient previously had pydantic as a dependency, it now just borrows the logic from <code>pydantic-extra-types.color</code>.</p>"},{"location":"CHANGELOG/#3132","title":"3.13.2","text":"<p>After switching to uv, the package has been updated to python 3.13.2.</p>"},{"location":"CHANGELOG/#v020-updated","title":"v0.2.0 Updated","text":"<ul> <li>Switched rich-gradient package manager from astral/rye to astral/uv</li> <li>Updated python to <code>3.13.2</code></li> </ul>"},{"location":"CHANGELOG/#v020-changed","title":"v0.2.0 Changed","text":"<ul> <li>Removed <code>pydantic</code> and <code>pydantic-extra-types</code> dependencies.</li> <li>Updated the names of some of the colors. For example greenyellow became lawngreen.</li> <li>Updated <code>README.md</code>, <code>CHANGELOG</code>, and documentation.</li> </ul>"},{"location":"CHANGELOG/#v020-added","title":"v0.2.0 Added","text":"<ul> <li><code>src/rich_gradient/_base_color.py</code>: stores the color logic from pydantic-extra-types.color modules stripped of the pydantic framwork.</li> </ul>"},{"location":"CHANGELOG/#v017-2024-7-16-added-support-for-two-color-gradients","title":"v0.1.7 - 2024-7-16 | Added support for Two-Color Gradients","text":""},{"location":"CHANGELOG/#v017-updated","title":"v0.1.7 Updated","text":"<ul> <li>Updated Gradient.generate_subgradients() to default to returning a list containing a single simple gradient to allow Gradients to work when only supplied with two colors.</li> </ul>"},{"location":"CHANGELOG/#v017-added","title":"v0.1.7 Added","text":"<ul> <li>Added len, int, str, and repr dunder methods to <code>rich-gradient.gradient.Gradient</code> (will simply refer to as <code>Gradient</code> from here on out).</li> <li>Added a tests/test_gradient.py for Gradient to test two color gradiets</li> </ul>"},{"location":"CHANGELOG/#v016-2024-6-28-updated-rev","title":"v0.1.6 - 2024-6-28 | Updated Rev","text":"<ul> <li>Updated rev to 0.1.6.</li> </ul>"},{"location":"CHANGELOG/#v015-2024-6-28-added-tests","title":"v0.1.5 - 2024-6-28 | Added Tests","text":""},{"location":"CHANGELOG/#v015-updated","title":"v0.1.5 Updated","text":"<ul> <li>Updated requirements for minimum versions of python from 3.8 -&gt; 3.10.</li> <li>Added <code>pytest</code> to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v015-added","title":"v0.1.5 Added","text":"<ul> <li>Tests for:</li> <li>Color</li> <li>Specturm</li> <li>SimpleGradient</li> </ul>"},{"location":"CHANGELOG/#v014-2024-6-28-resolved-dependancies","title":"v0.1.4 | 2024-6-28 | Resolved Dependancies","text":""},{"location":"CHANGELOG/#v014-updated","title":"v0.1.4 Updated","text":"<ul> <li>This release is primarily to prune unnecessary dependancies.</li> <li>Removed <code>numpy</code> to avoid issues of <code>numpy</code> version 2.0.0 conflicting with <code>torch</code>.</li> </ul>"},{"location":"CHANGELOG/#v013-2021-10-10","title":"v0.1.3 - 2021-10-10","text":""},{"location":"CHANGELOG/#v013-fixed","title":"v0.1.3 Fixed","text":"<ul> <li>Updated README to use GitHub pages for example gradient image.</li> </ul>"},{"location":"CHANGELOG/#v012-2021-10-10","title":"v0.1.2 - 2021-10-10","text":""},{"location":"CHANGELOG/#v012-updated","title":"v0.1.2 Updated","text":"<ul> <li>Updated PyProject.toml description.</li> <li>Moved MKDocs and related dependancies to dev-dependancies.</li> </ul>"},{"location":"CHANGELOG/#v012-fixed","title":"v0.1.2 Fixed","text":"<ul> <li>Updated README to use GitHub pages for banner image.</li> <li>Updated README to use GitHub pages for docs url.</li> </ul>"},{"location":"CHANGELOG/#v011-2021-10-10","title":"v0.1.1 - 2021-10-10","text":""},{"location":"CHANGELOG/#v011-fixed","title":"v0.1.1 Fixed","text":"<ul> <li>Updated README to use GitHub pages for images.</li> </ul>"},{"location":"CHANGELOG/#v010-2021-10-10","title":"v0.1.0 - 2021-10-10","text":"<p>Initial release. Based off of MaxGradient with a simplified color model based on pydantic-extra-types.color.Color. Re-released as rich-gradient to avoid confusion with MaxGradient.</p>"},{"location":"gradient/","title":"Gradient","text":"<p>The <code>Gradient</code> class accepts any rich.console.ConsoleRenderable and prints it to a rich.console.Console instance in gradient color.</p> <pre><code>panel = Panel(\n    \"If you are looking for a way to display more than \\\na single line of text with a gradient, \\\nyou can use the `Gradient` class to \\\ncreate a gradient that can be applied to \\\nmultiple lines of text or any rich renderable object.\",\n    title=\"Gradient Example\",\n    title_align=\"left\",\n    padding=(1, 2),\n    border_style=\"bold\",\n    width=60,\n)\nconsole.print(Gradient(panel, rainbow=True), justify=\"center\")\n</code></pre> <p></p> <p>Or if you would like an animated gradient:</p> <pre><code>console = Console(width=64, record=True)\nconsole.line(2)\npanel = Panel(\n    \"This example demonstrates an animated gradient that shifts colors over time. \\\nYou can use the `Gradient` class to create a gradient that can be applied to any \\\nrich renderable object, such as text or panels. The animation is achieved by \\\nincrementing the phase of the gradient.\",\n    title=\"Animated Gradient\",\n    padding=(1, 2),\n)\ngradient = Gradient(panel, rainbow=True, animated=True)\nlive_renderable = gradient\n# Setup Live to refresh at ~30 FPS\nwith Live(live_renderable, console=console, refresh_per_second=30):\n    with suppress(KeyboardInterrupt):\n        while True:\n            time.sleep(0.03)\n            # Increment phase to animate gradient shift\n            gradient.phase += 0.2\n</code></pre> <p></p>"},{"location":"gradient_ref/","title":"Gradient","text":"<p>Factory that returns <code>BaseGradient</code> or <code>AnimatedGradient</code>.</p> <p>If <code>animated=True</code> (or <code>animate=True</code>) is passed, an <code>AnimatedGradient</code> instance is constructed; otherwise a <code>BaseGradient</code> is returned. All other positional and keyword arguments are forwarded to the chosen implementation.</p> Source code in <code>src/rich_gradient/gradient.py</code> <pre><code>class Gradient:\n    \"\"\"Factory that returns `BaseGradient` or `AnimatedGradient`.\n\n    If `animated=True` (or `animate=True`) is passed, an `AnimatedGradient`\n    instance is constructed; otherwise a `BaseGradient` is returned. All other\n    positional and keyword arguments are forwarded to the chosen implementation.\n    \"\"\"\n\n    def __new__(cls, *args: Any, **kwargs: Any):  # type: ignore[override]\n        # Support both `animated` (preferred) and `animate` (compat) flags\n        animated = bool(kwargs.pop(\"animated\", False) or kwargs.pop(\"animate\", False))\n        if animated:\n            return AnimatedGradient(*args, **kwargs)\n        return BaseGradient(*args, **kwargs)\n</code></pre>"},{"location":"rule/","title":"Rule","text":""},{"location":"rule/#rule","title":"Rule","text":"<p>The 'Rule` class is based off of the rich.rule.Rule class and is used to define a rule in gradient color and variable thickness.</p>"},{"location":"rule/#usage","title":"Usage","text":"<pre><code>from rich.console import Console\nfrom rich_gradient.rule import Rule\n\nconsole = Console()\nconsole.print(\n    Rule(\n        \"Hello, world!\",\n    )\n)\n</code></pre>"},{"location":"rule/#alignment","title":"Alignment","text":"<p>The <code>Rule</code> class supports the same alignment options as the <code>Rule</code> class.</p>"},{"location":"rule/#left-aligned-rule","title":"Left Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"\u2190 This is a left aligned rule.\",\n        align=\"left\",\n    )\n)\n</code></pre>"},{"location":"rule/#right-aligned-rule","title":"Right Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a right aligned rule. \u2192,\n        align=\"right\"\n    )\n)\n</code></pre>"},{"location":"rule/#center-aligned-rule","title":"Center Aligned Rule","text":"<pre><code>console.print(\n    Rule(\n        \"\u2192 This is a center aligned rule. \u2190\",\n        align=\"center\"\n    )\n)\n</code></pre> <p>Note</p> <p>The default behavior of rich_gradient.rule.Rule is center aligned.</p>"},{"location":"rule/#thickness","title":"Thickness","text":"<p>The <code>Rule</code> class supports configurable thickness. Valid integer values are:</p> <ol> <li><code>thin</code> (<code>\u2500</code>)</li> <li><code>double</code> (<code>\u2550</code>)</li> <li><code>medium</code> (<code>\u2501</code>) (default)</li> <li><code>thick</code> (<code>\u2588</code>)</li> </ol>"},{"location":"rule/#thin-rule","title":"Thin Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a thin rule\",\n        thickness=0\n    )\n)\n</code></pre>"},{"location":"rule/#double-line-rule","title":"Double-line Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a double-line rule\",\n        thickness=1\n    )\n)\n</code></pre>"},{"location":"rule/#medium-rule","title":"Medium Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a medium rule\",\n        thickness=2\n    )\n)\n</code></pre>"},{"location":"rule/#thick-rule","title":"Thick Rule","text":"<pre><code>console.print(\n    Rule(\n        \"This is a thick rule\",\n        thickness=3\n    )\n)\n</code></pre>"},{"location":"rule/#custom-colored-rule","title":"Custom Colored Rule","text":"<p>To create a rule with custom colors, simply supply the <code>colors</code> parameter with a list of colors (as CSS color names, 3 or 6 digit hex codes, rich color names, or rgb color codes).</p> console.print( Rule( \"This rule has custom colors!\", colors=[ \"#f00\", # red \"#f90\", # orange \"#ff0\", # yellow \"#9f0\", # yellow-green ]    \u00a0\u00a0) )  <p></p> <p></p>"},{"location":"rule/#custom-title-style","title":"Custom Title Style","text":"<p>If you would like some distinction between the rule and it's title, simply pass a rich style to the <code>title_style</code> parameter:</p> <pre><code>console.print(\n     Rule(\n         \"Custom Styled Rule Title\",\n         title_style=\"bold white\",\n         align=\"center\"\n     )\n)\n</code></pre> <p></p>"},{"location":"rule_ref/","title":"Rule Reference","text":"<p>               Bases: <code>Rule</code></p> <p>A Rule with a gradient background.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Optional[str]</code> <p>The text to display as the title.</p> required <code>title_style</code> <code>StyleType</code> <p>The style to apply to the title text. Defaults to NULL_STYLE.</p> <code>parse('bold')</code> <code>colors</code> <code>Sequence[ColorType]</code> <p>A sequence of colors for the gradient. Each color may be a string understood by <code>rich.color.Color.parse</code> (e.g., \"red\", \"#ff0000\"), a <code>Color</code> instance, or an RGB tuple. Defaults to empty list.</p> <code>None</code> <code>thickness</code> <code>int</code> <p>Thickness level of the rule (0 to 3). Defaults to 2.</p> <code>2</code> <code>style</code> <code>StyleType</code> <p>The style of the rule line. Defaults to NULL_STYLE.</p> <code>NULL_STYLE</code> <code>rainbow</code> <code>bool</code> <p>If True, use a rainbow gradient regardless of colors. Defaults to False.</p> <code>False</code> <code>hues</code> <code>int</code> <p>Number of hues in the gradient if colors are not provided. Defaults to 10.</p> <code>10</code> <code>end</code> <code>str</code> <p>End character after the rule. Defaults to newline.</p> <code>'\\n'</code> <code>align</code> <code>AlignMethod</code> <p>Alignment of the rule. Defaults to \"center\".</p> <code>'center'</code> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>class Rule(RichRule):\n    \"\"\"A Rule with a gradient background.\n\n    Args:\n        title (Optional[str]): The text to display as the title.\n        title_style (StyleType, optional): The style to apply to the title text. Defaults to NULL_STYLE.\n        colors (Sequence[ColorType], optional): A sequence of colors for the gradient. Each color may be a\n            string understood by ``rich.color.Color.parse`` (e.g., \"red\", \"#ff0000\"), a ``Color`` instance,\n            or an RGB tuple. Defaults to empty list.\n        thickness (int, optional): Thickness level of the rule (0 to 3). Defaults to 2.\n        style (StyleType, optional): The style of the rule line. Defaults to NULL_STYLE.\n        rainbow (bool, optional): If True, use a rainbow gradient regardless of colors. Defaults to False.\n        hues (int, optional): Number of hues in the gradient if colors are not provided. Defaults to 10.\n        end (str, optional): End character after the rule. Defaults to newline.\n        align (AlignMethod, optional): Alignment of the rule. Defaults to \"center\".\n    \"\"\"\n\n    def __init__(\n        self,\n        title: Optional[str],\n        title_style: StyleType = Style.parse(\"bold\"),\n        colors: Optional[Sequence[ColorType]] = None,\n        thickness: int = 2,\n        style: StyleType = NULL_STYLE,\n        rainbow: bool = False,\n        hues: int = 10,\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n    ) -&gt; None:\n        # Validate thickness input\n        if thickness &lt; 0 or thickness &gt; 3:\n            raise ValueError(\n                f\"Invalid thickness: {thickness}. Thickness must be between 0 and 3.\"\n            )\n        # Validate type\n        if title is not None and not isinstance(title, str):\n            raise TypeError(f\"title must be str, got {type(title).__name__}\")\n\n        if not isinstance(title_style, (str, Style)):\n            raise TypeError(\n                f\"title_style must be str or Style, got {type(title_style).__name__}\"\n            )\n        if not isinstance(style, (str, Style)):\n            raise TypeError(f\"style must be str or Style, got {type(style).__name__}\")\n        # Determine character based on thickness\n        self.characters = CHARACTER_MAP.get(thickness, \"\u2501\")\n        # Parse and store the title style\n        self.title_style = Style.parse(str(title_style))\n        # Initialize the base Rule with provided parameters\n        super().__init__(\n            title=title or \"\",\n            characters=self.characters,\n            style=Style.parse(str(style)),\n            end=end,\n            align=align,\n        )\n        # Parse and store the gradient colors\n        self.colors = self._parse_colors(\n            colors if colors is not None else [], rainbow, hues\n        )\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n        \"\"\"Render the gradient rule.\n\n        Args:\n            console (Console): The console to render to.\n            options (ConsoleOptions): The console options.\n\n        Yields:\n            RenderResult: The rendered segments of the gradient rule.\n        \"\"\"\n        # Prepare a base rule with no style to extract segments\n        base_rule = RichRule(\n            title=self.title or \"\",\n            characters=self.characters,\n            style=NULL_STYLE,\n            end=self.end,\n            align=cast(AlignMethod, self.align),\n        )\n        # Render the base rule to get segments\n        rule_segments = console.render(base_rule, options=options)\n        # Concatenate segment texts to form the full rule text (filter to Segment-like objects)\n        rule_text_parts: List[str] = []\n        for seg in rule_segments:\n            try:\n                text = seg.text\n            except Exception:\n                continue\n            rule_text_parts.append(text)\n        rule_text = \"\".join(rule_text_parts)\n\n        # If no title style, render the gradient text directly\n        if self.title_style == NULL_STYLE:\n            gradient_rule = Text(rule_text, colors=self.colors)\n            yield from console.render(gradient_rule, options)\n            return\n        # Create gradient text for the rule\n        gradient_rule = Text(rule_text, colors=self.colors)\n\n        # Extract the title string for highlighting\n        title = self.title.plain if isinstance(self.title, Text) else str(self.title)\n\n        # Apply the title style highlight after gradient generation\n        if title and self.title_style != NULL_STYLE:\n            gradient_rule.highlight_words([title], style=self.title_style)\n\n        # Yield the styled gradient text\n        yield from console.render(gradient_rule, options)\n\n    def _parse_colors(\n        self,\n        colors: Sequence[ColorType],\n        rainbow: bool,\n        hues: int,\n    ) -&gt; List[str]:\n        \"\"\"Parse colors for the gradient.\n\n        Args:\n            colors (Sequence[ColorType]): A sequence of colors supplied as strings, ``Color`` objects,\n                ``ColorTriplet`` instances or RGB tuples.\n            rainbow (bool): If True, use a rainbow gradient.\n            hues (int): Number of hues in the gradient.\n\n        Raises:\n            ValueError: If fewer than two colors are provided when colors are specified.\n            ColorParseError: If a provided color value cannot be interpreted.\n\n        Returns:\n            List[str]: A list of hex color strings for the gradient.\n        \"\"\"\n        if rainbow:\n            return Spectrum(hues).hex\n\n        if colors and len(colors) &lt; 2:\n            raise ValueError(\n                f\"At least two colors are required for a gradient. Please provide at least two color values. Received: {colors!r}\"\n            )\n\n        if not colors:\n            return Spectrum(hues).hex\n\n        _colors: List[str] = []\n        for color in colors:\n            try:\n                if isinstance(color, Color):\n                    _colors.append(color.get_truecolor().hex)\n                elif isinstance(color, ColorTriplet):\n                    _colors.append(color.hex)\n                elif isinstance(color, tuple) and len(color) == 3:\n                    _colors.append(ColorTriplet(*color).hex)\n                else:\n                    _colors.append(Color.parse(color).get_truecolor().hex)\n            except (ColorParseError, TypeError, ValueError) as ce:\n                raise ValueError(\n                    f\"Invalid color: {color}. Please provide a valid color value.\"\n                ) from ce\n        return _colors\n</code></pre>"},{"location":"rule_ref/#rich_gradient.rule.Rule.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render the gradient rule.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>The console to render to.</p> required <code>options</code> <code>ConsoleOptions</code> <p>The console options.</p> required <p>Yields:</p> Name Type Description <code>RenderResult</code> <code>RenderResult</code> <p>The rendered segments of the gradient rule.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def __rich_console__(\n    self, console: Console, options: ConsoleOptions\n) -&gt; RenderResult:\n    \"\"\"Render the gradient rule.\n\n    Args:\n        console (Console): The console to render to.\n        options (ConsoleOptions): The console options.\n\n    Yields:\n        RenderResult: The rendered segments of the gradient rule.\n    \"\"\"\n    # Prepare a base rule with no style to extract segments\n    base_rule = RichRule(\n        title=self.title or \"\",\n        characters=self.characters,\n        style=NULL_STYLE,\n        end=self.end,\n        align=cast(AlignMethod, self.align),\n    )\n    # Render the base rule to get segments\n    rule_segments = console.render(base_rule, options=options)\n    # Concatenate segment texts to form the full rule text (filter to Segment-like objects)\n    rule_text_parts: List[str] = []\n    for seg in rule_segments:\n        try:\n            text = seg.text\n        except Exception:\n            continue\n        rule_text_parts.append(text)\n    rule_text = \"\".join(rule_text_parts)\n\n    # If no title style, render the gradient text directly\n    if self.title_style == NULL_STYLE:\n        gradient_rule = Text(rule_text, colors=self.colors)\n        yield from console.render(gradient_rule, options)\n        return\n    # Create gradient text for the rule\n    gradient_rule = Text(rule_text, colors=self.colors)\n\n    # Extract the title string for highlighting\n    title = self.title.plain if isinstance(self.title, Text) else str(self.title)\n\n    # Apply the title style highlight after gradient generation\n    if title and self.title_style != NULL_STYLE:\n        gradient_rule.highlight_words([title], style=self.title_style)\n\n    # Yield the styled gradient text\n    yield from console.render(gradient_rule, options)\n</code></pre>"},{"location":"rule_ref/#rich_gradient.rule.Rule._parse_colors","title":"<code>_parse_colors(colors, rainbow, hues)</code>","text":"<p>Parse colors for the gradient.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>Sequence[ColorType]</code> <p>A sequence of colors supplied as strings, <code>Color</code> objects, <code>ColorTriplet</code> instances or RGB tuples.</p> required <code>rainbow</code> <code>bool</code> <p>If True, use a rainbow gradient.</p> required <code>hues</code> <code>int</code> <p>Number of hues in the gradient.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two colors are provided when colors are specified.</p> <code>ColorParseError</code> <p>If a provided color value cannot be interpreted.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of hex color strings for the gradient.</p> Source code in <code>src/rich_gradient/rule.py</code> <pre><code>def _parse_colors(\n    self,\n    colors: Sequence[ColorType],\n    rainbow: bool,\n    hues: int,\n) -&gt; List[str]:\n    \"\"\"Parse colors for the gradient.\n\n    Args:\n        colors (Sequence[ColorType]): A sequence of colors supplied as strings, ``Color`` objects,\n            ``ColorTriplet`` instances or RGB tuples.\n        rainbow (bool): If True, use a rainbow gradient.\n        hues (int): Number of hues in the gradient.\n\n    Raises:\n        ValueError: If fewer than two colors are provided when colors are specified.\n        ColorParseError: If a provided color value cannot be interpreted.\n\n    Returns:\n        List[str]: A list of hex color strings for the gradient.\n    \"\"\"\n    if rainbow:\n        return Spectrum(hues).hex\n\n    if colors and len(colors) &lt; 2:\n        raise ValueError(\n            f\"At least two colors are required for a gradient. Please provide at least two color values. Received: {colors!r}\"\n        )\n\n    if not colors:\n        return Spectrum(hues).hex\n\n    _colors: List[str] = []\n    for color in colors:\n        try:\n            if isinstance(color, Color):\n                _colors.append(color.get_truecolor().hex)\n            elif isinstance(color, ColorTriplet):\n                _colors.append(color.hex)\n            elif isinstance(color, tuple) and len(color) == 3:\n                _colors.append(ColorTriplet(*color).hex)\n            else:\n                _colors.append(Color.parse(color).get_truecolor().hex)\n        except (ColorParseError, TypeError, ValueError) as ce:\n            raise ValueError(\n                f\"Invalid color: {color}. Please provide a valid color value.\"\n            ) from ce\n    return _colors\n</code></pre>"},{"location":"spectrum/","title":"Spectrum","text":"<p><code>rich_gradient.spectrum.Spectrum</code> provides a convenient way to generate and preview a palette of colors used throughout rich-gradient:</p> <ul> <li>Generates a list of Rich <code>Color</code> objects spanning the spectrum.</li> <li>Supports <code>hues</code> count, optional reversal, and a <code>seed</code> for deterministic order.</li> <li>Exposes <code>.colors</code>, <code>.triplets</code>, <code>.styles</code>, <code>.hex</code>, and <code>.names</code>.</li> <li>Renders as a Rich table when printed.</li> </ul>"},{"location":"spectrum/#usage","title":"Usage","text":"<pre><code>from rich.console import Console\nfrom rich_gradient.spectrum import Spectrum\n\nconsole = Console()\nconsole.print(Spectrum(hues=8, seed=42), justify=\"center\")\n</code></pre>"},{"location":"spectrum_ref/","title":"Spectrum Reference","text":"<p>Create a list of concurrent Color and/or Style instances. Args:     hues (int): Number of colors to generate. Defaults to 17.     invert (bool, optional): If True, reverse the generated list. Defaults to False.     seed (Optional[int], optional): If provided, sets the random seed for deterministic color order.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>class Spectrum:\n    \"\"\"Create a list of concurrent Color and/or Style instances.\n    Args:\n        hues (int): Number of colors to generate. Defaults to 17.\n        invert (bool, optional): If True, reverse the generated list. Defaults to False.\n        seed (Optional[int], optional): If provided, sets the random seed for deterministic color order.\n    \"\"\"\n\n    def __init__(\n        self, hues: int = 17, invert: bool = False, seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Initialize the Spectrum with a specified number of hues and optional inversion and seed.\n        Args:\n            hues (int): Number of colors to generate. Defaults to 17.\n            invert (bool, optional): If True, reverse the generated list. Defaults to False.\n            seed (Optional[int], optional): If provided, sets the random seed for deterministic color order.\n        Raises:\n            ValueError: If hues &lt; 2.\n            ValueError: If seed is not None and not an integer.\n        Returns:\n            None\n        \"\"\"\n        if hues &lt; 2:\n            raise ValueError(\"hues must be at least 2\")\n        # Use a dedicated RNG to avoid mutating global random state\n        rng = Random(seed)\n        # Generate a random cycle of colors from the spectrum\n        colors: List[Color] = [Color.parse(color) for color in SPECTRUM_COLORS.keys()]\n        color_cycle = cycle(colors)\n        # Skip a pseudo-random number of colors to add variability, deterministically per seed\n        for _ in range(rng.randint(1, 18)):\n            next(color_cycle)\n        # Create a list of colors based on the specified number of hues\n        colors = [next(color_cycle) for _ in range(hues)]\n        self._colors: List[Color] = colors\n        if invert:\n            self._colors.reverse()\n        self._names = [\n            SPECTRUM_COLORS[color.get_truecolor().hex.upper()] for color in self._colors\n        ]\n        self._styles = [\n            Style(color=color, bold=False, italic=False, underline=False)\n            for color in self._colors\n        ]\n        self.hex = [color.get_truecolor().hex.upper() for color in self._colors]\n        # Do not maintain a stateful iterator; Spectrum is an iterable, not a stateful iterator.\n        # If consumers need an iterator, they should call iter(spectrum).\n        # self._iterator = iter(self._colors)\n\n    @property\n    def colors(self) -&gt; List[Color]:\n        \"\"\"Return the list of Color instances.\"\"\"\n        return self._colors\n\n    @colors.setter\n    def colors(self, value: List[Color]) -&gt; None:\n        \"\"\"Set the list of Color instances.\"\"\"\n        if not isinstance(value, list) or not all(isinstance(c, Color) for c in value):\n            raise ValueError(\"colors must be a list of Color instances\")\n        if len(value) &lt; 2:\n            raise ValueError(\"colors must contain at least two Color instances\")\n        self._colors = value\n\n    @property\n    def triplets(self) -&gt; List[ColorTriplet]:\n        \"\"\"Return the list of ColorTriplet instances.\"\"\"\n        return [color.get_truecolor() for color in self._colors]\n\n    @property\n    def styles(self) -&gt; List[Style]:\n        \"\"\"Return the list of Style instances.\"\"\"\n        return self._styles\n\n    @property\n    def names(self) -&gt; List[str]:\n        \"\"\"Return the list of color names.\"\"\"\n        return self._names\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Spectrum.\"\"\"\n        colors = [f\"{name}\" for name in self.names]\n        colors_str = \", \".join(colors)\n        return f\"Spectrum({colors_str})\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of colors in the Spectrum.\"\"\"\n        return len(self.colors)\n\n    def __getitem__(self, index: int) -&gt; Color:\n        \"\"\"Return the Color at the specified index.\"\"\"\n        if not isinstance(index, int):\n            raise TypeError(\"Index must be an integer\")\n        if index &lt; 0 or index &gt;= len(self.colors):\n            raise IndexError(\"Index out of range\")\n        return self.colors[index]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the colors in the Spectrum.\"\"\"\n        return iter(self.colors)\n\n    def __rich__(self) -&gt; Table:\n        \"\"\"Return a rich Table representation of the Spectrum.\"\"\"\n        table = Table(title=\"Spectrum Colors\")\n        table.add_column(\"[b white]Sample[/]\", justify=\"center\")\n        table.add_column(\"[b white]Color[/]\", style=\"bold\")\n        table.add_column(\"[b white]Hex[/]\", style=\"bold\")\n        table.add_column(\"[b white]Name[/]\", style=\"bold\")\n\n        for color, name in zip(self.colors, self.names):\n            hex_code = color.get_truecolor().hex\n            red = color.get_truecolor().red\n            green = color.get_truecolor().green\n            blue = color.get_truecolor().blue\n\n            name_text = Text(\n                name.capitalize(),\n                Style(color=hex_code, bold=True),\n                no_wrap=True,\n                justify=\"left\",\n            )\n            hex_text = Text(\n                f\" {hex_code.upper()} \",\n                Style(bgcolor=hex_code, color=\"#000000\", bold=True),\n                no_wrap=True,\n                justify=\"center\",\n            )\n            rgb_text = Text.assemble(*[\n                Text(\"rgb\", style=f\"bold {hex_code}\"),\n                Text(\"(\", style=\"i white\"),\n                Text(f\"{red:&gt;3}\", style=\"#FF0000\"),\n                Text(\",\", style=\"i #555\"),\n                Text(f\"{green:&gt;3}\", style=\"#00FF00\"),\n                Text(\",\", style=\"i #555\"),\n                Text(f\"{blue:&gt;3}\", style=\"#00AAFF\"),\n                Text(\")\", style=\"i white\"),\n            ])\n            sample = Text(\"\u2588\" * 10, style=Style(color=hex_code, bold=True))\n            table.add_row(sample, name_text, hex_text, rgb_text)\n        return table\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of Color instances.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.names","title":"<code>names</code>  <code>property</code>","text":"<p>Return the list of color names.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.styles","title":"<code>styles</code>  <code>property</code>","text":"<p>Return the list of Style instances.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.triplets","title":"<code>triplets</code>  <code>property</code>","text":"<p>Return the list of ColorTriplet instances.</p>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Return the Color at the specified index.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Color:\n    \"\"\"Return the Color at the specified index.\"\"\"\n    if not isinstance(index, int):\n        raise TypeError(\"Index must be an integer\")\n    if index &lt; 0 or index &gt;= len(self.colors):\n        raise IndexError(\"Index out of range\")\n    return self.colors[index]\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__init__","title":"<code>__init__(hues=17, invert=False, seed=None)</code>","text":"<p>Initialize the Spectrum with a specified number of hues and optional inversion and seed. Args:     hues (int): Number of colors to generate. Defaults to 17.     invert (bool, optional): If True, reverse the generated list. Defaults to False.     seed (Optional[int], optional): If provided, sets the random seed for deterministic color order. Raises:     ValueError: If hues &lt; 2.     ValueError: If seed is not None and not an integer. Returns:     None</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __init__(\n    self, hues: int = 17, invert: bool = False, seed: Optional[int] = None\n) -&gt; None:\n    \"\"\"Initialize the Spectrum with a specified number of hues and optional inversion and seed.\n    Args:\n        hues (int): Number of colors to generate. Defaults to 17.\n        invert (bool, optional): If True, reverse the generated list. Defaults to False.\n        seed (Optional[int], optional): If provided, sets the random seed for deterministic color order.\n    Raises:\n        ValueError: If hues &lt; 2.\n        ValueError: If seed is not None and not an integer.\n    Returns:\n        None\n    \"\"\"\n    if hues &lt; 2:\n        raise ValueError(\"hues must be at least 2\")\n    # Use a dedicated RNG to avoid mutating global random state\n    rng = Random(seed)\n    # Generate a random cycle of colors from the spectrum\n    colors: List[Color] = [Color.parse(color) for color in SPECTRUM_COLORS.keys()]\n    color_cycle = cycle(colors)\n    # Skip a pseudo-random number of colors to add variability, deterministically per seed\n    for _ in range(rng.randint(1, 18)):\n        next(color_cycle)\n    # Create a list of colors based on the specified number of hues\n    colors = [next(color_cycle) for _ in range(hues)]\n    self._colors: List[Color] = colors\n    if invert:\n        self._colors.reverse()\n    self._names = [\n        SPECTRUM_COLORS[color.get_truecolor().hex.upper()] for color in self._colors\n    ]\n    self._styles = [\n        Style(color=color, bold=False, italic=False, underline=False)\n        for color in self._colors\n    ]\n    self.hex = [color.get_truecolor().hex.upper() for color in self._colors]\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the colors in the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterator over the colors in the Spectrum.\"\"\"\n    return iter(self.colors)\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of colors in the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of colors in the Spectrum.\"\"\"\n    return len(self.colors)\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Spectrum.\"\"\"\n    colors = [f\"{name}\" for name in self.names]\n    colors_str = \", \".join(colors)\n    return f\"Spectrum({colors_str})\"\n</code></pre>"},{"location":"spectrum_ref/#rich_gradient.spectrum.Spectrum.__rich__","title":"<code>__rich__()</code>","text":"<p>Return a rich Table representation of the Spectrum.</p> Source code in <code>src/rich_gradient/spectrum.py</code> <pre><code>def __rich__(self) -&gt; Table:\n    \"\"\"Return a rich Table representation of the Spectrum.\"\"\"\n    table = Table(title=\"Spectrum Colors\")\n    table.add_column(\"[b white]Sample[/]\", justify=\"center\")\n    table.add_column(\"[b white]Color[/]\", style=\"bold\")\n    table.add_column(\"[b white]Hex[/]\", style=\"bold\")\n    table.add_column(\"[b white]Name[/]\", style=\"bold\")\n\n    for color, name in zip(self.colors, self.names):\n        hex_code = color.get_truecolor().hex\n        red = color.get_truecolor().red\n        green = color.get_truecolor().green\n        blue = color.get_truecolor().blue\n\n        name_text = Text(\n            name.capitalize(),\n            Style(color=hex_code, bold=True),\n            no_wrap=True,\n            justify=\"left\",\n        )\n        hex_text = Text(\n            f\" {hex_code.upper()} \",\n            Style(bgcolor=hex_code, color=\"#000000\", bold=True),\n            no_wrap=True,\n            justify=\"center\",\n        )\n        rgb_text = Text.assemble(*[\n            Text(\"rgb\", style=f\"bold {hex_code}\"),\n            Text(\"(\", style=\"i white\"),\n            Text(f\"{red:&gt;3}\", style=\"#FF0000\"),\n            Text(\",\", style=\"i #555\"),\n            Text(f\"{green:&gt;3}\", style=\"#00FF00\"),\n            Text(\",\", style=\"i #555\"),\n            Text(f\"{blue:&gt;3}\", style=\"#00AAFF\"),\n            Text(\")\", style=\"i white\"),\n        ])\n        sample = Text(\"\u2588\" * 10, style=Style(color=hex_code, bold=True))\n        table.add_row(sample, name_text, hex_text, rgb_text)\n    return table\n</code></pre>"},{"location":"text/","title":"rich_gradient.text.Text","text":"<p>If you pass <code>rich_gradient.text.Text</code> a string, it will print the string to the console in a random gradient. Rich-gradient's <code>Text</code> class inherits from <code>rich.text.Text</code>. In addition to all of it's parent's parameters, <code>rich_gradient.text.Text</code> also accepts:</p> <ul> <li><code>colors</code>: (<code>List[ColorType]</code>) - A list of strings that can be parsed by <code>rich.color.Color</code>.</li> </ul> \ud83d\udcdd Note<code>rich_color_ext</code> extends rich to be able to parse:   <ul> <li>CSS color names: <ul> <li>\u25c9 rebeccapurple</li> <li>\u25c9 salmon</li> <li>\u25c9 aliceblue</li> </ul> </li><li>3-Digit Hex Color Codes: <ul> <li>\u25c9 #abc</li> <li>\u25c9 #FDC</li> <li>\u25c9 #A1f          <ul> <li><code>bgcolors</code> (<code>List[ColorType]</code>) - A list of strings that can be parsed by `rich.color.Color to use as the color stops of the background of the style. If a single color is used - it is used for the entire background.</li> <li><code>hues</code>: (<code>int</code>) - The number of color stops a gradient should use</li> <li><code>rainbow</code>: (<code>bool</code>) - Whether to create a gradient that spans the entire spectrum. Defaults to <code>False</code></li> <li><code>markup</code>: (<code>bool</code>) - Whether to respect the inputs existing styles. Defaults  to <code>True</code></li> </ul>"},{"location":"text/#basic-usage-of-text","title":"Basic Usage of Text","text":""},{"location":"text/#gradient-text-with-specific-colors","title":"Gradient Text with Specific Colors","text":"<p>To have more control over the gradient that is printed, you can pass the <code>colors</code> parameter a list of colors. Colors can be parsed from: -  CSS colors names, -  3 or 6 digit hex codes, -  <code>rich.color.Color</code> instances or names, -  any string or style that <code>rich.color.Color</code> can parse.</p> <p></p>"},{"location":"text/#rainbow-gradient-text-example","title":"Rainbow Gradient Text Example","text":"<p>If four colors isn't enough, you can use the 'rainbow' parameter to generate a rainbow gradient that spans the entire spectrum of colors randomly.</p> <p></p> <p>*The rainbow gradient is generated randomly each time the code is run.</p>"},{"location":"text/#still-inherits-from-richtexttext","title":"Still inherits from <code>rich.text.Text</code>","text":"<p>Since <code>rich_gradient.text.Text</code> is a subclass of <code>rich.text.Text</code>, you can still use all the same methods and parameters as you would.</p> <p></p>"},{"location":"text/#rich_gradienttexttext-richtexttext","title":"<code>rich_gradient.text.Text \u2192 rich.text.Text</code>","text":"<p>As the rendering of <code>rich_gradient.text.Text</code> and <code>rich.text.Text</code> are identical, <code>rich_gradient.text.Text</code> has a <code>.as_rich()</code> method to convert an instance into a styled <code>rich.text.text</code>.</p> <p></p>"},{"location":"text_ref/","title":"Text","text":"<p>               Bases: <code>Text</code></p> <p>A rich text class that supports gradient colors and styles.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>class Text(RichText):\n    \"\"\"A rich text class that supports gradient colors and styles.\"\"\"\n\n    def __init__(\n        self,\n        text: TextType = \"\",\n        colors: Optional[Sequence[ColorType]] = None,\n        *,\n        rainbow: bool = False,\n        hues: int = 5,\n        style: StyleType = \"\",\n        justify: JustifyMethod = \"default\",\n        overflow: OverflowMethod = \"fold\",\n        no_wrap: bool = False,\n        end: str = \"\\n\",\n        tab_size: int = 4,\n        bgcolors: Optional[Sequence[ColorType]] = None,\n        markup: bool = True,\n        spans: Optional[Sequence[Span]] = None,\n    ):\n        \"\"\"Initialize the Text with gradient colors and styles.\n        Args:\n            text (TextType): The text content.\n            colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n            rainbow (bool): If True, generate a rainbow spectrum.\n            hues (int): The number of hues to generate if colors are not provided.\n            style (StyleType): The style of the text.\n            justify (JustifyMethod): Justification method for the text. Defaults to `default`.\n            overflow (OverflowMethod): Overflow method for the text. Defaults to `fold`.\n            no_wrap (bool): If True, disable wrapping of the text. Defaults to False.\n            end (str): The string to append at the end of the text. Default is a newline (`\\\\n`).\n            tab_size (int): The number of spaces for a tab character. Defaults to 4.\n            bgcolors (Optional[List[ColorType]]): A list of background colors as Color \\\ninstances. Defaults to None.\n            markup (bool): If True, parse Rich markup tags in the input text. Defaults to True.\n            spans (Optional[Sequence[Span]]): A list of spans to apply to the text. Defaults to None.\n        \"\"\"\n\n        # Parse the input text with or without markup\n        if markup:\n            parsed_text = RichText.from_markup(\n                text=str(text), style=style, justify=justify, overflow=overflow\n            )\n        else:\n            parsed_text = RichText(\n                strip_control_codes(str(text)),\n                style=style,\n                justify=justify,\n                overflow=overflow,\n            )\n\n        # Extract parsed attributes\n        plain = parsed_text.plain\n        parsed_justify = parsed_text.justify\n        parsed_overflow = parsed_text.overflow\n        parsed_spans = parsed_text._spans\n\n        # Initialize the parent class\n        super().__init__(\n            plain,\n            style=style,\n            justify=parsed_justify,\n            overflow=parsed_overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            spans=parsed_spans,\n        )\n        self._interpolate_bgcolors = False  # Ensure flag is always initialized\n        # Normalize color inputs into rich.color.Color instances\n        self.colors = self.parse_colors(colors, hues, rainbow)\n        self.bgcolors = self.parse_bgcolors(bgcolors, hues)\n\n        # Handle the single-color and single-background case: apply style directly and return early\n        if len(self.colors) == 1 and len(self.bgcolors) == 1:\n            # Apply the single color style directly. Parse the provided style only once.\n            if isinstance(style, str):\n                parsed_style = Style.parse(style)\n            elif isinstance(style, Style):\n                parsed_style = style\n            else:\n                parsed_style = Style.parse(str(style))\n            style_with_color = (\n                Style(color=self.colors[0], bgcolor=self.bgcolors[0]) + parsed_style\n            )\n            for index in range(len(self.plain)):\n                self.stylize(style_with_color, index, index + 1)\n            return\n\n        # Apply the gradient coloring\n        self.apply_gradient()\n\n    @property\n    def colors(self) -&gt; list[Color]:\n        \"\"\"Return the list of colors in the gradient.\"\"\"\n        return list(self._colors) if self._colors else []\n\n    @colors.setter\n    def colors(self, value: Optional[Sequence[Color]]) -&gt; None:\n        \"\"\"Set the list of colors in the gradient.\"\"\"\n        self._colors = list(value) if value else []\n\n    @property\n    def bgcolors(self) -&gt; list[Color]:\n        \"\"\"Return the list of background colors in the gradient.\"\"\"\n        return list(self._bgcolors) if self._bgcolors else []\n\n    @bgcolors.setter\n    def bgcolors(self, value: Optional[Sequence[Color]]) -&gt; None:\n        \"\"\"Set the list of background colors in the gradient.\"\"\"\n        self._bgcolors = list(value) if value else []\n\n    @staticmethod\n    def _normalize_color(value: ColorType) -&gt; Color:\n        \"\"\"Normalize a single color-like value to a rich.color.Color.\n        Accepts: Color, ColorTriplet, 3-tuple of ints, or string parsable\n        by Color.parse. Note that rich-color-ext expands what is considered\n        a valid color input.\n\n        Args:\n            value (ColorType): The color-like value to normalize.\n        Returns:\n            Color: The normalized Color instance.\n        Raises:\n            ColorParseError: If the color value cannot be parsed.\n        \"\"\"\n        try:\n            if isinstance(value, Color):\n                return value\n            elif isinstance(value, ColorTriplet):\n                return Color.from_rgb(value.red, value.green, value.blue)\n            elif isinstance(value, tuple) and len(value) == 3:\n                r, g, b = value\n                return Color.from_rgb(int(r), int(g), int(b))\n            else:\n                return Color.parse(str(value))\n        except ColorParseError as cpe:\n            raise ColorParseError(\n                f\"Failed to parse and normalize color: {value}\"\n            ) from cpe\n\n    @staticmethod\n    def parse_colors(\n        colors: Optional[Sequence[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of colors for the gradient.\n        Supports:\n        - rgb colors (e.g. `'rgb(255, 0, 0)'`)\n        - rgb tuples (e.g., `(255, 0, 0)`)\n        - 3-digit hex colors (e.g., `'#f00'`, `'#F90'`)\n        - 6-digit hex colors (e.g., `'#ff0000'`, `'#00FF00'`)\n        - CSS names (e.g., `'red'`, `'aliceblue'`)\n        - rich.color.Color objects (e.g., `Color.parse('#FF0000')`)\n        Args:\n            colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color\n                instances, tuples of integers, or strings.\n            hues (int): The number of hues to generate if colors are not provided. Defaults to 5.\n            rainbow (bool): Whether to generate a rainbow spectrum. Note that rainbow overrides\n                any colors or hues provided. Defaults to False\n        Raises:\n            ColorParseError: If any color value cannot be parsed.\n            ValueError: If no colors are provided, rainbow is False, and hues &lt; 2.\n        Returns:\n            List[rich.color.Color]: A list of Color objects.\n        \"\"\"\n        # When rainbow is True, we use a full 17-color spectrum\n        if rainbow:\n            return Spectrum(hues=17).colors\n\n        # If no colors are provided, fall back to Spectrum with the specified hues\n        if colors is None or len(colors) == 0:\n            if hues &lt; 2:\n                raise ValueError(\n                    f\"If `rainbow=False` and no colors are provided, hues must be \\\nat least 2. Invalid hues value: {hues}\"\n                )\n            return Spectrum(hues).colors\n\n        # If we have colors, parse and normalize them\n        parsed: List[Color] = []\n        for c in colors:\n            try:\n                parsed.append(Text._normalize_color(c))\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported color value: {c}\") from exc\n        return parsed\n\n    def parse_bgcolors(\n        self, bgcolors: Optional[Sequence[ColorType]] = None, hues: int = 5\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of background colors for the gradient.\n        Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n        Args:\n            bgcolors (Optional[Sequence[ColorType | Color]]): A list of background colors as Color instances or strings.\n            hues (int): The number of hues to generate if bgcolors are not provided.\n        Returns:\n            List[Color]: A list of Color objects for background colors.\n        \"\"\"\n        if bgcolors is None or len(bgcolors) == 0:\n            self._interpolate_bgcolors = False\n            # Default to transparent/default background per character count\n            return [Color.parse(\"default\")] * max(1, len(self.colors))\n\n        if len(bgcolors) == 1:\n            # If only one background color is provided, do not interpolate\n            self._interpolate_bgcolors = False\n            c = bgcolors[0]\n            try:\n                normalized = Text._normalize_color(c)\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n            return [normalized] * max(1, len(self.colors))\n\n        # Multiple bgcolors: interpolate across provided stops\n        self._interpolate_bgcolors = True\n        parsed_bg: List[Color] = []\n        for c in bgcolors:\n            try:\n                parsed_bg.append(Text._normalize_color(c))\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n        return parsed_bg\n\n    def interpolate_colors(\n        self, colors: Optional[Sequence[Color]] = None\n    ) -&gt; list[Color]:\n        \"\"\"Interpolate colors across the text using gamma-correct blending.\"\"\"\n        colors = list(colors) if colors is not None else self.colors\n        if not colors:\n            raise ValueError(\"No colors to interpolate\")\n\n        text = self.plain\n        length = len(text)\n        if length == 0:\n            return []\n        num_colors = len(colors)\n        if num_colors == 1:\n            return [colors[0]] * length\n\n        segments = num_colors - 1\n        result: List[Color] = []\n\n        GAMMA = 2.2\n\n        def to_linear(v: int) -&gt; float:\n            return (v / 255.0) ** GAMMA\n\n        def to_srgb(x: float) -&gt; int:\n            return int(((x ** (1.0 / GAMMA)) * 255.0))\n\n        for i in range(length):\n            pos = i / (length - 1) if length &gt; 1 else 0.0\n            fidx = pos * segments\n            idx = int(fidx)\n            if idx &gt;= segments:\n                idx = segments - 1\n                t = 1.0\n            else:\n                t = fidx - idx\n\n            c0 = colors[idx].get_truecolor()\n            c1 = colors[idx + 1].get_truecolor()\n\n            lr = to_linear(c0.red) + (to_linear(c1.red) - to_linear(c0.red)) * t\n            lg = to_linear(c0.green) + (to_linear(c1.green) - to_linear(c0.green)) * t\n            lb = to_linear(c0.blue) + (to_linear(c1.blue) - to_linear(c0.blue)) * t\n\n            r, g, b = to_srgb(lr), to_srgb(lg), to_srgb(lb)\n            result.append(Color.from_rgb(r, g, b))\n\n        return result\n\n    def apply_gradient(self) -&gt; None:\n        \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n        # Generate a color for each character\n        colors = self.interpolate_colors(self.colors)\n        if self._interpolate_bgcolors:\n            # Generate a background color for each character if bgcolors are interpolated\n            bgcolors = self.interpolate_colors(self.bgcolors)\n        else:\n            # If not interpolating background colors, use the first bgcolor for all characters\n            bgcolors = [self.bgcolors[0]] * len(colors)\n        # Apply a style span for each character with its corresponding color\n        for index, (color, bgcolor) in enumerate(zip(colors, bgcolors)):\n            # Build a style with the interpolated color\n            span_style = Style(color=color, bgcolor=bgcolor)\n            # Stylize the single character range\n            self.stylize(span_style, index, index + 1)\n\n\n    def as_rich(self) -&gt; RichText:\n        \"\"\"Return a plain ``rich.text.Text`` instance with styles and spans applied.\n\n        Args:\n            value (Text | TextType): Either an instance of this class (``Text``)\n                or a text-like value (``TextType``). If a non-``Text`` value is provided\n                a new ``Text`` will be constructed using any provided ``kwargs`` and\n                then converted.\n            kwargs (Any): Forwarded to the constructor when `value` is not already a\n                ``Text`` instance.\n\n        The returned object is a ``rich.text.Text`` (the base class) containing the\n        same plain content and spans/styles as the source. This is useful when a\n        consumer specifically needs an instance of the base ``rich.text.Text``\n        instead of the gradient-aware subclass.\n        \"\"\"\n        # Create a plain RichText that mirrors the source content and layout\n        rich_text = RichText(\n            self.plain,\n            style=self.style,\n            justify=self.justify,\n            overflow=self.overflow,\n            no_wrap=self.no_wrap,\n            end=self.end,\n            tab_size=self.tab_size,\n        )\n\n        # Copy internal spans from the source into the returned RichText.\n        # Using the internal _spans attribute is acceptable here since both\n        # classes share the same underlying implementation in rich.\n        for span in getattr(self, \"_spans\", []):\n            rich_text._spans.append(span)\n\n        return rich_text\n\n    @property\n    def rich(self) -&gt; RichText:\n        \"\"\"Return the underlying RichText instance.\"\"\"\n        return self.as_rich()\n\n    def __rich_console__(self, console: Console, options) -&gt; Iterable[Segment]:\n        \"\"\"Render Text while suppressing any output for empty content.\n\n        For empty plain text, yield no segments at all (no stray newlines).\n        Otherwise, delegate to the parent implementation and filter a final\n        trailing `end` segment as required.\n        \"\"\"\n        if self.plain == \"\":\n            return\n        for render_output in super().__rich_console__(console, options):\n            if isinstance(render_output, Segment):\n                # For empty Text, filter out both the empty text Segment and the trailing end Segment.\n                if self.plain == \"\" and render_output.text in (\"\", self.end):\n                    continue\n                yield render_output\n            else:\n                # Render nested renderable to segments, filter as needed\n                for seg in console.render(render_output, options):\n                    if self.plain == \"\" and seg.text in (\"\", self.end):\n                        continue\n                    yield seg\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.bgcolors","title":"<code>bgcolors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of background colors in the gradient.</p>"},{"location":"text_ref/#rich_gradient.text.Text.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Return the list of colors in the gradient.</p>"},{"location":"text_ref/#rich_gradient.text.Text.rich","title":"<code>rich</code>  <code>property</code>","text":"<p>Return the underlying RichText instance.</p>"},{"location":"text_ref/#rich_gradient.text.Text.__init__","title":"<code>__init__(text='', colors=None, *, rainbow=False, hues=5, style='', justify='default', overflow='fold', no_wrap=False, end='\\n', tab_size=4, bgcolors=None, markup=True, spans=None)</code>","text":"<p>Initialize the Text with gradient colors and styles. Args:     text (TextType): The text content.     colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.     rainbow (bool): If True, generate a rainbow spectrum.     hues (int): The number of hues to generate if colors are not provided.     style (StyleType): The style of the text.     justify (JustifyMethod): Justification method for the text. Defaults to <code>default</code>.     overflow (OverflowMethod): Overflow method for the text. Defaults to <code>fold</code>.     no_wrap (bool): If True, disable wrapping of the text. Defaults to False.     end (str): The string to append at the end of the text. Default is a newline (<code>\\n</code>).     tab_size (int): The number of spaces for a tab character. Defaults to 4.     bgcolors (Optional[List[ColorType]]): A list of background colors as Color instances. Defaults to None.     markup (bool): If True, parse Rich markup tags in the input text. Defaults to True.     spans (Optional[Sequence[Span]]): A list of spans to apply to the text. Defaults to None.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>    def __init__(\n        self,\n        text: TextType = \"\",\n        colors: Optional[Sequence[ColorType]] = None,\n        *,\n        rainbow: bool = False,\n        hues: int = 5,\n        style: StyleType = \"\",\n        justify: JustifyMethod = \"default\",\n        overflow: OverflowMethod = \"fold\",\n        no_wrap: bool = False,\n        end: str = \"\\n\",\n        tab_size: int = 4,\n        bgcolors: Optional[Sequence[ColorType]] = None,\n        markup: bool = True,\n        spans: Optional[Sequence[Span]] = None,\n    ):\n        \"\"\"Initialize the Text with gradient colors and styles.\n        Args:\n            text (TextType): The text content.\n            colors (Optional[List[ColorType]]): A list of colors as Color instances or strings.\n            rainbow (bool): If True, generate a rainbow spectrum.\n            hues (int): The number of hues to generate if colors are not provided.\n            style (StyleType): The style of the text.\n            justify (JustifyMethod): Justification method for the text. Defaults to `default`.\n            overflow (OverflowMethod): Overflow method for the text. Defaults to `fold`.\n            no_wrap (bool): If True, disable wrapping of the text. Defaults to False.\n            end (str): The string to append at the end of the text. Default is a newline (`\\\\n`).\n            tab_size (int): The number of spaces for a tab character. Defaults to 4.\n            bgcolors (Optional[List[ColorType]]): A list of background colors as Color \\\ninstances. Defaults to None.\n            markup (bool): If True, parse Rich markup tags in the input text. Defaults to True.\n            spans (Optional[Sequence[Span]]): A list of spans to apply to the text. Defaults to None.\n        \"\"\"\n\n        # Parse the input text with or without markup\n        if markup:\n            parsed_text = RichText.from_markup(\n                text=str(text), style=style, justify=justify, overflow=overflow\n            )\n        else:\n            parsed_text = RichText(\n                strip_control_codes(str(text)),\n                style=style,\n                justify=justify,\n                overflow=overflow,\n            )\n\n        # Extract parsed attributes\n        plain = parsed_text.plain\n        parsed_justify = parsed_text.justify\n        parsed_overflow = parsed_text.overflow\n        parsed_spans = parsed_text._spans\n\n        # Initialize the parent class\n        super().__init__(\n            plain,\n            style=style,\n            justify=parsed_justify,\n            overflow=parsed_overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            spans=parsed_spans,\n        )\n        self._interpolate_bgcolors = False  # Ensure flag is always initialized\n        # Normalize color inputs into rich.color.Color instances\n        self.colors = self.parse_colors(colors, hues, rainbow)\n        self.bgcolors = self.parse_bgcolors(bgcolors, hues)\n\n        # Handle the single-color and single-background case: apply style directly and return early\n        if len(self.colors) == 1 and len(self.bgcolors) == 1:\n            # Apply the single color style directly. Parse the provided style only once.\n            if isinstance(style, str):\n                parsed_style = Style.parse(style)\n            elif isinstance(style, Style):\n                parsed_style = style\n            else:\n                parsed_style = Style.parse(str(style))\n            style_with_color = (\n                Style(color=self.colors[0], bgcolor=self.bgcolors[0]) + parsed_style\n            )\n            for index in range(len(self.plain)):\n                self.stylize(style_with_color, index, index + 1)\n            return\n\n        # Apply the gradient coloring\n        self.apply_gradient()\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.__rich_console__","title":"<code>__rich_console__(console, options)</code>","text":"<p>Render Text while suppressing any output for empty content.</p> <p>For empty plain text, yield no segments at all (no stray newlines). Otherwise, delegate to the parent implementation and filter a final trailing <code>end</code> segment as required.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def __rich_console__(self, console: Console, options) -&gt; Iterable[Segment]:\n    \"\"\"Render Text while suppressing any output for empty content.\n\n    For empty plain text, yield no segments at all (no stray newlines).\n    Otherwise, delegate to the parent implementation and filter a final\n    trailing `end` segment as required.\n    \"\"\"\n    if self.plain == \"\":\n        return\n    for render_output in super().__rich_console__(console, options):\n        if isinstance(render_output, Segment):\n            # For empty Text, filter out both the empty text Segment and the trailing end Segment.\n            if self.plain == \"\" and render_output.text in (\"\", self.end):\n                continue\n            yield render_output\n        else:\n            # Render nested renderable to segments, filter as needed\n            for seg in console.render(render_output, options):\n                if self.plain == \"\" and seg.text in (\"\", self.end):\n                    continue\n                yield seg\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text._normalize_color","title":"<code>_normalize_color(value)</code>  <code>staticmethod</code>","text":"<p>Normalize a single color-like value to a rich.color.Color. Accepts: Color, ColorTriplet, 3-tuple of ints, or string parsable by Color.parse. Note that rich-color-ext expands what is considered a valid color input.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>ColorType</code> <p>The color-like value to normalize.</p> required <p>Returns:     Color: The normalized Color instance. Raises:     ColorParseError: If the color value cannot be parsed.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>@staticmethod\ndef _normalize_color(value: ColorType) -&gt; Color:\n    \"\"\"Normalize a single color-like value to a rich.color.Color.\n    Accepts: Color, ColorTriplet, 3-tuple of ints, or string parsable\n    by Color.parse. Note that rich-color-ext expands what is considered\n    a valid color input.\n\n    Args:\n        value (ColorType): The color-like value to normalize.\n    Returns:\n        Color: The normalized Color instance.\n    Raises:\n        ColorParseError: If the color value cannot be parsed.\n    \"\"\"\n    try:\n        if isinstance(value, Color):\n            return value\n        elif isinstance(value, ColorTriplet):\n            return Color.from_rgb(value.red, value.green, value.blue)\n        elif isinstance(value, tuple) and len(value) == 3:\n            r, g, b = value\n            return Color.from_rgb(int(r), int(g), int(b))\n        else:\n            return Color.parse(str(value))\n    except ColorParseError as cpe:\n        raise ColorParseError(\n            f\"Failed to parse and normalize color: {value}\"\n        ) from cpe\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.apply_gradient","title":"<code>apply_gradient()</code>","text":"<p>Apply interpolated colors as spans to each character in the text.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def apply_gradient(self) -&gt; None:\n    \"\"\"Apply interpolated colors as spans to each character in the text.\"\"\"\n    # Generate a color for each character\n    colors = self.interpolate_colors(self.colors)\n    if self._interpolate_bgcolors:\n        # Generate a background color for each character if bgcolors are interpolated\n        bgcolors = self.interpolate_colors(self.bgcolors)\n    else:\n        # If not interpolating background colors, use the first bgcolor for all characters\n        bgcolors = [self.bgcolors[0]] * len(colors)\n    # Apply a style span for each character with its corresponding color\n    for index, (color, bgcolor) in enumerate(zip(colors, bgcolors)):\n        # Build a style with the interpolated color\n        span_style = Style(color=color, bgcolor=bgcolor)\n        # Stylize the single character range\n        self.stylize(span_style, index, index + 1)\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.as_rich","title":"<code>as_rich()</code>","text":"<p>Return a plain <code>rich.text.Text</code> instance with styles and spans applied.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Text | TextType</code> <p>Either an instance of this class (<code>Text</code>) or a text-like value (<code>TextType</code>). If a non-<code>Text</code> value is provided a new <code>Text</code> will be constructed using any provided <code>kwargs</code> and then converted.</p> required <code>kwargs</code> <code>Any</code> <p>Forwarded to the constructor when <code>value</code> is not already a <code>Text</code> instance.</p> required <p>The returned object is a <code>rich.text.Text</code> (the base class) containing the same plain content and spans/styles as the source. This is useful when a consumer specifically needs an instance of the base <code>rich.text.Text</code> instead of the gradient-aware subclass.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def as_rich(self) -&gt; RichText:\n    \"\"\"Return a plain ``rich.text.Text`` instance with styles and spans applied.\n\n    Args:\n        value (Text | TextType): Either an instance of this class (``Text``)\n            or a text-like value (``TextType``). If a non-``Text`` value is provided\n            a new ``Text`` will be constructed using any provided ``kwargs`` and\n            then converted.\n        kwargs (Any): Forwarded to the constructor when `value` is not already a\n            ``Text`` instance.\n\n    The returned object is a ``rich.text.Text`` (the base class) containing the\n    same plain content and spans/styles as the source. This is useful when a\n    consumer specifically needs an instance of the base ``rich.text.Text``\n    instead of the gradient-aware subclass.\n    \"\"\"\n    # Create a plain RichText that mirrors the source content and layout\n    rich_text = RichText(\n        self.plain,\n        style=self.style,\n        justify=self.justify,\n        overflow=self.overflow,\n        no_wrap=self.no_wrap,\n        end=self.end,\n        tab_size=self.tab_size,\n    )\n\n    # Copy internal spans from the source into the returned RichText.\n    # Using the internal _spans attribute is acceptable here since both\n    # classes share the same underlying implementation in rich.\n    for span in getattr(self, \"_spans\", []):\n        rich_text._spans.append(span)\n\n    return rich_text\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.interpolate_colors","title":"<code>interpolate_colors(colors=None)</code>","text":"<p>Interpolate colors across the text using gamma-correct blending.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def interpolate_colors(\n    self, colors: Optional[Sequence[Color]] = None\n) -&gt; list[Color]:\n    \"\"\"Interpolate colors across the text using gamma-correct blending.\"\"\"\n    colors = list(colors) if colors is not None else self.colors\n    if not colors:\n        raise ValueError(\"No colors to interpolate\")\n\n    text = self.plain\n    length = len(text)\n    if length == 0:\n        return []\n    num_colors = len(colors)\n    if num_colors == 1:\n        return [colors[0]] * length\n\n    segments = num_colors - 1\n    result: List[Color] = []\n\n    GAMMA = 2.2\n\n    def to_linear(v: int) -&gt; float:\n        return (v / 255.0) ** GAMMA\n\n    def to_srgb(x: float) -&gt; int:\n        return int(((x ** (1.0 / GAMMA)) * 255.0))\n\n    for i in range(length):\n        pos = i / (length - 1) if length &gt; 1 else 0.0\n        fidx = pos * segments\n        idx = int(fidx)\n        if idx &gt;= segments:\n            idx = segments - 1\n            t = 1.0\n        else:\n            t = fidx - idx\n\n        c0 = colors[idx].get_truecolor()\n        c1 = colors[idx + 1].get_truecolor()\n\n        lr = to_linear(c0.red) + (to_linear(c1.red) - to_linear(c0.red)) * t\n        lg = to_linear(c0.green) + (to_linear(c1.green) - to_linear(c0.green)) * t\n        lb = to_linear(c0.blue) + (to_linear(c1.blue) - to_linear(c0.blue)) * t\n\n        r, g, b = to_srgb(lr), to_srgb(lg), to_srgb(lb)\n        result.append(Color.from_rgb(r, g, b))\n\n    return result\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.parse_bgcolors","title":"<code>parse_bgcolors(bgcolors=None, hues=5)</code>","text":"<p>Parse and return a list of background colors for the gradient. Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects. Args:     bgcolors (Optional[Sequence[ColorType | Color]]): A list of background colors as Color instances or strings.     hues (int): The number of hues to generate if bgcolors are not provided. Returns:     List[Color]: A list of Color objects for background colors.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>def parse_bgcolors(\n    self, bgcolors: Optional[Sequence[ColorType]] = None, hues: int = 5\n) -&gt; List[Color]:\n    \"\"\"Parse and return a list of background colors for the gradient.\n    Supports 3-digit hex colors (e.g., '#f00', '#F90'), 6-digit hex, CSS names, and Color objects.\n    Args:\n        bgcolors (Optional[Sequence[ColorType | Color]]): A list of background colors as Color instances or strings.\n        hues (int): The number of hues to generate if bgcolors are not provided.\n    Returns:\n        List[Color]: A list of Color objects for background colors.\n    \"\"\"\n    if bgcolors is None or len(bgcolors) == 0:\n        self._interpolate_bgcolors = False\n        # Default to transparent/default background per character count\n        return [Color.parse(\"default\")] * max(1, len(self.colors))\n\n    if len(bgcolors) == 1:\n        # If only one background color is provided, do not interpolate\n        self._interpolate_bgcolors = False\n        c = bgcolors[0]\n        try:\n            normalized = Text._normalize_color(c)\n        except Exception as exc:  # pragma: no cover - defensive\n            raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n        return [normalized] * max(1, len(self.colors))\n\n    # Multiple bgcolors: interpolate across provided stops\n    self._interpolate_bgcolors = True\n    parsed_bg: List[Color] = []\n    for c in bgcolors:\n        try:\n            parsed_bg.append(Text._normalize_color(c))\n        except Exception as exc:  # pragma: no cover - defensive\n            raise ColorParseError(f\"Unsupported background color: {c}\") from exc\n    return parsed_bg\n</code></pre>"},{"location":"text_ref/#rich_gradient.text.Text.parse_colors","title":"<code>parse_colors(colors=None, hues=5, rainbow=False)</code>  <code>staticmethod</code>","text":"<p>Parse and return a list of colors for the gradient. Supports: - rgb colors (e.g. <code>'rgb(255, 0, 0)'</code>) - rgb tuples (e.g., <code>(255, 0, 0)</code>) - 3-digit hex colors (e.g., <code>'#f00'</code>, <code>'#F90'</code>) - 6-digit hex colors (e.g., <code>'#ff0000'</code>, <code>'#00FF00'</code>) - CSS names (e.g., <code>'red'</code>, <code>'aliceblue'</code>) - rich.color.Color objects (e.g., <code>Color.parse('#FF0000')</code>) Args:     colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color         instances, tuples of integers, or strings.     hues (int): The number of hues to generate if colors are not provided. Defaults to 5.     rainbow (bool): Whether to generate a rainbow spectrum. Note that rainbow overrides         any colors or hues provided. Defaults to False Raises:     ColorParseError: If any color value cannot be parsed.     ValueError: If no colors are provided, rainbow is False, and hues &lt; 2. Returns:     List[rich.color.Color]: A list of Color objects.</p> Source code in <code>src/rich_gradient/text.py</code> <pre><code>    @staticmethod\n    def parse_colors(\n        colors: Optional[Sequence[ColorType]] = None,\n        hues: int = 5,\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Parse and return a list of colors for the gradient.\n        Supports:\n        - rgb colors (e.g. `'rgb(255, 0, 0)'`)\n        - rgb tuples (e.g., `(255, 0, 0)`)\n        - 3-digit hex colors (e.g., `'#f00'`, `'#F90'`)\n        - 6-digit hex colors (e.g., `'#ff0000'`, `'#00FF00'`)\n        - CSS names (e.g., `'red'`, `'aliceblue'`)\n        - rich.color.Color objects (e.g., `Color.parse('#FF0000')`)\n        Args:\n            colors (Optional[Sequence[ColorType | Color]]): A list of colors as Color\n                instances, tuples of integers, or strings.\n            hues (int): The number of hues to generate if colors are not provided. Defaults to 5.\n            rainbow (bool): Whether to generate a rainbow spectrum. Note that rainbow overrides\n                any colors or hues provided. Defaults to False\n        Raises:\n            ColorParseError: If any color value cannot be parsed.\n            ValueError: If no colors are provided, rainbow is False, and hues &lt; 2.\n        Returns:\n            List[rich.color.Color]: A list of Color objects.\n        \"\"\"\n        # When rainbow is True, we use a full 17-color spectrum\n        if rainbow:\n            return Spectrum(hues=17).colors\n\n        # If no colors are provided, fall back to Spectrum with the specified hues\n        if colors is None or len(colors) == 0:\n            if hues &lt; 2:\n                raise ValueError(\n                    f\"If `rainbow=False` and no colors are provided, hues must be \\\nat least 2. Invalid hues value: {hues}\"\n                )\n            return Spectrum(hues).colors\n\n        # If we have colors, parse and normalize them\n        parsed: List[Color] = []\n        for c in colors:\n            try:\n                parsed.append(Text._normalize_color(c))\n            except Exception as exc:  # pragma: no cover - defensive\n                raise ColorParseError(f\"Unsupported color value: {c}\") from exc\n        return parsed\n</code></pre>"},{"location":"theme_ref/","title":"Theme Reference","text":"<p>               Bases: <code>Theme</code></p> <p>A container for style information used by 'rich.console.Console'.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>Dict[str, Style]</code> <p>A mapping of style names on to             styles. Defaults to None for a theme with no styles.</p> <code>DEFAULT_STYLES</code> <code>inherit</code> <code>bool</code> <p>Inherit default styles. Defaults to True.</p> required Source code in <code>src/rich_gradient/theme.py</code> <pre><code>class GradientTheme(Theme):\n    \"\"\"A container for style information used by 'rich.console.Console'.\n\n    Args:\n        styles (Dict[str, Style], optional): A mapping of style names on to \\\n            styles. Defaults to None for a theme with no styles.\n        inherit (bool, optional): Inherit default styles. Defaults to True.\n    \"\"\"\n\n    # styles: Dict[str, Style] = {}\n\n    def __init__(self, styles: Dict[str, StyleType] = DEFAULT_STYLES) -&gt; None:\n        \"\"\"Initialize the GradientTheme with default styles.\"\"\"\n        super().__init__(styles=styles, inherit=True)\n        self._theme: Theme = Theme(DEFAULT_STYLES)\n        self._styles: Dict[str, StyleType] = styles\n\n    @property\n    def theme(self) -&gt; Theme:\n        return self._theme\n\n    @theme.setter\n    def theme(self, theme: Theme = Theme(DEFAULT_STYLES)) -&gt; None:\n        self._theme = theme\n\n    def __call__(self) -&gt; Theme:\n        return self.theme\n\n    def __repr__(self) -&gt; str:\n        return f\"GradientTheme({self._styles!r})\"\n\n    def __rich__(self) -&gt; Table:\n        return styles_table()\n\n    def __getitem__(self, name: str) -&gt; Style:\n        return Style.parse(str(self._styles[name]))\n\n    @classmethod\n    def get_theme_table(cls) -&gt; Table:\n        \"\"\"Get a table of all styles in the theme.\"\"\"\n        return styles_table()\n</code></pre> <p>Note: <code>GRADIENT_TERMINAL_THEME</code> is a terminal theme constant exported from <code>rich_gradient.theme</code> for use with <code>Console.save_svg</code>. It is not included in the auto-generated API table above but is part of the public API.</p>"},{"location":"theme_ref/#rich_gradient.theme.GradientTheme.__init__","title":"<code>__init__(styles=DEFAULT_STYLES)</code>","text":"<p>Initialize the GradientTheme with default styles.</p> Source code in <code>src/rich_gradient/theme.py</code> <pre><code>def __init__(self, styles: Dict[str, StyleType] = DEFAULT_STYLES) -&gt; None:\n    \"\"\"Initialize the GradientTheme with default styles.\"\"\"\n    super().__init__(styles=styles, inherit=True)\n    self._theme: Theme = Theme(DEFAULT_STYLES)\n    self._styles: Dict[str, StyleType] = styles\n</code></pre>"},{"location":"theme_ref/#rich_gradient.theme.GradientTheme.get_theme_table","title":"<code>get_theme_table()</code>  <code>classmethod</code>","text":"<p>Get a table of all styles in the theme.</p> Source code in <code>src/rich_gradient/theme.py</code> <pre><code>@classmethod\ndef get_theme_table(cls) -&gt; Table:\n    \"\"\"Get a table of all styles in the theme.\"\"\"\n    return styles_table()\n</code></pre>"}]}